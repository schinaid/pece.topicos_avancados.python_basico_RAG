<!DOCTYPE html>

<html lang="pt-BR" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Protocolo de Buffer" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/buffer.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Certos objetos disponíveis no Python envolvem o acesso a um vetor ou buffer de memória subjacente. Esses objetos incluem as bytes e bytearray embutidas, e alguns tipos de extensão como array.array...." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_c-api_buffer_76571f13.png" />
<meta property="og:image:alt" content="Certos objetos disponíveis no Python envolvem o acesso a um vetor ou buffer de memória subjacente. Esses objetos incluem as bytes e bytearray embutidas, e alguns tipos de extensão como array.array...." />
<meta name="description" content="Certos objetos disponíveis no Python envolvem o acesso a um vetor ou buffer de memória subjacente. Esses objetos incluem as bytes e bytearray embutidas, e alguns tipos de extensão como array.array...." />
<meta name="twitter:card" content="summary_large_image" />

    <title>Protocolo de Buffer &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=62a4a58b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=71a39b36"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="Camada de Objetos Concretos" href="concrete.html" />
    <link rel="prev" title="Protocolo Iterador" href="iter.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/c-api/buffer.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">Protocolo de Buffer</a><ul>
<li><a class="reference internal" href="#buffer-structure">Estrutura de Buffer</a></li>
<li><a class="reference internal" href="#buffer-request-types">Tipos de solicitação do buffer</a><ul>
<li><a class="reference internal" href="#request-independent-fields">campos independentes do pedido</a></li>
<li><a class="reference internal" href="#readonly-format">apenas em formato</a></li>
<li><a class="reference internal" href="#shape-strides-suboffsets">forma, avanços, suboffsets</a></li>
<li><a class="reference internal" href="#contiguity-requests">requisições contíguas</a></li>
<li><a class="reference internal" href="#compound-requests">requisições compostas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-arrays">Vetores Complexos</a><ul>
<li><a class="reference internal" href="#numpy-style-shape-and-strides">Estilo NumPy: forma e avanços</a></li>
<li><a class="reference internal" href="#pil-style-shape-strides-and-suboffsets">Estilo-PIL: forma, avanços e suboffsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-related-functions">Funções relacionadas ao Buffer</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="iter.html"
                          title="capítulo anterior">Protocolo Iterador</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="concrete.html"
                          title="próximo capítulo">Camada de Objetos Concretos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/buffer.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="concrete.html" title="Camada de Objetos Concretos"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="iter.html" title="Protocolo Iterador"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referência da API Python/C</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" accesskey="U">Camada de Objetos Abstratos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Protocolo de Buffer</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="buffer-protocol">
<span id="bufferobjects"></span><span id="index-0"></span><h1 class="translated">Protocolo de Buffer<a class="headerlink" href="#buffer-protocol" title="Link para este cabeçalho">¶</a></h1>
<p class="translated">Certos objetos disponíveis no Python envolvem o acesso a um vetor ou <em>buffer</em> de memória subjacente. Esses objetos incluem as <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> embutidas, e alguns tipos de extensão como <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>. As bibliotecas de terceiros podem definir seus próprios tipos para fins especiais, como processamento de imagem ou análise numérica.</p>
<p class="translated">Embora cada um desses tipos tenha sua própria semântica, eles compartilham a característica comum de serem suportados por um buffer de memória possivelmente grande. É desejável, em algumas situações, acessar esse buffer diretamente e sem cópia intermediária.</p>
<p class="translated">Python fornece essa facilidade no nível C e Python sob a forma de <a class="reference internal" href="#bufferobjects"><span class="std std-ref">protocolo de buffer</span></a>. Este protocolo tem dois lados:</p>
<ul class="simple" id="index-1">
<li><p class="translated">do lado do produtor, um tipo pode exportar uma “interface de buffer” que permite que objetos desse tipo exponham informações sobre o buffer subjacente. Esta interface é descrita na seção <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>; para Python, consulte <a class="reference internal" href="../reference/datamodel.html#python-buffer-protocol"><span class="std std-ref">Emulando tipos buffer</span></a>.</p></li>
<li><p class="translated">do lado do consumidor, vários meios estão disponíveis para obter o ponteiro para os dados subjacentes de um objeto (por exemplo, um parâmetro de método). Para Python, consulte <a class="reference internal" href="../reference/datamodel.html#python-buffer-protocol"><span class="std std-ref">Emulando tipos buffer</span></a>.</p></li>
</ul>
<p class="translated">Objetos simples como <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> expõem seu buffer subjacente em uma forma orientada a byte. Outras formas são possíveis; por exemplo, os elementos expostos por uma <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> podem ser valores de vários bytes.</p>
<p class="translated">Um exemplo de interface de um consumidor de buffer é o método <a class="reference internal" href="../library/io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> de objetos arquivo: qualquer objeto que possa exportar uma série de bytes por meio da interface de buffer pode ser gravado em um arquivo. Enquanto o <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> precisa apenas de acesso de somente leitura ao conteúdo interno do objeto passado, outros métodos, como <a class="reference internal" href="../library/io.html#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readinto()</span></code></a>, precisam de acesso de somente escrita ao conteúdo interno. A interface de buffer permite que o objetos possam permitir ou rejeitar a exportação para buffers de leitura e escrita ou somente leitura.</p>
<p class="translated">Existem duas maneiras para um consumidor da interface de buffer adquirir um buffer em um objeto alvo:</p>
<ul class="simple">
<li><p class="translated">chamada de <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> com os parâmetros certos;</p></li>
<li><p class="translated">chamada de <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> (ou um dos seus irmãos) com um dos <a class="reference internal" href="arg.html#arg-parsing"><span class="std std-ref">códigos de formatação</span></a> <code class="docutils literal notranslate"><span class="pre">y*</span></code>, <code class="docutils literal notranslate"><span class="pre">w*</span></code> ou <code class="docutils literal notranslate"><span class="pre">s*</span></code>.</p></li>
</ul>
<p class="translated">Em ambos os casos, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> deve ser chamado quando o buffer não é mais necessário. A falta de tal pode levar a várias questões, tais como vazamentos de recursos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.12: </span>O protocolo de buffer agora está acessível em Python, veja <a class="reference internal" href="../reference/datamodel.html#python-buffer-protocol"><span class="std std-ref">Emulando tipos buffer</span></a> e <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>.</p>
</div>
<section id="buffer-structure">
<span id="id1"></span><h2 class="translated">Estrutura de Buffer<a class="headerlink" href="#buffer-structure" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">As estruturas de buffer (ou simplesmente “buffers”) são úteis como uma maneira de expor os dados binários de outro objeto para o programador Python. Eles também podem ser usados como um mecanismo de cópia silenciosa. Usando sua capacidade de fazer referência a um bloco de memória, é possível expor facilmente qualquer dado ao programador Python. A memória pode ser uma matriz grande e constante em uma extensão C, pode ser um bloco bruto de memória para manipulação antes de passar para uma biblioteca do sistema operacional, ou pode ser usado para transmitir dados estruturados no formato nativo e formato de memória.</p>
<p class="translated">Ao contrário da maioria dos tipos de dados expostos pelo interpretador Python, os buffers não são ponteiros <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> mas sim estruturas C simples. Isso permite que eles sejam criados e copiados de forma muito simples. Quando um invólucro genérico em torno de um buffer é necessário, um objeto <a class="reference internal" href="memoryview.html#memoryview-objects"><span class="std std-ref">memoryview</span></a> pode ser criado.</p>
<p class="translated">Para obter instruções curtas sobre como escrever um objeto exportador, consulte <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>. Para obter um buffer, veja <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.Py_buffer">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_buffer</span></span></span><a class="headerlink" href="#c.Py_buffer" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> (incluindo todos os membros) desde a versão 3.11.</em><dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">buf</span></span></span><a class="headerlink" href="#c.Py_buffer.buf" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Um ponteiro para o início da estrutura lógica descrita pelos campos do buffer. Este pode ser qualquer local dentro do bloco de memória física subjacente do exportador. Por exemplo, com negativo <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> o valor pode apontar para o final do bloco de memória.</p>
<p class="translated">Para vetores <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contíguos</span></a>, o valor aponta para o início do bloco de memória.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.obj">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">obj</span></span></span><a class="headerlink" href="#c.Py_buffer.obj" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Uma nova referência ao objeto sendo exporta. A referência pertence ao consumidor e é automaticamente liberada (por exemplo, a contagem de referências é decrementada) e é atribuída para <code class="docutils literal notranslate"><span class="pre">NULL</span></code>  por <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>. O campo é equivalmente ao valor de retorno de qualquer função do padrão C-API.</p>
<p class="translated">Como um caso especial, para buffers <em>temporários</em> que são encapsulados por <a class="reference internal" href="memoryview.html#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMemoryView_FromBuffer()</span></code></a> ou <a class="reference internal" href="#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a> esse campo é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Em geral, objetos exportadores NÃO DEVEM usar esse esquema.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.len">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">len</span></span></span><a class="headerlink" href="#c.Py_buffer.len" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated"><code class="docutils literal notranslate"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span></code>. Para matrizes contíguas, este é o comprimento do bloco de memória subjacente. Para matrizes não contíguas, é o comprimento que a estrutura lógica teria se fosse copiado para uma representação contígua.</p>
<p class="translated">Acessando <code class="docutils literal notranslate"><span class="pre">((char</span> <span class="pre">*)buf)[0]</span> <span class="pre">up</span> <span class="pre">to</span> <span class="pre">((char</span> <span class="pre">*)buf)[len-1]</span></code> só é válido se o buffer tiver sido obtido por uma solicitação que garanta a contiguidade. Na maioria dos casos, esse pedido será <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a> ou <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.readonly">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readonly</span></span></span><a class="headerlink" href="#c.Py_buffer.readonly" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Um indicador de se o buffer é somente leitura. Este campo é controlado pelo sinalizador <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.itemsize">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">itemsize</span></span></span><a class="headerlink" href="#c.Py_buffer.itemsize" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">O tamanho do item em bytes de um único elemento. O mesmo que o valor de <a class="reference internal" href="../library/struct.html#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">struct.calcsize()</span></code></a> chamado em valores não <code class="docutils literal notranslate"><span class="pre">NULL</span></code> de <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>.</p>
<p class="translated">Exceção importante: Se um consumidor requisita um buffer sem sinalizador <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a>, <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a> será definido como <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, mas <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> ainda terá seu valor para o formato original.</p>
<p class="translated">Se <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> está presente, a igualdade <code class="docutils literal notranslate"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len</span></code> ainda é válida e o usuário pode usar <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> para navegar o buffer.</p>
<p class="translated">Se <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> é <code class="docutils literal notranslate"><span class="pre">NULL</span></code> como resultado de uma <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a> ou uma requisição <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>, o consumidor deve ignorar <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> e presumir <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.format">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">format</span></span></span><a class="headerlink" href="#c.Py_buffer.format" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Uma string terminada por <em>NULL</em> no estilo de sintaxe de módulo <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> descrevendo os conteúdos de um único item. Se isso é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> (unsigned bytes) é presumido.</p>
<p class="translated">Este campo é controlado pelo sinalizador <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.ndim">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ndim</span></span></span><a class="headerlink" href="#c.Py_buffer.ndim" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">O número de dimensões de memória representado como um array n-dimensional. Se for <code class="docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a> aponta para um único elemento representando um escalar. Neste caso, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> e <a class="reference internal" href="#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code class="xref c c-member docutils literal notranslate"><span class="pre">suboffsets</span></code></a> DEVEM ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. O número máximo de dimensões é dado por <a class="reference internal" href="#c.PyBUF_MAX_NDIM" title="PyBUF_MAX_NDIM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_MAX_NDIM</span></code></a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.shape">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">shape</span></span></span><a class="headerlink" href="#c.Py_buffer.shape" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Uma matriz de <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> do comprimento <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a> indicando a forma da memória como uma matriz n-dimensional. Observe que a forma <code class="docutils literal notranslate"><span class="pre">shape[0]</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">shape[ndim-1]</span> <span class="pre">*</span> <span class="pre">itemsize</span></code> DEVE ser igual a <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code class="xref c c-member docutils literal notranslate"><span class="pre">len</span></code></a>.</p>
<p class="translated">Os valores da forma são restritos a <code class="docutils literal notranslate"><span class="pre">shape[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>. The case <code class="docutils literal notranslate"><span class="pre">shape[n]</span> <span class="pre">==</span> <span class="pre">0</span></code> requer atenção especial. Veja <a class="reference internal" href="#complex-arrays">complex arrays</a> para mais informações.</p>
<p class="translated">A forma de acesso a matriz é de somente leitura para o usuário.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.strides">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">strides</span></span></span><a class="headerlink" href="#c.Py_buffer.strides" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Um vetor de <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> de comprimento <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a> dando o número de bytes para saltar para obter um novo elemento em cada dimensão.</p>
<p class="translated">Os valores de Stride podem ser qualquer número inteiro. Para arrays regulares, os passos são geralmente positivos, mas um consumidor DEVE ser capaz de lidar com o caso <code class="docutils literal notranslate"><span class="pre">strides[n]</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>. Veja <a class="reference internal" href="#complex-arrays">complex arrays</a> para mais informações.</p>
<p class="translated">A matriz de passos é somente leitura para o consumidor.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.suboffsets">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">suboffsets</span></span></span><a class="headerlink" href="#c.Py_buffer.suboffsets" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Uma matriz de <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> de comprimento <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>. Se <code class="docutils literal notranslate"><span class="pre">suboffsets[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, os valores armazenados ao longo da n-ésima dimensão são ponteiros e o valor suboffset determina quantos bytes para adicionar a cada ponteiro após desreferenciar. Um valor de suboffset que é negativo indica que não deve ocorrer desreferenciação (caminhando em um bloco de memória contíguo).</p>
<p class="translated">Se todos os subconjuntos forem negativos (ou seja, não é necessário fazer referência), então este campo deve ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (o valor padrão).</p>
<p class="translated">Esse tipo de representação de matriz é usado pela Python Imaging Library (PIL). Veja <a class="reference internal" href="#complex-arrays">complex arrays</a> para obter mais informações sobre como acessar elementos dessa matriz.a matriz.</p>
<p class="translated">A matriz de subconjuntos é somente leitura para o consumidor.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.Py_buffer.internal">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">internal</span></span></span><a class="headerlink" href="#c.Py_buffer.internal" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Isso é para uso interno pelo objeto exportador. Por exemplo, isso pode ser re-moldado como um número inteiro pelo exportador e usado para armazenar bandeiras sobre se os conjuntos de forma, passos e suboffsets devem ou não ser liberados quando o buffer é liberado. O consumidor NÃO DEVE alterar esse valor.</p>
</dd></dl>

</dd></dl>

<p class="translated">Constantes:</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_MAX_NDIM">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_MAX_NDIM</span></span></span><a class="headerlink" href="#c.PyBUF_MAX_NDIM" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">O número máximo de dimensões que a memória representa. Exportadores DEVEM respeitar esse limite, consumidores de buffers multi-dimensionais DEVEM ser capazes de liader com até <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_MAX_NDIM</span></code> dimensões. Atualmente definido como 64.</p>
</dd></dl>

</section>
<section id="buffer-request-types">
<span id="id2"></span><h2 class="translated">Tipos de solicitação do buffer<a class="headerlink" href="#buffer-request-types" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Os buffers geralmente são obtidos enviando uma solicitação de buffer para um objeto exportador via <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>. Uma vez que a complexidade da estrutura lógica da memória pode variar drasticamente, o consumidor usa o argumento <em>flags</em> para especificar o tipo de buffer exato que pode manipular.</p>
<p class="translated">Todos os campos <a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> são definidos de forma não-ambígua pelo tipo de requisição.</p>
<section id="request-independent-fields">
<h3 class="translated">campos independentes do pedido<a class="headerlink" href="#request-independent-fields" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os seguintes campos não são influenciados por <em>flags</em> e devem sempre ser preenchidos com os valores corretos: <a class="reference internal" href="#c.Py_buffer.obj" title="Py_buffer.obj"><code class="xref c c-member docutils literal notranslate"><span class="pre">obj</span></code></a>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>, <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code class="xref c c-member docutils literal notranslate"><span class="pre">len</span></code></a>, <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>.</p>
</section>
<section id="readonly-format">
<h3 class="translated">apenas em formato<a class="headerlink" href="#readonly-format" title="Link para este cabeçalho">¶</a></h3>
<blockquote>
<div><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_WRITABLE">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_WRITABLE</span></span></span><a class="headerlink" href="#c.PyBUF_WRITABLE" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Controla o campo <a class="reference internal" href="#c.Py_buffer.readonly" title="Py_buffer.readonly"><code class="xref c c-member docutils literal notranslate"><span class="pre">readonly</span></code></a> . Se configurado, o exportador DEVE fornecer um buffer gravável ou então relatar falha. Do contrário, o exportador PODE fornecer um buffer somente leitura ou um buffer gravável , mas a escolha DEVE ser consistente para todos os consumidores. Por exemplo, <span class="c-expr sig sig-inline c"><a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><span class="n">PyBUF_SIMPLE</span></a><span class="w"> </span><span class="o">|</span><span class="w"> </span><a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><span class="n">PyBUF_WRITABLE</span></a></span> pode ser usado para requisitar um buffer simples gravável.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_FORMAT">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_FORMAT</span></span></span><a class="headerlink" href="#c.PyBUF_FORMAT" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">Controla o campo <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>. Se configurado, este campo DEVE ser preenchido corretamente. Caso contrário, este campo DEVE ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

</div></blockquote>
<p class="translated">:<a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> pode ser |’d para qualquer um dos sinalizadores na próxima seção. Uma vez que <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> é definido como 0, <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> pode ser usado como uma bandeira autônoma para solicitar um buffer simples gravável.</p>
<p class="translated"><a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a> deve ser |’d para qualquer um dos sinalizadores exceto <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a>, uma vez que este já indica que o formato <code class="docutils literal notranslate"><span class="pre">B</span></code> (unsigned bytes). <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code> não pode ser utilizado sozinho.</p>
</section>
<section id="shape-strides-suboffsets">
<h3 class="translated">forma, avanços, suboffsets<a class="headerlink" href="#shape-strides-suboffsets" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">As bandeiras que controlam a estrutura lógica da memória estão listadas em ordem decrescente de complexidade. Observe que cada bandeira contém todos os bits das bandeiras abaixo.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Solicitação</p></th>
<th class="head"><p class="translated">Forma</p></th>
<th class="head"><p class="translated">Avanços</p></th>
<th class="head"><p class="translated">subconjuntos</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_INDIRECT">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_INDIRECT</span></span></span><a class="headerlink" href="#c.PyBUF_INDIRECT" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">se necessário</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_STRIDES">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_STRIDES</span></span></span><a class="headerlink" href="#c.PyBUF_STRIDES" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_ND">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_ND</span></span></span><a class="headerlink" href="#c.PyBUF_ND" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_SIMPLE">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_SIMPLE</span></span></span><a class="headerlink" href="#c.PyBUF_SIMPLE" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">NULL</p></td>
</tr>
</tbody>
</table>
</section>
<section id="contiguity-requests">
<span id="index-2"></span><h3 class="translated">requisições contíguas<a class="headerlink" href="#contiguity-requests" title="Link para este cabeçalho">¶</a></h3>
<p class="translated"><a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguity</span></a> do C ou Fortran podem ser explicitamente solicitadas, com ou sem informação de avanço. Sem informação de avanço, o buffer deve ser C-contíguo.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Solicitação</p></th>
<th class="head"><p class="translated">Forma</p></th>
<th class="head"><p class="translated">Avanços</p></th>
<th class="head"><p class="translated">subconjuntos</p></th>
<th class="head"><p class="translated">contig</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_C_CONTIGUOUS">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_C_CONTIGUOUS</span></span></span><a class="headerlink" href="#c.PyBUF_C_CONTIGUOUS" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">C</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_F_CONTIGUOUS">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_F_CONTIGUOUS</span></span></span><a class="headerlink" href="#c.PyBUF_F_CONTIGUOUS" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">F</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_ANY_CONTIGUOUS">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_ANY_CONTIGUOUS</span></span></span><a class="headerlink" href="#c.PyBUF_ANY_CONTIGUOUS" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">C ou F</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#c.PyBUF_ND" title="PyBUF_ND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_ND</span></code></a></p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">C</p></td>
</tr>
</tbody>
</table>
</section>
<section id="compound-requests">
<h3 class="translated">requisições compostas<a class="headerlink" href="#compound-requests" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Todas as requisições possíveis foram completamente definidas por alguma combinação dos sinalizadores na seção anterior. Por conveniência, o protocolo do buffer fornece combinações frequentemente utilizadas como sinalizadores únicos.</p>
<p class="translated">Na seguinte tabela <em>U</em> significa contiguidade indefinida. O consumidor deve chamar <a class="reference internal" href="#c.PyBuffer_IsContiguous" title="PyBuffer_IsContiguous"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_IsContiguous()</span></code></a> para determinar a contiguidade.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Solicitação</p></th>
<th class="head"><p class="translated">Forma</p></th>
<th class="head"><p class="translated">Avanços</p></th>
<th class="head"><p class="translated">subconjuntos</p></th>
<th class="head"><p class="translated">contig</p></th>
<th class="head"><p class="translated">readonly</p></th>
<th class="head"><p class="translated">format</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_FULL">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_FULL</span></span></span><a class="headerlink" href="#c.PyBUF_FULL" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">se necessário</p></td>
<td><p class="translated">U</p></td>
<td><p class="translated">0</p></td>
<td><p class="translated">sim</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_FULL_RO">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_FULL_RO</span></span></span><a class="headerlink" href="#c.PyBUF_FULL_RO" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">se necessário</p></td>
<td><p class="translated">U</p></td>
<td><p class="translated">1 ou 0</p></td>
<td><p class="translated">sim</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_RECORDS">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_RECORDS</span></span></span><a class="headerlink" href="#c.PyBUF_RECORDS" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">U</p></td>
<td><p class="translated">0</p></td>
<td><p class="translated">sim</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_RECORDS_RO">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_RECORDS_RO</span></span></span><a class="headerlink" href="#c.PyBUF_RECORDS_RO" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">U</p></td>
<td><p class="translated">1 ou 0</p></td>
<td><p class="translated">sim</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_STRIDED">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_STRIDED</span></span></span><a class="headerlink" href="#c.PyBUF_STRIDED" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">U</p></td>
<td><p class="translated">0</p></td>
<td><p class="translated">NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_STRIDED_RO">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_STRIDED_RO</span></span></span><a class="headerlink" href="#c.PyBUF_STRIDED_RO" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">U</p></td>
<td><p class="translated">1 ou 0</p></td>
<td><p class="translated">NULL</p></td>
</tr>
<tr class="row-even"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_CONTIG">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_CONTIG</span></span></span><a class="headerlink" href="#c.PyBUF_CONTIG" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">C</p></td>
<td><p class="translated">0</p></td>
<td><p class="translated">NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="c macro">
<dt class="sig sig-object c" id="c.PyBUF_CONTIG_RO">
<span class="sig-name descname"><span class="n"><span class="pre">PyBUF_CONTIG_RO</span></span></span><a class="headerlink" href="#c.PyBUF_CONTIG_RO" title="Link para esta definição">¶</a><br /></dt>
<dd></dd></dl>

</td>
<td><p class="translated">sim</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">NULL</p></td>
<td><p class="translated">C</p></td>
<td><p class="translated">1 ou 0</p></td>
<td><p class="translated">NULL</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="complex-arrays">
<h2 class="translated">Vetores Complexos<a class="headerlink" href="#complex-arrays" title="Link para este cabeçalho">¶</a></h2>
<section id="numpy-style-shape-and-strides">
<h3 class="translated">Estilo NumPy: forma e avanços<a class="headerlink" href="#numpy-style-shape-and-strides" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">A estrutura lógica de vetores do estilo NumPy é definida por <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> e <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>.</p>
<p class="translated">Se <code class="docutils literal notranslate"><span class="pre">ndim</span> <span class="pre">==</span> <span class="pre">0</span></code>, a localização da memória apontada para <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a> é interpretada como um escalar de tamanho <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>. Nesse caso, ambos <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> e <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> são <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p class="translated">Se <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, o vetor é interpretado como um vetor C n-dimensional padrão. Caso contrário, o consumidor deve acessar um vetor n-dimensional como a seguir:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">];</span>
<span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="n">typeof</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">Como notado acima, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a> pode apontar para qualquer localização dentro do bloco de memória em si. Um exportador pode verificar a validade de um buffer com essa função:</p>
<div class="translated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">verify_structure</span><span class="p">(</span><span class="n">memlen</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verifica se os parâmetros representa um vetor válido dentro</span>
<span class="sd">       dos limites da memória alocada:</span>
<span class="sd">           char *mem: início do bloco de memória física</span>
<span class="sd">           memlen: comprimento do bloco de memória física</span>
<span class="sd">           offset: (char *)buf - mem</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">%</span> <span class="n">itemsize</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">offset</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="n">memlen</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="n">itemsize</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strides</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">strides</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">imin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">imax</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="o">+</span><span class="n">imin</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">+</span><span class="n">imax</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&lt;=</span> <span class="n">memlen</span>
</pre></div>
</div>
</section>
<section id="pil-style-shape-strides-and-suboffsets">
<h3 class="translated">Estilo-PIL: forma, avanços e suboffsets<a class="headerlink" href="#pil-style-shape-strides-and-suboffsets" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Além dos itens normais, uma matriz em estilo PIL pode conter ponteiros que devem ser seguidos para se obter o próximo elemento em uma dimensão. Por exemplo, a matriz tridimensional em C <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">v[2][2][3]</span></code> também pode ser vista como um vetor de 2 ponteiros para duas matrizes bidimensionais: <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">(*v[2])[2][3]</span></code>. Na representação por suboffsets, esses dois ponteiros podem ser embutidos no início de <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>, apontando para duas matrizes <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">x[2][3]</span></code> que podem estar localizadas em qualquer lugar na memória.</p>
<p class="translated">Esta é uma função que retorna um ponteiro para o elemento em uma matriz N-D apontada por um índice N-dimensional onde existem ambos passos e subconjuntos não-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_item_pointer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ndim</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">strides</span><span class="p">,</span>
<span class="w">                       </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">suboffsets</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ndim</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pointer</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="buffer-related-functions">
<h2 class="translated">Funções relacionadas ao Buffer<a class="headerlink" href="#buffer-related-functions" title="Link para este cabeçalho">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_CheckBuffer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_CheckBuffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CheckBuffer" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">1</span></code> se <em>obj</em> oferece suporte à interface de buffer, se não, <code class="docutils literal notranslate"><span class="pre">0</span></code>. Quando <code class="docutils literal notranslate"><span class="pre">1</span></code> é retornado, isso não garante que <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> será bem sucedida. Esta função é sempre bem sucedida.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_GetBuffer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_GetBuffer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exporter</span></span>, <a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">view</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetBuffer" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Envia uma requisição ao <em>exporter</em> para preencher a <em>view</em> conforme especificado por <em>flags</em>. Se o exporter não conseguir prover um buffer do tipo especificado, ele DEVE levantar <a class="reference internal" href="../library/exceptions.html#BufferError" title="BufferError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferError</span></code></a>, definir <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> para <code class="docutils literal notranslate"><span class="pre">NULL</span></code> e retornar <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p class="translated">Em caso de sucesso, preenche <em>view</em>, define <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> para uma nova referência para <em>exporter</em> e retorna 0. No caso de provedores de buffer encadeados que redirecionam requisições para um único objeto, <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> DEVE se referir a este objeto em vez de <em>exporter</em> (Veja <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">Buffer Object Structures</span></a>).</p>
<p class="translated">Chamadas bem sucedidas para <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> devem ser emparelhadas a chamadas para  <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>, similar para <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>. Assim, após o consumidor terminar com o buffer, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> deve ser chamado exatamente uma vez.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_Release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_Release</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">view</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_Release" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Libera o buffer de <em>view</em> e libera o <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a> (por exemplo, decrementa o contador de referências) para o objeto de suporte da view, <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>. Esta função DEVE ser chamada quando o buffer não estiver mais sendo usado, ou o vazamento de referências pode acontecer.</p>
<p class="translated">É um erro chamar essa função em um buffer que não foi obtido via <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_SizeFromFormat">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_SizeFromFormat</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_SizeFromFormat" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Retorna o <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> implícito de <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>. Em erro, levantar e exceção e retornar -1.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_IsContiguous">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_IsContiguous</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">view</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_IsContiguous" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">1</span></code> se a memória definida pela <em>view</em> é <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contígua</span></a> no estilo C (<em>order</em> é <code class="docutils literal notranslate"><span class="pre">'C'</span></code>) ou no estilo Fortran (<em>order</em> é <code class="docutils literal notranslate"><span class="pre">'F'</span></code>) ou qualquer outra (<em>order</em> é <code class="docutils literal notranslate"><span class="pre">'A'</span></code>). Retorna <code class="docutils literal notranslate"><span class="pre">0</span></code> caso contrário. Essa função é sempre bem sucedida.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_GetPointer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_GetPointer</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">view</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_GetPointer" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Recebe a área de memória apontada pelos <em>indices</em> dentro da <em>view</em> dada. <em>indices</em> deve apontar para um array de <code class="docutils literal notranslate"><span class="pre">view-&gt;ndim</span></code> índices.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_FromContiguous">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_FromContiguous</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">view</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">fort</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FromContiguous" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Copia <em>len</em> bytes contíguos de <em>buf</em> para <em>view</em>. <em>fort</em> pode ser <code class="docutils literal notranslate"><span class="pre">'C'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'F'</span></code> (para ordenação estilo C ou estilo Fortran). Retorna <code class="docutils literal notranslate"><span class="pre">0</span></code> em caso de sucesso e <code class="docutils literal notranslate"><span class="pre">-1</span></code> em caso de erro.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_ToContiguous">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_ToContiguous</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_ToContiguous" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Copia <em>len</em> bytes de <em>src</em> para sua representação contígua em <em>buf</em>. <em>order</em> pode ser <code class="docutils literal notranslate"><span class="pre">'C'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'F'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'A'</span></code> (para ordenação estilo C, Fortran ou qualquer uma). O retorno é <code class="docutils literal notranslate"><span class="pre">0</span></code> em caso de sucesso e <code class="docutils literal notranslate"><span class="pre">-1</span></code> em caso de falha.</p>
<p class="translated">Esta função falha se <em>len</em> != <em>src-&gt;len</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_CopyData">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_CopyData</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dest</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CopyData" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Copia os dados do buffer <em>src</em> para o buffer <em>dest</em>. Pode converter entre buffers de estilo C e/ou estilo Fortran.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">0</span></code> é retornado em caso de sucesso, <code class="docutils literal notranslate"><span class="pre">-1</span></code> em caso de erro.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_FillContiguousStrides">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_FillContiguousStrides</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">ndims</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">strides</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">itemsize</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n"><span class="pre">order</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FillContiguousStrides" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Preenche o array <em>strides</em> com byte-strides de um array <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contíguo</span></a> (estilo C se <em>order</em> é <code class="docutils literal notranslate"><span class="pre">'C'</span></code> ou estilo Fortran se <em>order</em> for <code class="docutils literal notranslate"><span class="pre">'F'</span></code>) da forma dada com o número dado de bytes por elemento.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyBuffer_FillInfo">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyBuffer_FillInfo</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><span class="n"><span class="pre">Py_buffer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">view</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exporter</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">buf</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">readonly</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FillInfo" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a> desde a versão 3.11.</em><p class="translated">Manipula requisições de buffer para um exportador que quer expor <em>buf</em> de tamanho <em>len</em> com capacidade de escrita definida de acordo com <em>readonly</em>. <em>buf</em> é interpretada como uma sequência de bytes sem sinal.</p>
<p class="translated">O argumento <em>flags</em> indica o tipo de requisição. Esta função sempre preenche <em>view</em> como especificado por <em>flags</em>, a não ser que <em>buf</em> seja designado como somente leitura e <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> esteja definido em <em>flags</em>.</p>
<p class="translated">Em caso de sucesso, defina <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> como um novo referência para <em>exporter</em> e retorna 0. Caso contrário, levante <a class="reference internal" href="../library/exceptions.html#BufferError" title="BufferError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferError</span></code></a> , defina <code class="docutils literal notranslate"><span class="pre">view-&gt;obj</span></code> para <code class="docutils literal notranslate"><span class="pre">NULL</span></code> e retorne <code class="docutils literal notranslate"><span class="pre">-1</span></code> ;</p>
<p class="translated">Se esta função é usada como parte de um <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">getbufferproc</span></a>, <em>exporter</em> DEVE ser definida para o objeto de exportação e <em>flags</em> deve ser passado sem modificações. Caso contrário, <em>exporter</em> DEVE ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">Protocolo de Buffer</a><ul>
<li><a class="reference internal" href="#buffer-structure">Estrutura de Buffer</a></li>
<li><a class="reference internal" href="#buffer-request-types">Tipos de solicitação do buffer</a><ul>
<li><a class="reference internal" href="#request-independent-fields">campos independentes do pedido</a></li>
<li><a class="reference internal" href="#readonly-format">apenas em formato</a></li>
<li><a class="reference internal" href="#shape-strides-suboffsets">forma, avanços, suboffsets</a></li>
<li><a class="reference internal" href="#contiguity-requests">requisições contíguas</a></li>
<li><a class="reference internal" href="#compound-requests">requisições compostas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-arrays">Vetores Complexos</a><ul>
<li><a class="reference internal" href="#numpy-style-shape-and-strides">Estilo NumPy: forma e avanços</a></li>
<li><a class="reference internal" href="#pil-style-shape-strides-and-suboffsets">Estilo-PIL: forma, avanços e suboffsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-related-functions">Funções relacionadas ao Buffer</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="iter.html"
                          title="capítulo anterior">Protocolo Iterador</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="concrete.html"
                          title="próximo capítulo">Camada de Objetos Concretos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/buffer.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="concrete.html" title="Camada de Objetos Concretos"
             >próximo</a> |</li>
        <li class="right" >
          <a href="iter.html" title="Protocolo Iterador"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referência da API Python/C</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" >Camada de Objetos Abstratos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Protocolo de Buffer</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>