<!DOCTYPE html>

<html lang="pt-BR" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Análise de argumentos e construção de valores" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/arg.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Essas funções são úteis ao criar suas próprias funções e métodos de extensão. Informações adicionais e exemplos estão disponíveis em Estendendo e incorporando o interpretador Python. As três primei..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_c-api_arg_168c8d72.png" />
<meta property="og:image:alt" content="Essas funções são úteis ao criar suas próprias funções e métodos de extensão. Informações adicionais e exemplos estão disponíveis em Estendendo e incorporando o interpretador Python. As três primei..." />
<meta name="description" content="Essas funções são úteis ao criar suas próprias funções e métodos de extensão. Informações adicionais e exemplos estão disponíveis em Estendendo e incorporando o interpretador Python. As três primei..." />
<meta name="twitter:card" content="summary_large_image" />

    <title>Análise de argumentos e construção de valores &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=62a4a58b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=71a39b36"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="Conversão e formação de strings" href="conversion.html" />
    <link rel="prev" title="Suporte a marshalling de dados" href="marshal.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/c-api/arg.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">Análise de argumentos e construção de valores</a><ul>
<li><a class="reference internal" href="#parsing-arguments">Análise de argumentos</a><ul>
<li><a class="reference internal" href="#strings-and-buffers">Strings e buffers</a></li>
<li><a class="reference internal" href="#numbers">Números</a></li>
<li><a class="reference internal" href="#other-objects">Outros objetos</a></li>
<li><a class="reference internal" href="#api-functions">Funções da API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-values">Construindo valores</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="marshal.html"
                          title="capítulo anterior">Suporte a <em>marshalling</em> de dados</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="conversion.html"
                          title="próximo capítulo">Conversão e formação de strings</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/arg.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="Conversão e formação de strings"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Suporte a marshalling de dados"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referência da API Python/C</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" accesskey="U">Utilitários</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Análise de argumentos e construção de valores</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="parsing-arguments-and-building-values">
<span id="arg-parsing"></span><h1 class="translated">Análise de argumentos e construção de valores<a class="headerlink" href="#parsing-arguments-and-building-values" title="Link para este cabeçalho">¶</a></h1>
<p class="translated">Essas funções são úteis ao criar suas próprias funções e métodos de extensão. Informações adicionais e exemplos estão disponíveis em <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">Estendendo e incorporando o interpretador Python</span></a>.</p>
<p class="translated">As três primeiras funções descritas, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, e <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code></a>, todas usam a <em>string de formatação</em> que informam à função sobre os argumentos esperados. As strings de formato usam a mesma sintaxe para cada uma dessas funções.</p>
<section id="parsing-arguments">
<h2 class="translated">Análise de argumentos<a class="headerlink" href="#parsing-arguments" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Uma string de formato consiste em zero ou mais “unidades de formato”. Uma unidade de formato descreve um objeto Python; geralmente é um único caractere ou uma sequência entre parênteses de unidades de formato. Com algumas poucas exceções, uma unidade de formato que não é uma sequência entre parênteses normalmente corresponde a um único argumento de endereço para essas funções. Na descrição a seguir, a forma citada é a unidade de formato; a entrada em parênteses ( ) é o tipo de objeto Python que corresponde à unidade de formato; e a entrada em colchetes [ ] é o tipo da variável(s) C cujo endereço deve ser passado.</p>
<section id="strings-and-buffers">
<span id="arg-parsing-string-and-buffers"></span><h3 class="translated">Strings e buffers<a class="headerlink" href="#strings-and-buffers" title="Link para este cabeçalho">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">No Python 3.12 e anteriores, a macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code> deve ser definida antes da inclusão de <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code> para usar todas as variantes no formato <code class="docutils literal notranslate"><span class="pre">#</span></code> (<code class="docutils literal notranslate"><span class="pre">s#</span></code>, <code class="docutils literal notranslate"><span class="pre">y#</span></code>, etc.) explicadas abaixo. Isso não é necessário no Python 3.13 e posteriores.</p>
</div>
<p class="translated">Esses formatos permitem acessar um objeto como um pedaço contíguo de memória. Você não precisa fornecer armazenamento bruto para a área de unicode ou bytes retornada.</p>
<p class="translated">Salvo indicação em contrário, os buffers não são terminados em NUL.</p>
<p class="translated">Existem três maneiras pelas quais strings e buffers podem ser convertidos em C:</p>
<ul>
<li><p class="translated">Formatos como <code class="docutils literal notranslate"><span class="pre">y*</span></code> e <code class="docutils literal notranslate"><span class="pre">s*</span></code> estão dentro de uma estrutura <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a>.  Isso bloqueia o buffer  subjacente para que o chamador  possa posteriormente usar o buffer, mesmo dentro de um bloco <a class="reference internal" href="init.html#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> sem que haja o risco de que dados mutáveis sejam redimensionados ou destruídos. Dessa forma, <strong>você precisa chamar</strong> <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> depois de ter concluído o processamento de dados (ou em qualquer caso de interrupção precoce).</p></li>
<li><p class="translated">Os formatos <code class="docutils literal notranslate"><span class="pre">es</span></code>, <code class="docutils literal notranslate"><span class="pre">es#</span></code>, <code class="docutils literal notranslate"><span class="pre">et</span></code> e <code class="docutils literal notranslate"><span class="pre">et#</span></code> alocam o buffer resultante. <strong>Você precisa chamar</strong> <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> depois de ter concluído o processamento de dados (ou em qualquer caso de interrupção precoce).</p></li>
<li><p class="translated" id="c-arg-borrowed-buffer">Outros formatos usam um <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou um <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> somente leitura, como <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, e fornecem um ponteiro <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> para seu buffer. Nesse caso, o buffer é “emprestado”: ele é gerenciado pelo objeto Python correspondente e compartilha o tempo de vida desse objeto. Você mesmo não precisará liberar nenhuma memória.</p>
<p class="translated">Para garantir que o buffer subjacente possa ser emprestado com segurança, o campo <a class="reference internal" href="typeobj.html#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a> do objeto deve ser <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Isso não permite objetos mutáveis comuns, como <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, mas também alguns objetos somente leitura, como <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p class="translated">Além desse requisito <code class="docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code>, não há nenhuma verificação para saber se o objeto de entrada é imutável (por exemplo, se ele atenderia a uma solicitação de um buffer gravável ou se outro thread pode alterar os dados).</p>
</li>
</ul>
<dl>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *]</dt><dd><p class="translated">Converte um objeto Unicode para um ponteiro em C para uma string. Um ponteiro para uma string existente é armazenado na variável do ponteiro do caractere cujo o endereço que você está passando. A string em C é terminada em NULO. A string no Python não deve conter pontos de código nulo embutidos; se isso acontecer, uma exceção <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> é levantada. Objetos Unicode são convertidos para strings em C usando a codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>. Se essa conversão falhar, uma exceção <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> é levantada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Esse formato não aceita <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objetos bytes ou similares</span></a>. Se você quer aceitar caminhos de sistema de arquivos e convertê-los para strings de caracteres em C, é preferível que use o formato <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> com <a class="reference internal" href="unicode.html#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> como <em>conversor</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Anteriormente, a exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> era levantada quando pontos de código nulo embutidos em string Python eram encontrados.</p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">s*</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a>) [Py_buffer]</dt><dd><p class="translated">Esse formato aceita tanto objetos Unicode quanto objetos bytes ou similares. Preenche uma estrutura <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> fornecida pelo chamador. Nesse caso, a string em C resultante pode conter bytes NUL embutidos. Objetos Unicode são convertidos para strings em C usando codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> somente leitura) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Como <code class="docutils literal notranslate"><span class="pre">s*</span></code>, exceto que não fornece um <a class="reference internal" href="#c-arg-borrowed-buffer"><span class="std std-ref">buffer emprestado</span></a>. O resultado é armazenado em duas variáveis em C, a primeira é um ponteiro para uma string em C, a segunda é o tamanho. A string pode conter bytes nulos embutidos. Objetos Unicode são convertidos para strings em C usando codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p class="translated">Como <code class="docutils literal notranslate"><span class="pre">s</span></code>, mas o objeto Python também pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>, nesse caso o ponteiro C é definido como <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">z*</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [Py_buffer]</dt><dd><p class="translated">Como <code class="docutils literal notranslate"><span class="pre">s*</span></code>, mas o objeto Python também pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>, nesse caso o membro <code class="docutils literal notranslate"><span class="pre">buf</span></code> da estrutura <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> é definido como <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> somente leitura ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Como <code class="docutils literal notranslate"><span class="pre">s#</span></code>, mas o objeto Python também pode ser <code class="docutils literal notranslate"><span class="pre">None</span></code>, nesse caso o ponteiro C é definido como <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">y</span></code> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> somente leitura) [const char *]</dt><dd><p class="translated">Este formato converte um objeto bytes ou similar para um ponteiro C para uma string de caracteres <a class="reference internal" href="#c-arg-borrowed-buffer"><span class="std std-ref">emprestada</span></a>; não aceita objetos Unicode. O buffer de bytes não pode conter bytes nulos embutidos; se isso ocorrer uma exceção <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> será levantada.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Anteriormente, a exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> era levantada quando pontos de código nulo embutidos em string Python eram encontrados no buffer de bytes.</p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">y*</span></code> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a>) [Py_buffer]</dt><dd><p class="translated">Esta variante em <code class="docutils literal notranslate"><span class="pre">s*</span></code> não aceita objetos unicode, apenas objetos bytes ou similares. <strong>Esta é a maneira recomendada para aceitar dados binários.</strong></p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">y#</span></code> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> somente leitura) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Esta variação de <code class="docutils literal notranslate"><span class="pre">s#</span></code> não aceita objetos Unicode, apenas objetos bytes ou similares.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">S</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [PyBytesObject *]</dt><dd><p class="translated">Exige que o objeto Python seja um objeto <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, sem tentar nenhuma conversão. Levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> se o objeto não for um objeto byte. A variável C pode ser declarada como <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">Y</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [PyByteArrayObject *]</dt><dd><p class="translated">Exige que o objeto Python seja um objeto <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, sem aceitar qualquer conversão.  Levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> se o objeto não é um objeto <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. A variável C apenas pode ser declarada como <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [PyObject *]</dt><dd><p class="translated">Exige que o objeto python seja um objeto Unicode, sem tentar alguma conversão. Levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> se o objeto não for um objeto Unicode. A variável C deve ser declarada como <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">w*</span></code> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto bytes ou similar</span></a> de leitura e escrita) [Py_buffer]</dt><dd><p class="translated">Este formato aceita qualquer objeto que implemente a interface do buffer de leitura e escrita. Ele preenche uma estrutura <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> fornecida pelo chamador. O buffer pode conter bytes nulos incorporados. O chamador deve chamar <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> quando isso for feito com o buffer.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">es</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer]</dt><dd><p class="translated">Esta variante em <code class="docutils literal notranslate"><span class="pre">s</span></code> é utilizada para codificação do Unicode em um buffer de caracteres. Ele só funciona para dados codificados sem NUL bytes incorporados.</p>
<p class="translated">Este formato exige dois argumentos. O primeiro é usado apenas como entrada e deve ser a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> que aponta para o nome de uma codificação como uma string terminada em NUL ou <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, nesse caso a codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> é usada. Uma exceção é levantada se a codificação nomeada não for conhecida pelo Python. O segundo argumento deve ser um <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span><span class="p">*</span></span>; o valor do ponteiro a que ele faz referência será definido como um buffer com o conteúdo do texto do argumento. O texto será codificado na codificação especificada pelo primeiro argumento.</p>
<p class="translated"><a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> alocará um buffer do tamanho necessário, copiará os dados codificados nesse buffer e ajustará <em>*buffer</em> para referenciar o armazenamento recém-alocado. O chamador é responsável por chamar <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> para liberar o buffer alocado após o uso.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">et</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer]</dt><dd><p class="translated">O mesmo que <code class="docutils literal notranslate"><span class="pre">es</span></code>, exceto que os objetos strings de bytes são passados sem os recodificar. Em vez disso, a implementação presume que o objeto string de bytes usa a codificação passada como parâmetro.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">es#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> *buffer_length]</dt><dd><p class="translated">Essa variante em <code class="docutils literal notranslate"><span class="pre">s#</span></code> é usada para codificar Unicode em um buffer de caracteres. Diferente do formato <code class="docutils literal notranslate"><span class="pre">es</span></code>, essa variante permite a entrada de dados que contêm caracteres NUL.</p>
<p class="translated">Exige três argumentos. O primeiro é usado apenas como entrada e deve ser a <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="p">*</span></span> que aponta para o nome de uma codificação como uma string terminada em NUL ou <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, nesse caso a codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> é usada. Uma exceção será gerada se a codificação nomeada não for conhecida pelo Python. O segundo argumento deve ser um <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span><span class="p">*</span></span>; o valor do ponteiro a que ele faz referência será definido como um buffer com o conteúdo do texto do argumento. O texto será codificado na codificação especificada pelo primeiro argumento. O terceiro argumento deve ser um ponteiro para um número inteiro; o número inteiro referenciado será definido como o número de bytes no buffer de saída.</p>
<p class="translated">Há dois modos de operação:</p>
<p class="translated">Se <em>*buffer</em> apontar um ponteiro <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, a função irá alocar um buffer do tamanho necessário, copiar os dados codificados para dentro desse buffer e configurar <em>*buffer</em> para referenciar o novo armazenamento alocado. O chamador é responsável por chamar <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> para liberar o buffer alocado após o uso.</p>
<p class="translated">Se <em>*buffer</em> apontar para um ponteiro que não seja <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (um buffer já alocado), <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> irá usar essa localização como buffer e interpretar o valor inicial de <em>*buffer_length</em> como sendo o tamanho do buffer. Depois ela vai copiar os dados codificados para dentro do buffer e terminá-lo com NUL. Se o buffer não for suficientemente grande, um <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> será definido.</p>
<p class="translated">Em ambos os casos, o <em>*buffer_length</em> é definido como o comprimento dos dados codificados sem o byte NUL à direita.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">et#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> *buffer_length]</dt><dd><p class="translated">O mesmo que <code class="docutils literal notranslate"><span class="pre">es#</span></code>, exceto que os objetos strings de bytes são passados sem que sejam recodificados. Em vez disso, a implementação presume que o objeto string de bytes usa a codificação passada como parâmetro.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span><code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">u#</span></code>, <code class="docutils literal notranslate"><span class="pre">Z</span></code> e <code class="docutils literal notranslate"><span class="pre">Z#</span></code> foram removidos porque usavam uma representação herdada de <code class="docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code>.</p>
</div>
</section>
<section id="numbers">
<h3 class="translated">Números<a class="headerlink" href="#numbers" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Esses formatos permitem representar números Python ou caracteres únicos como números C. Formatos que exigem <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ou <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> também podem usar os métodos especiais correspondentes <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> ou <a class="reference internal" href="../reference/datamodel.html#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> para converter o objeto Python para o tipo necessário.</p>
<p class="translated">Para formatos inteiros com sinal, <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> é levantada se o valor estiver fora do intervalo para o tipo C. Para formatos inteiros não assinados, nenhuma verificação de intervalo é feita — os bits mais significativos são silenciosamente truncados quando o campo de recebimento é muito pequeno para receber o valor.</p>
<dl>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p class="translated">Converte um inteiro Python não negativo em um inteiro pequeno sem sinal (unsigned tiny integer), armazenado em um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p class="translated">Converte um inteiro Python para um inteiro pequeno (tiny integer) sem verificação de estouro, armazenado em um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [short int]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned short int]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span> do C, sem verificação de estouro.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [int]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> simples do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned int]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> do C, sem verificação de estouro.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long int]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">int</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> do C sem verificação de estouro.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [longo longo]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long long]</dt><dd><p class="translated">Converte um inteiro Python para um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> do C sem verificação de estouro.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Converte um inteiro Python para um <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">c</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> de comprimento 1) [char]</dt><dd><p class="translated">Converte um byte Python, representado com um objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">byte</span></code> ou <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> de comprimento 1, para um <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> do C.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Permite objetos <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>.</p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">C</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> de comprimento 1) [int]</dt><dd><p class="translated">Converte um caractere Python, representado como uma <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> objeto de comprimento 1, para um <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> do C</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">f`</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [float]</dt><dd><p class="translated">Converte um número de ponto flutuante Python para um <span class="c-expr sig sig-inline c"><span class="kt">float</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [double]</dt><dd><p class="translated">Converte um número de ponto flutuante Python para um <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> do C.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>) [Py_complex]</dt><dd><p class="translated">Converte um número complexo Python para uma estrutura C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a></p>
</dd>
</dl>
</section>
<section id="other-objects">
<h3 class="translated">Outros objetos<a class="headerlink" href="#other-objects" title="Link para este cabeçalho">¶</a></h3>
<dl class="simple">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">O</span></code> (objeto) [PyObject*]</dt><dd><p class="translated">Armazena um objeto Python (sem qualquer conversão) em um ponteiro de objeto C. O programa C então recebe o objeto real que foi passado. Uma nova <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">referência forte</span></a> ao objeto não é criado (isto é sua contagem de referências não é aumentada). O ponteiro armazenado não é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">O!</span></code> (objeto) [<em>typeobject</em>, PyObject *]</dt><dd><p class="translated">Armazena um objeto Python em um ponteiro de objeto C. Isso é similar a <code class="docutils literal notranslate"><span class="pre">O</span></code>, mas usa dois argumentos C: o primeiro é o endereço de um objeto do tipo Python, o segundo é um endereço da variável C (de tipo <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>) no qual o ponteiro do objeto está armazenado. Se o objeto Python não tiver o tipo necessário, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> é levantada.</p>
</dd>
</dl>
<dl id="o-ampersand">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (objeto) [<em>converter</em>, <em>address</em>]</dt><dd><p class="translated">Converte um objeto Python em uma variável C através de uma função <em>converter</em>. Isso leva dois argumentos: o primeiro é a função, o segundo é o endereço da variável C (de tipo arbitrário), convertendo para <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span>. A função <em>converter</em> por sua vez,  é chamada da seguinte maneira:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">converter</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">onde <em>object</em> é o objeto Python a ser convertido e <em>address</em> é o argumento <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> que foi passado para a função <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code>. O <em>status</em> retornado deve ser <code class="docutils literal notranslate"><span class="pre">1</span></code> para uma conversão bem-sucedida e <code class="docutils literal notranslate"><span class="pre">0</span></code> se a conversão falhar. Quando a conversão falha, a função <em>converter</em> deve levantar uma exceção e deixar o conteúdo de <em>address</em> inalterado.</p>
<p class="translated" id="c.Py_CLEANUP_SUPPORTED">Se o <em>converter</em> retornar <code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_CLEANUP_SUPPORTED</span></code>, ele poderá ser chamado uma segunda vez se a análise do argumento eventualmente falhar, dando ao conversor a chance de liberar qualquer memória que já havia alocado. Nesta segunda chamada, o parâmetro <em>object</em> será <code class="docutils literal notranslate"><span class="pre">NULL</span></code>; <em>address</em> terá o mesmo valor que na chamada original.</p>
<p class="translated">Exemplos de conversores: <a class="reference internal" href="unicode.html#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> e <a class="reference internal" href="unicode.html#c.PyUnicode_FSDecoder" title="PyUnicode_FSDecoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSDecoder()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.1: </span><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_CLEANUP_SUPPORTED</span></code> foi adicionado.</p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p</span></code> (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) [int]</dt><dd><p class="translated">Testa o valor transmitido para a verdade (um booleano <strong>p</strong>redicado) e converte o resultado em seu valor inteiro C verdadeiro/falso equivalente. Define o int como <code class="docutils literal notranslate"><span class="pre">1</span></code> se a expressão for verdadeira e <code class="docutils literal notranslate"><span class="pre">0</span></code> se for falsa. Isso aceita qualquer valor válido do Python. Veja <a class="reference internal" href="../library/stdtypes.html#truth"><span class="std std-ref">Teste do valor verdade</span></a> para obter mais informações sobre como o Python testa valores para a verdade.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.3.</span></p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt><dd><p class="translated">O objeto deve ser uma sequência Python cujo comprimento seja o número de unidades de formato em <em>items</em>. Os argumentos C devem corresponder às unidades de formato individuais em <em>items</em>. As unidades de formato para sequências podem ser aninhadas.</p>
</dd>
</dl>
<p class="translated">Alguns outros caracteres possuem significados na string de formatação. Isso pode não ocorrer dentro de parênteses aninhados. Eles são:</p>
<dl>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p class="translated">Indica que os argumentos restantes na lista de argumentos do Python são opcionais. As variáveis C correspondentes a argumentos opcionais devem ser inicializadas para seus valores padrão — quando um argumento opcional não é especificado, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> não toca no conteúdo da(s) variável(eis) C correspondente(s).</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p class="translated"><a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> apenas: Indica que os argumentos restantes na lista de argumentos do Python são somente-nomeados. Atualmente, todos os argumentos somente-nomeados devem ser também argumentos opcionais, então <code class="docutils literal notranslate"><span class="pre">|</span></code> deve sempre ser especificado antes de <code class="docutils literal notranslate"><span class="pre">$</span></code> na string de formatação.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.3.</span></p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">:</span></code></dt><dd><p class="translated">A lista de unidades de formatação acaba aqui; a string após os dois pontos é usada como o nome da função nas mensagens de erro (o “valor associado” da exceção que <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> levanta).</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">;</span></code></dt><dd><p class="translated">A lista de unidades de formatação acaba aqui; a string após o ponto e vírgula é usada como a mensagem de erro <em>ao invés</em> da mensagem de erro padrão. <code class="docutils literal notranslate"><span class="pre">:</span></code> e <code class="docutils literal notranslate"><span class="pre">;</span></code> se excluem mutuamente.</p>
</dd>
</dl>
<p class="translated">Note que quaisquer referências a objeto Python que são fornecidas ao chamador são referências <em>emprestadas</em>; não libera-as (isto é, não decremente a contagem de referências delas)!</p>
<p class="translated">Argumentos adicionais passados para essas funções devem ser endereços de variáveis cujo tipo é determinado pela string de formatação; estes são usados para armazenar valores vindos da tupla de entrada. Existem alguns casos, como descrito na lista de unidades de formatação acima, onde esses parâmetros são usados como valores de entrada; eles devem concordar com o que é especificado para a unidade de formatação correspondente nesse caso.</p>
<p class="translated">Para a conversão funcionar, o objeto <em>arg</em> deve corresponder ao formato e o formato deve estar completo. Em caso de sucesso, as funções <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> retornam verdadeiro, caso contrário retornam falso e levantam uma exceção apropriada. Quando as funções <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> falham devido a uma falha de conversão em uma das unidades de formatação, as variáveis nos endereços correspondentes àquela unidade e às unidades de formatação seguintes são deixadas intocadas.</p>
</section>
<section id="api-functions">
<h3 class="translated">Funções da API<a class="headerlink" href="#api-functions" title="Link para este cabeçalho">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_ParseTuple">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_ParseTuple</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTuple" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Analisa os parâmetros de uma função que recebe apenas parâmetros posicionais em variáveis locais. Retorna verdadeiro em caso de sucesso; em caso de falha, retorna falso e levanta a exceção apropriada.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_VaParse">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_VaParse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">vargs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParse" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Idêntico a <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, exceto que aceita uma va_list ao invés de um número variável de argumentos.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_ParseTupleAndKeywords">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_ParseTupleAndKeywords</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kw</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keywords</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTupleAndKeywords" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Analisa os parâmetros de uma função que aceita tanto parâmetros posicionais quando parâmetros nomeados e os converte em variáveis locais. O argumento <em>keywords</em> é um array terminado em <code class="docutils literal notranslate"><span class="pre">NULL</span></code> de nomes de parâmetros nomeados especificados como strings C codificadas em ASCII ou UTF-8 e terminadas com nulo. Nomes vazios representam <a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">parâmetros somente-posicional</span></a>. Retorna verdadeiro em caso de sucesso; em caso de falha, retorna falso e levanta a exceção apropriada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">A declaração do parâmetro <em>keywords</em> é <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="k">const</span><span class="p">*</span></span> em C e <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="k">const</span><span class="p">*</span></span> em C++. Isso pode ser substituído com a macro  <a class="reference internal" href="#c.PY_CXX_CONST" title="PY_CXX_CONST"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_CXX_CONST</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Adicionado suporte para <a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">positional-only parameters</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.13: </span>O parâmetro <em>keywords</em> é agora do tipo <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="k">const</span><span class="p">*</span></span> em C e <span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="k">const</span><span class="p">*</span></span> em C++, no lugar de <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span><span class="p">*</span></span>. Adicionado suporte para nomes de parâmetros nomeados não-ASCII.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_VaParseTupleAndKeywords">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_VaParseTupleAndKeywords</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kw</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">keywords</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">vargs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParseTupleAndKeywords" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Idêntico a <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, exceto que aceita uma va_list ao invés de um número variável de argumentos.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_ValidateKeywordArguments">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_ValidateKeywordArguments</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ValidateKeywordArguments" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Garante que as chaves no dicionário de argumento de palavras reservadas são strings. Isso só é necessário se <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> não é usado, já que o último já faz essa checagem.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.2.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_Parse">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_Parse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_Parse" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Analisa o parâmetro de uma função que recebe um único parâmetro posicional e o converte em uma variável local. Retorna verdadeiro em caso de sucesso; em caso de falha, retorna falso e levanta a exceção apropriada.</p>
<p class="translated">Exemplo:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Função usando a convenção de chamada ao método METH_O</span>
<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="o">*</span>
<span class="nf">my_function</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">PyArg_Parse</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i:my_function&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ... usar valor ...</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyArg_UnpackTuple">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyArg_UnpackTuple</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">min</span></span>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n"><span class="pre">Py_ssize_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">max</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_UnpackTuple" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Uma forma mais simples de recuperação de parâmetro que não usa uma string de formato para especificar os tipos de argumentos. Funções que usam este método para recuperar seus parâmetros devem ser declaradas como <a class="reference internal" href="structures.html#c.METH_VARARGS" title="METH_VARARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a> em tabelas de função ou método. A tupla contendo os parâmetros reais deve ser passada como <em>args</em>; deve realmente ser uma tupla. O comprimento da tupla deve ser de pelo menos <em>min</em> e não mais do que <em>max</em>; <em>min</em> e <em>max</em> podem ser iguais. Argumentos adicionais devem ser passados para a função, cada um dos quais deve ser um ponteiro para uma variável <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>; eles serão preenchidos com os valores de <em>args</em>; eles conterão <a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">referências emprestadas</span></a>. As variáveis que correspondem a parâmetros opcionais não fornecidos por <em>args</em> não serão preenchidas; estes devem ser inicializados pelo chamador. Esta função retorna verdadeiro em caso de sucesso e falso se <em>args</em> não for uma tupla ou contiver o número incorreto de elementos; uma exceção será definida se houver uma falha.</p>
<p class="translated">Este é um exemplo do uso dessa função, tirado das fontes do módulo auxiliar para referências fracas <code class="xref py py-mod docutils literal notranslate"><span class="pre">_weakref</span></code>:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">weakref_ref</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ref&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">callback</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyWeakref_NewRef</span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="translated">A chamada à <a class="reference internal" href="#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a> neste exemplo é inteiramente equivalente à chamada para <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;O|O:ref&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PY_CXX_CONST">
<span class="sig-name descname"><span class="n"><span class="pre">PY_CXX_CONST</span></span></span><a class="headerlink" href="#c.PY_CXX_CONST" title="Link para esta definição">¶</a><br /></dt>
<dd><p class="translated">O valor para ser inserido, se houver, antes de <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="k">const</span><span class="p">*</span></span> na declaração do parâmetro <em>keywords</em> das funções  <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> e <a class="reference internal" href="#c.PyArg_VaParseTupleAndKeywords" title="PyArg_VaParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_VaParseTupleAndKeywords()</span></code></a>. Por padrão, é vazio para C e <code class="docutils literal notranslate"><span class="pre">const</span></code> for C++ (<span class="c-expr sig sig-inline c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">*</span><span class="k">const</span><span class="p">*</span></span>). Para substituir, defina o valor desejado antes de incluir <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.13.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="building-values">
<h2 class="translated">Construindo valores<a class="headerlink" href="#building-values" title="Link para este cabeçalho">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_BuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_BuildValue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="p"><span class="pre">...</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BuildValue" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="refcount return_new_ref">Retorna valor: Nova referência.</em><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Cria um novo valor baseado em uma string de formatação similar àquelas aceitas pela família de funções <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> e uma sequência de valores. Retorna o valor ou <code class="docutils literal notranslate"><span class="pre">NULL</span></code> em caso de erro; uma exceção será levantada se <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for retornado.</p>
<p class="translated"><a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> não constrói sempre uma tupla. Ela constrói uma tupla apenas se a sua string de formatação contém duas ou mais unidades de formatação. Se a string de formatação estiver vazia, ela retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>; se ela contém exatamente uma unidade de formatação, ela retorna qualquer que seja o objeto que for descrito pela unidade de formatação. Para forçar ela a retornar uma tupla de tamanho 0 ou um, use parênteses na string de formatação.</p>
<p class="translated">Quando buffers de memória são passados como parâmetros para fornecer dados para construir objetos, como nos formatos <code class="docutils literal notranslate"><span class="pre">s</span></code> e <code class="docutils literal notranslate"><span class="pre">s#</span></code>, os dados necessários são copiados. Buffers fornecidos pelo chamador nunca são referenciados pelos objetos criados por <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>. Em outras palavras, se o seu código invoca <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> e passa a memória alocada para <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>, seu código é responsável por chamar <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> para aquela memória uma vez que <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> tiver retornado.</p>
<p class="translated">Na descrição a seguir, a forma entre aspas é a unidade de formatação; a entrada em parênteses (arredondado) é o tipo do objeto Python que a unidade de formatação irá retornar; e a entrada em colchetes [quadrado] é o tipo do(s) valor(es) C a ser(em) passado(s).</p>
<p class="translated">Os caracteres de espaço, tab, dois pontos e vírgula são ignorados em strings de formatação (mas não dentro de unidades de formatação como <code class="docutils literal notranslate"><span class="pre">s#</span></code>). Isso pode ser usado para tornar strings de formatação longas um pouco mais legíveis.</p>
<dl class="simple">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p class="translated">Converte uma string C terminada em NULL em um objeto Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> usando codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>. Se o ponteiro da string C é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> é usado.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Converte uma string C e seu comprimento em um objeto Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> usando a codificação <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>. Se o ponteiro da string C é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, o comprimento é ignorado e <code class="docutils literal notranslate"><span class="pre">None</span></code> é retornado.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">y</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [const char *]</dt><dd><p class="translated">Isso converte uma string C para um objeto Python <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Se o ponteiro da string C é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> é retornado.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">y#</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Isso converte uma string C e seu comprimento para um objeto Python. Se o ponteiro da string C é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> é retornado.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p class="translated">O mesmo de <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">O mesmo de <code class="docutils literal notranslate"><span class="pre">s#</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">u</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const wchar_t *]</dt><dd><p class="translated">Converte um buffer terminado por null <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> de dados Unicode (UTF-16 ou UCS-4) para um objeto Python Unicode. Se o ponteiro do buffer Unicode é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> é retornado.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">u#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const wchar_t *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Converte um buffer de dados Unicode (UTF-17 ou UCS-4) e seu comprimento em um objeto Python Unicode. Se o ponteiro do buffer Unicode é <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, o comprimento é ignorado e <code class="docutils literal notranslate"><span class="pre">None</span></code> é retornado.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p class="translated">O mesmo de <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">U#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">O mesmo de <code class="docutils literal notranslate"><span class="pre">s#</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [int]</dt><dd><p class="translated">Converte um simples <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [char]</dt><dd><p class="translated">Converte um simples <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [short int]</dt><dd><p class="translated">Converte um simples <span class="c-expr sig sig-inline c"><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long int]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">int</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned short int]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned int]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [longo longo]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> do C em um objeto inteiro do Python.</p>
</dd>
</dl>
<dl class="simple" id="capi-py-buildvalue-format-k">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long long]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>]</dt><dd><p class="translated">Converte um <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> do C em um objeto inteiro do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">c</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> de comprimento 1) [char]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> representando um byte do C em um objeto <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> de comprimento 1 do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">C</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> de comprimento 1) [int]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> representando um caractere do C em um objeto <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> de comprimento 1 do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [double]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> do C em um número ponto flutuante do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">f`</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [float]</dt><dd><p class="translated">Converte um <span class="c-expr sig sig-inline c"><span class="kt">float</span></span> do C em um número ponto flutuante do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>) [Py_complex *]</dt><dd><p class="translated">Converte uma estrutura <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> do C em um número complexo do Python.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">O</span></code> (objeto) [PyObject*]</dt><dd><p class="translated">Passa um objeto Python intocado, mas cria uma nova <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">referência forte</span></a> a ele (isto é, sua contagem de referências é incrementada por um). Se o objeto passado é um ponteiro <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, presume-se que isso foi causado porque a chamada que produziu o argumento encontrou um erro e definiu uma exceção. Portanto, <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> irá retornar <code class="docutils literal notranslate"><span class="pre">NULL</span></code> mas não irá levantar uma exceção. Se nenhuma exceção foi levantada ainda, <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> é definida.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">S</span></code> (objeto) [PyObject *]</dt><dd><p class="translated">O mesmo que <code class="docutils literal notranslate"><span class="pre">O</span></code>.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">N</span></code> (objeto) [PyObject *]</dt><dd><p class="translated">O mesmo que <code class="docutils literal notranslate"><span class="pre">O</span></code>, exceto que não cria uma nova <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">referência forte</span></a>. Útil quando o objeto é criado por uma chamada a um construtor de objeto na lista de argumento.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (objeto) [<em>converter</em>, <em>anything</em>]</dt><dd><p class="translated">Converte <em>anything</em> para um objeto Python através de uma função <em>converter</em>. A função é chamada com <em>anything</em> (que deve ser compatível com o <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span>) como argumento e deve retornar um “novo” objeto Python, ou <code class="docutils literal notranslate"><span class="pre">NULL</span></code> se um erro ocorreu.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt><dd><p class="translated">Converte uma sequência de valores C para uma tupla Python com o mesmo número de itens.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">[items]</span></code> (<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) [<em>matching-items</em>]</dt><dd><p class="translated">Converte uma sequência de valores C para uma lista Python com o mesmo número de itens.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">{items}</span></code> (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) [<em>matching-items</em>]</dt><dd><p class="translated">Converte uma sequência de valores C para um dicionário Python. Cada par de valores consecutivos do C adiciona um item ao dicionário, servindo como chave e valor, respectivamente.</p>
</dd>
</dl>
<p class="translated">Se existir um erro na string de formatação, a exceção <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> é definida e <code class="docutils literal notranslate"><span class="pre">NULL</span></code> é retornado.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_VaBuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_VaBuildValue</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">format</span></span>, <span class="n"><span class="pre">va_list</span></span><span class="w"> </span><span class="n"><span class="pre">vargs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_VaBuildValue" title="Link para esta definição">¶</a><br /></dt>
<dd><em class="refcount return_new_ref">Retorna valor: Nova referência.</em><em class="stableabi"> Parte da <a class="reference internal" href="stable.html#stable"><span class="std std-ref">ABI Estável</span></a>.</em><p class="translated">Idêntico a <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>, exceto que aceita uma va_list ao invés de um número variável de argumentos.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">Análise de argumentos e construção de valores</a><ul>
<li><a class="reference internal" href="#parsing-arguments">Análise de argumentos</a><ul>
<li><a class="reference internal" href="#strings-and-buffers">Strings e buffers</a></li>
<li><a class="reference internal" href="#numbers">Números</a></li>
<li><a class="reference internal" href="#other-objects">Outros objetos</a></li>
<li><a class="reference internal" href="#api-functions">Funções da API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-values">Construindo valores</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="marshal.html"
                          title="capítulo anterior">Suporte a <em>marshalling</em> de dados</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="conversion.html"
                          title="próximo capítulo">Conversão e formação de strings</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/arg.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="Conversão e formação de strings"
             >próximo</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Suporte a marshalling de dados"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referência da API Python/C</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" >Utilitários</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Análise de argumentos e construção de valores</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>