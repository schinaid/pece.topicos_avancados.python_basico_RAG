<!DOCTYPE html>

<html lang="pt-BR" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="5. O sistema de importação" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/import.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="O código Python em um módulo obtém acesso ao código em outro módulo pelo processo de importação dele. A instrução import é a maneira mais comum de invocar o mecanismo de importação, mas não é a úni..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_reference_import_8796dc21.png" />
<meta property="og:image:alt" content="O código Python em um módulo obtém acesso ao código em outro módulo pelo processo de importação dele. A instrução import é a maneira mais comum de invocar o mecanismo de importação, mas não é a úni..." />
<meta name="description" content="O código Python em um módulo obtém acesso ao código em outro módulo pelo processo de importação dele. A instrução import é a maneira mais comum de invocar o mecanismo de importação, mas não é a úni..." />
<meta name="twitter:card" content="summary_large_image" />

    <title>5. O sistema de importação &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=62a4a58b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=71a39b36"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="6. Expressões" href="expressions.html" />
    <link rel="prev" title="4. Modelo de execução" href="executionmodel.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/reference/import.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">5. O sistema de importação</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="#packages">5.2. Pacotes</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. Pacotes regulares</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. Pacotes de espaço de nomes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. Caminho de busca</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. O cache de módulos</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. Localizadores e carregadores</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. Ganchos de importação</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. O metacaminho</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loading">5.4. Carregando</a><ul>
<li><a class="reference internal" href="#loaders">5.4.1. Carregadores</a></li>
<li><a class="reference internal" href="#submodules">5.4.2. Submódulos</a></li>
<li><a class="reference internal" href="#module-specs">5.4.3. Especificações de módulo</a></li>
<li><a class="reference internal" href="#path-attributes-on-modules">5.4.4. Atributo __path__ dos módulos</a></li>
<li><a class="reference internal" href="#module-reprs">5.4.5. Representações do módulo</a></li>
<li><a class="reference internal" href="#cached-bytecode-invalidation">5.4.6. Invalidação de bytecode em cache</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. O localizador baseado no caminho</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. Localizadores de entrada de caminho</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. Protocolo do localizador de entrada de caminho</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. Substituindo o sistema de importação padrão</a></li>
<li><a class="reference internal" href="#package-relative-imports">5.7. Importações relativas ao pacote</a></li>
<li><a class="reference internal" href="#special-considerations-for-main">5.8. Considerações especiais para __main__</a><ul>
<li><a class="reference internal" href="#main-spec">5.8.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">5.9. Referências</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="capítulo anterior"><span class="section-number">4. </span>Modelo de execução</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="expressions.html"
                          title="próximo capítulo"><span class="section-number">6. </span>Expressões</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/import.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. Expressões"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de execução"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>O sistema de importação</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="the-import-system">
<span id="importsystem"></span><h1 class="translated"><span class="section-number">5. </span>O sistema de importação<a class="headerlink" href="#the-import-system" title="Link para este cabeçalho">¶</a></h1>
<p class="translated" id="index-0">O código Python em um <a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">módulo</span></a> obtém acesso ao código em outro módulo pelo processo de <a class="reference internal" href="../glossary.html#term-importing"><span class="xref std std-term">importação</span></a> dele. A instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> é a maneira mais comum de invocar o mecanismo de importação, mas não é a única maneira. Funções como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> e a função embutida <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> também podem ser usadas para chamar o mecanismo de importação.</p>
<p class="translated">A instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> combina duas operações; ela procura o módulo nomeado e vincula os resultados dessa pesquisa a um nome no escopo local. A operação de busca da instrução <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> é definida como uma chamada para a função <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>, com os argumentos apropriados. O valor de retorno de <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> é usado para executar a operação de ligação de nome da instrução <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>. Veja a instrução <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> para os detalhes exatos da operação de ligação desse nome.</p>
<p class="translated">Uma chamada direta para <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> realiza apenas a pesquisa do módulo e, se encontrada, a operação de criação do módulo. Embora certos efeitos colaterais possam ocorrer, como a importação de pacotes pai e a atualização de vários caches (incluindo <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>), apenas a instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> realiza uma operação de ligação de nome.</p>
<p class="translated">Quando uma instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> é executada, a função embutida padrão <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> é chamada. Outros mecanismos para chamar o sistema de importação (como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>) podem optar por ignorar <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> e usar suas próprias soluções para implementar a semântica de importação.</p>
<p class="translated">Quando um módulo é importado pela primeira vez, o Python procura pelo módulo e, se encontrado, cria um objeto de módulo <a class="footnote-reference brackets" href="#fnmo" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, inicializando-o. Se o módulo nomeado não puder ser encontrado, uma <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> será levantada. O Python implementa várias estratégias para procurar o módulo nomeado quando o mecanismo de importação é chamado. Essas estratégias podem ser modificadas e estendidas usando vários ganchos descritos nas seções abaixo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>O sistema de importação foi atualizado para implementar completamente a segunda fase da <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>. Não há mais um mecanismo de importação implícito – o sistema completo de importação é exposto através de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Além disso, o suporte nativo a pacote de espaço de nomes foi implementado (consulte <span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>).</p>
</div>
<section id="importlib">
<h2 class="translated"><span class="section-number">5.1. </span><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a><a class="headerlink" href="#importlib" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">O módulo <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> fornece uma API rica para interagir com o sistema de importação. Por exemplo, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> fornece uma API mais simples e recomendada do que a função embutida <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> para chamar o mecanismo de importação. Consulte a documentação da biblioteca <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> para obter detalhes adicionais.</p>
</section>
<section id="packages">
<h2 class="translated"><span class="section-number">5.2. </span>Pacotes<a class="headerlink" href="#packages" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-3">O Python possui apenas um tipo de objeto de módulo e todos os módulos são desse tipo, independentemente de o módulo estar implementado em Python, C ou qualquer outra coisa. Para ajudar a organizar os módulos e fornecer uma hierarquia de nomes, o Python tem o conceito de <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">pacotes</span></a>.</p>
<p class="translated">Você pode pensar em pacotes como os diretórios em um sistema de arquivos e os módulos como arquivos nos diretórios, mas não tome essa analogia muito literalmente, já que pacotes e módulos não precisam se originar do sistema de arquivos. Para os fins desta documentação, usaremos essa analogia conveniente de diretórios e arquivos. Como os diretórios do sistema de arquivos, os pacotes são organizados hierarquicamente e os próprios pacotes podem conter subpacotes e módulos regulares.</p>
<p class="translated">É importante ter em mente que todos os pacotes são módulos, mas nem todos os módulos são pacotes. Ou, dito de outra forma, os pacotes são apenas um tipo especial de módulo. Especificamente, qualquer módulo que contenha um atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> é considerado um pacote.</p>
<p class="translated">Todo módulo tem um nome. Nomes de subpacotes são separados do nome do pacote por um ponto, semelhante à sintaxe de acesso aos atributos padrão do Python. Assim pode ter um pacote chamado <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>, que por sua vez tem um subpacote chamado <a class="reference internal" href="../library/email.mime.html#module-email.mime" title="email.mime: Build MIME messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code></a> e um módulo dentro dele chamado <a class="reference internal" href="../library/email.mime.html#module-email.mime.text" title="email.mime.text"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime.text</span></code></a>.</p>
<section id="regular-packages">
<h3 class="translated"><span class="section-number">5.2.1. </span>Pacotes regulares<a class="headerlink" href="#regular-packages" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-4">O Python define dois tipos de pacotes, <a class="reference internal" href="../glossary.html#term-regular-package"><span class="xref std std-term">pacotes regulares</span></a> e <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">pacotes de espaço de nomes</span></a>. Pacotes regulares são pacotes tradicionais, como existiam no Python 3.2 e versões anteriores. Um pacote regular é normalmente implementado como um diretório que contém um arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>. Quando um pacote regular é importado, esse arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> é executado implicitamente, e os objetos que ele define são vinculados aos nomes no espaço de nomes do pacote. O arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> pode conter o mesmo código Python que qualquer outro módulo pode conter, e o Python adicionará alguns atributos adicionais ao módulo quando ele for importado.</p>
<p class="translated">Por exemplo, o layout do sistema de arquivos a seguir define um pacote <code class="docutils literal notranslate"><span class="pre">parent</span></code> de nível superior com três subpacotes:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">one</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">two</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">three</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">A importação de <code class="docutils literal notranslate"><span class="pre">parent.one</span></code> vai executar implicitamente <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> e <code class="docutils literal notranslate"><span class="pre">parent/one/__init__.py</span></code>.  Importações subsequentes de <code class="docutils literal notranslate"><span class="pre">parent.two</span></code> ou <code class="docutils literal notranslate"><span class="pre">parent.three</span></code> vão executar <code class="docutils literal notranslate"><span class="pre">parent/two/__init__.py</span></code> e <code class="docutils literal notranslate"><span class="pre">parent/three/__init__.py</span></code>, respectivamente.</p>
</section>
<section id="namespace-packages">
<span id="reference-namespace-package"></span><h3 class="translated"><span class="section-number">5.2.2. </span>Pacotes de espaço de nomes<a class="headerlink" href="#namespace-packages" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-5">Um pacote de espaço de nomes é um composto de várias <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">porções</span></a>, em que cada parte contribui com um subpacote para o pacote pai. Partes podem residir em locais diferentes no sistema de arquivos. Partes também podem ser encontradas em arquivos zip, na rede ou em qualquer outro lugar que o Python pesquisar durante a importação. Os pacotes de espaço de nomes podem ou não corresponder diretamente aos objetos no sistema de arquivos; eles podem ser módulos virtuais que não têm representação concreta.</p>
<p class="translated">Os pacotes de espaço de nomes não usam uma lista comum para o atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code>. Em vez disso, eles usam um tipo iterável personalizado que executará automaticamente uma nova pesquisa por partes do pacote na próxima tentativa de importação dentro desse pacote, se o caminho do pacote pai (ou <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> para um pacote de nível superior) for alterado.</p>
<p class="translated">Com pacotes de espaço de nomes, não há arquivo <code class="docutils literal notranslate"><span class="pre">pai/__init__.py</span></code>. De fato, pode haver vários diretórios <code class="docutils literal notranslate"><span class="pre">pai</span></code> encontrados durante a pesquisa de importação, onde cada um é fornecido por uma parte diferente. Portanto, <code class="docutils literal notranslate"><span class="pre">pai/um</span></code> pode não estar fisicamente localizado próximo a <code class="docutils literal notranslate"><span class="pre">pai/dois</span></code>. Nesse caso, o Python criará um pacote de espaço de nomes para o pacote <code class="docutils literal notranslate"><span class="pre">pai</span></code> de nível superior sempre que ele ou um de seus subpacotes for importado.</p>
<p class="translated">Veja também <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> para a especificação de pacotes de espaço de nomes.</p>
</section>
</section>
<section id="searching">
<h2 class="translated"><span class="section-number">5.3. </span>Caminho de busca<a class="headerlink" href="#searching" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Para iniciar a busca, o Python precisa do nome <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">completo</span></a> do módulo (ou pacote, mas para o propósito dessa exposição, não há diferença) que se quer importar. Esse nome vem de vários argumentos passados para a instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, ou dos parâmetros das funções <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> ou <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.</p>
<p class="translated">Esse nome será usado em várias fases da busca da importação, e pode ser um nome com pontos para um submódulo como, por exemplo, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. Nesse caso, Python primeiro tenta importar <code class="docutils literal notranslate"><span class="pre">foo</span></code>, depois <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> e, finalmente, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. Se alguma das importações intermediárias falharem, uma exceção <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> é levantada.</p>
<section id="the-module-cache">
<h3 class="translated"><span class="section-number">5.3.1. </span>O cache de módulos<a class="headerlink" href="#the-module-cache" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-7">A primeira verificação durante a busca da importação é feita no <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Esse mapeamento serve como um cache de todos os módulos que já foram importados previamente, incluindo os caminhos intermediários. Se <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> foi previamente importado, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> conterá entradas para <code class="docutils literal notranslate"><span class="pre">foo</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> e <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. Cada chave terá como valor um objeto módulo correspondente.</p>
<p class="translated">Durante a importação, o nome do módulo é procurado em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> e, se estiver presente, o valor associado é o módulo que satisfaz a importação, e o processo termina. Entretanto, se o valor é <code class="docutils literal notranslate"><span class="pre">None</span></code>, uma exceção <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> é levantada. Se o nome do módulo não foi encontrado, Python continuará a busca pelo módulo.</p>
<p class="translated">É possível alterar <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Apagar uma chave pode não destruir o objeto módulo associado (outros módulos podem manter referências para ele), mas a entrada do cache será invalidada para o nome daquele módulo, fazendo Python executar nova busca na próxima importação. Pode ser atribuído <code class="docutils literal notranslate"><span class="pre">None</span></code> para a chave, forçando que a próxima importação do módulo resulte numa exceção <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.</p>
<p class="translated">No entanto, tenha cuidado, pois se você mantiver uma referência para o objeto módulo, invalidar sua entrada de cache em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> e, em seguida, reimportar do módulo nomeado, os dois módulo objetos <em>não</em> serão os mesmos. Por outro lado, o <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> reutilizará o <em>mesmo</em> objeto módulo e simplesmente reinicializará o conteúdo do módulo executando novamente o código do módulo.</p>
</section>
<section id="finders-and-loaders">
<span id="id2"></span><h3 class="translated"><span class="section-number">5.3.2. </span>Localizadores e carregadores<a class="headerlink" href="#finders-and-loaders" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-8">Se o módulo nomeado não for encontrado em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, então o protocolo de importação do Python é invocado para localizar e carregar o módulo. Este protocolo consiste em dois objetos conceituais, <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">localizadores</span></a> e <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">carregadores</span></a>. O trabalho de um localizador é determinar se ele pode localizar o módulo nomeado usando qualquer estratégia que ele conheça. Objetos que implementam ambas essas interfaces são referenciadas como <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importadores</span></a> – eles retornam a si mesmos, quando eles descobrem que eles podem carregar o módulo requisitado.</p>
<p class="translated">Python inclui um número de localizadores e carregadores padrões.  O primeiro sabe como localizar módulos embutidos, e o segundo sabe como localizar módulos congelados. Um terceiro localizador padrão procura em um <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a> por módulos. O <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a> é uma lista de localizações que podem nomear caminhos de sistema de arquivo ou arquivos zip. Ele também pode ser estendido para buscar por qualquer recurso localizável, tais como aqueles identificados por URLs.</p>
<p class="translated">O mecanismo de importação é extensível, então novos localizadores podem ser adicionados para estender o alcance e o escopo de buscar módulos.</p>
<p class="translated">Localizadores na verdade não carregam módulos. Se eles conseguirem encontrar o módulo nomeado, eles retornam um <em class="dfn">spec de módulo</em>, um encapsulamento da informação relacionada a importação do módulo, a qual o mecanismo de importação então usa quando o módulo é carregado.</p>
<p class="translated">As seguintes seções descrevem o protocolo para localizadores e carregadores em mais detalhes, incluindo como você pode criar e registrar novos para estender o mecanismo de importação.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Em versões anteriores do Python, localizadores retornavam <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">carregadores</span></a> diretamente, enquanto agora eles retornam especificações de módulo, as qual <em>contêm</em> carregadores. Carregadores ainda são usados durante a importação, mas possuem menos responsabilidades.</p>
</div>
</section>
<section id="import-hooks">
<h3 class="translated"><span class="section-number">5.3.3. </span>Ganchos de importação<a class="headerlink" href="#import-hooks" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-9">O mecanismo de importação é desenhado para ser extensível; o mecanismo primário para isso são os <em>ganchos de importação</em>.  Existem dois tipos de ganchos de importação: <em>metaganchos</em> e <em>ganchos de importação de caminho</em>.</p>
<p class="translated">Metaganchos são chamados no início do processo de importação, antes que qualquer outro processo de importação tenha ocorrido, que não seja busca de cache de <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Isso permite aos metaganchos substituir processamento de <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, módulos congelados ou mesmo módulos embutidos. Metaganchos são registrados adicionando novos objetos localizadores a <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, conforme descrito abaixo.</p>
<p class="translated">Ganchos de caminho de importação são chamados como parte do processamento de <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> (ou <code class="docutils literal notranslate"><span class="pre">package.__path__</span></code>), no ponto onde é encontrado o item do caminho associado. Ganchos de caminho de importação são registrados adicionando novos chamáveis para <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>, conforme descrito abaixo.</p>
</section>
<section id="the-meta-path">
<h3 class="translated"><span class="section-number">5.3.4. </span>O metacaminho<a class="headerlink" href="#the-meta-path" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-10">Quando o módulo nomeado não é encontrado em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, o Python em seguida o busca em <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, o qual contém uma lista de objetos localizadores de metacaminho. Esses localizadores são consultados a fim de verificar se eles sabem como manipular o módulo nomeado. Os localizadores de metacaminho devem implementar um método chamado <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>, o qual recebe três argumentos: um nome, um caminho de importação, e (opcionalmente) um módulo alvo. O localizador de metacaminho pode usar qualquer estratégia que ele quiser para determinar se ele pode manipular o módulo nomeado ou não.</p>
<p class="translated">Se o localizador de metacaminho souber como tratar o módulo nomeado, ele retorna um objeto spec. Se ele não puder tratar o módulo nomeado, ele retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Se o processamento de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> alcançar o fim da sua lista sem retornar um spec, então <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> é levantada. Quaisquer outras exceções levantadas são simplesmente propagadas para cima, abortando o processo de importação.</p>
<p class="translated">O método <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> dos localizadores de metacaminhos é chamado com dois ou três argumentos. O primeiro é o nome totalmente qualificado do módulo sendo importado, por exemplo <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. O segundo argumento são as entradas do caminho a ser usado na busca do módulo. Para módulos de nível superior, o segundo argumento é <code class="docutils literal notranslate"><span class="pre">None</span></code>, mas para submódulos ou subpacotes, o segundo argumento é o valor do atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> do pacote pai. Se o atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> apropriado não puder ser acessado, uma exceção <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> é levantada. O terceiro argumento é um objeto módulo existente que será o alvo do carregamento posteriormente. O sistema de importação passa um módulo alvo apenas durante o recarregamento.</p>
<p class="translated">O metacaminho pode ser percorrido múltiplas vezes para uma requisição de importação individual. Por exemplo, presumindo que nenhum dos módulos envolvidos já tenha sido cacheado, importar <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> irá primeiro executar uma importação de alto nível, chamando <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo&quot;,</span> <span class="pre">None,</span> <span class="pre">None)</span></code> em cada localizador de metacaminho (<code class="docutils literal notranslate"><span class="pre">mpf</span></code>). Depois que <code class="docutils literal notranslate"><span class="pre">foo</span></code> foi importado, <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> será importado percorrendo o metacaminho uma segunda vez, chamando <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar&quot;,</span> <span class="pre">foo.__path__,</span> <span class="pre">None)</span></code>. Uma vez que <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> tenha sido importado, a travessia final irá chamar <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar.baz&quot;,</span> <span class="pre">foo.bar.__path__,</span> <span class="pre">None)</span></code>.</p>
<p class="translated">Alguns localizadores de metacaminho apenas dão suporte a importações de alto nível. Estes importadores vão sempre retornar <code class="docutils literal notranslate"><span class="pre">None</span></code> quando qualquer coisa diferente de <code class="docutils literal notranslate"><span class="pre">None</span></code> for passada como o segundo argumento.</p>
<p class="translated">O <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> padrão do Python possui três localizador de metacaminho, um que sabe como importar módulos embutidos, um que sabe como importar módulos congelados, e outro que sabe como importar módulos de um <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a> (isto é, o <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>O método <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> dos localizador de metacaminho substituiu <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>, o qual agora foi descontinuado. Embora continue a funcionar sem alterações, a mecanismo de importação só tentará fazê-lo se o localizador não implementar <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>O uso de <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> pelo sistema de importação agora levanta <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> foi removido. Use <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
</div>
</section>
</section>
<section id="loading">
<h2 class="translated"><span class="section-number">5.4. </span>Carregando<a class="headerlink" href="#loading" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Se e quando uma spec de módulo é encontrada, o mecanismo de importação vai usá-la (e o carregador que ela contém) durante o carregamento do módulo. Esta é uma aproximação do que acontece durante a etapa de carregamento de uma importação:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;create_module&#39;</span><span class="p">):</span>
    <span class="c1"># É assumido que o carregador também define &#39;exec_module&#39;.</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">create_module</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">ModuleType</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># Define os atributos do módulo relacionados à importação:</span>
<span class="n">_init_module_attrs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>

<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># não suportado</span>
    <span class="k">raise</span> <span class="ne">ImportError</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># pacote espaço de nomes</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;exec_module&#39;</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span>
<span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">Perceba os seguintes detalhes:</p>
<ul class="simple">
<li><p class="translated">Se houver um objeto módulo existente com o nome fornecido em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, a importação já tera retornado ele.</p></li>
<li><p class="translated">O módulo irá existir em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes do carregador executar o código do módulo. Isso é crucial porque o código do módulo pode (direta ou indiretamente) importar a si mesmo; adicioná-lo a <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antecipadamente previne recursão infinita no pior caso e múltiplos carregamentos no melhor caso.</p></li>
<li><p class="translated">Se o carregamento falhar, o módulo com falha – e apenas o módulo com falha – é removido de <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Qualquer módulo já presente no cache de <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, e qualquer módulo que tenha sido carregado com sucesso como um efeito colateral, deve permanecer no cache. Isso contrasta com recarregamento, onde mesmo o módulo com falha é mantido em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.</p></li>
<li><p class="translated">Depois que o módulo é criado, mas antes da execução, o mecanismo de importação define os atributos de módulo relacionados a importação (“_init_module_attrs” no exemplo de pseudocódigo acima), assim como foi resumido em <a class="reference internal" href="datamodel.html#import-mod-attrs"><span class="std std-ref">uma seção posterior</span></a>.</p></li>
<li><p class="translated">Execução de módulo é o momento chave do carregamento, no qual o espaço de nomes do módulo é populado.  Execução é inteiramente delegada para o carregador, o qual pode decidir o que será populado e como.</p></li>
<li><p class="translated">O módulo criado durante o carregamento e passado para exec_module() pode não ser aquele retornado ao final da importação <a class="footnote-reference brackets" href="#fnlo" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>O sistema de importação tem tomado conta das responsabilidades inerentes dos carregadores. Essas responsabilidades eram anteriormente executadas pelo método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>.</p>
</div>
<section id="loaders">
<h3 class="translated"><span class="section-number">5.4.1. </span>Carregadores<a class="headerlink" href="#loaders" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os carregadores de módulo fornecem a função crítica de carregamento: execução do módulo. O mecanismo de importação chama o método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> com um único argumento, o objeto do módulo a ser executado. Qualquer valor retornado de <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> é ignorado.</p>
<p class="translated">Os carregadores devem atender aos seguintes requisitos:</p>
<ul class="simple">
<li><p class="translated">Se o módulo for um módulo Python (em oposição a um módulo embutido ou uma extensão carregada dinamicamente), o carregador deve executar o código do módulo no espaço de nomes global do módulo (<code class="docutils literal notranslate"><span class="pre">module.__dict__</span></code>).</p></li>
<li><p class="translated">Se o carregador não puder executar o módulo, ele deve levantar uma execção <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>, embora qualquer outra exceção levantada durante <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> será propagada.</p></li>
</ul>
<p class="translated">Em muitos casos, o localizador e o carregador podem ser o mesmo objeto; nesses casos o método <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> apenas retornaria um spec com o carregador definido como <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p class="translated">Os carregadores de módulo podem optar por criar o objeto do módulo durante o carregamento, implementando um método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>. Leva um argumento, o spec de módulo e retorna o novo objeto do módulo para usar durante o carregamento. <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> não precisa definir nenhum atributo no objeto do módulo. Se o método retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>, o mecanismo de importação criará ele mesmo o novo módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.4: </span>O método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> de carregadores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>O método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> foi substituído por <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> e o mecanismo de importação assumiu todas as responsabilidades inerentes de carregamento.</p>
<p class="translated">Para compatibilidade com carregadores existentes, o mecanismo de importação usará o método <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> de carregadores se ele existir e o carregador também não implementar <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code>. No entanto, <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> foi descontinuado e os carregadores devem implementar <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> em seu lugar.</p>
<p class="translated">O método <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> deve implementar toda a funcionalidade inerente de carregamento descrita acima, além de executar o módulo. Todas as mesmas restrições se aplicam, com alguns esclarecimentos adicionais:</p>
<ul class="simple">
<li><p class="translated">Se houver um objeto de módulo existente com o nome fornecido em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, o carregador deverá usar esse módulo existente. (Caso contrário, <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> não funcionará corretamente.) Se o módulo nomeado não existir em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, o carregador deverá criar um novo objeto de módulo e adicioná-lo a <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.</p></li>
<li><p class="translated">O módulo <em>deve</em> existir em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes que o carregador execute o código do módulo, para evitar recursão ilimitada ou carregamento múltiplo.</p></li>
<li><p class="translated">Se o carregamento falhar, o carregador deverá remover quaisquer módulos inseridos em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, mas deverá remover <strong>apenas</strong> o(s) módulo(s) com falha, e somente se o próprio carregador tiver carregado o(s) módulo(s) explicitamente.</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Uma exceção <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> é levantada quando <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> está definido, mas <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> não.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Uma exceção <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> é levantada quando <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> está definido, mas <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> não.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>O uso de <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> vai levantar <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
</section>
<section id="submodules">
<h3 class="translated"><span class="section-number">5.4.2. </span>Submódulos<a class="headerlink" href="#submodules" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Quando um submódulo é carregado usando qualquer mecanismo (por exemplo, APIs <code class="docutils literal notranslate"><span class="pre">importlib</span></code>, as instruções <code class="docutils literal notranslate"><span class="pre">import</span></code> ou <code class="docutils literal notranslate"><span class="pre">import-from</span></code>, ou a função <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> embutida) uma ligação é colocada no espaço de nomes do módulo pai para o objeto submódulo. Por exemplo, se o pacote <code class="docutils literal notranslate"><span class="pre">spam</span></code> tiver um submódulo <code class="docutils literal notranslate"><span class="pre">foo</span></code>, após importar <code class="docutils literal notranslate"><span class="pre">spam.foo</span></code>, <code class="docutils literal notranslate"><span class="pre">spam</span></code> terá um atributo <code class="docutils literal notranslate"><span class="pre">foo</span></code> que está vinculado ao submódulo. Digamos que você tenha a seguinte estrutura de diretórios:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">e <code class="docutils literal notranslate"><span class="pre">spam/__init__.py</span></code> tem a seguinte linha:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.foo</span><span class="w"> </span><span class="kn">import</span> <span class="n">Foo</span>
</pre></div>
</div>
<p class="translated">então executar o seguinte coloca ligações de nome para <code class="docutils literal notranslate"><span class="pre">foo</span></code> e <code class="docutils literal notranslate"><span class="pre">Foo</span></code> no módulo <code class="docutils literal notranslate"><span class="pre">spam</span></code>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;module &#39;spam.foo&#39; from &#39;/tmp/imports/spam/foo.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">Foo</span>
<span class="go">&lt;class &#39;spam.foo.Foo&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">Dadas as conhecidas regras de ligação de nomes do Python, isso pode parecer surpreendente, mas na verdade é um recurso fundamental do sistema de importação. A propriedade invariante é que se você tiver <code class="docutils literal notranslate"><span class="pre">sys.modules['spam']</span></code> e <code class="docutils literal notranslate"><span class="pre">sys.modules['spam.foo']</span></code> (como faria após a importação acima), o último deve aparecer como o atributo <code class="docutils literal notranslate"><span class="pre">foo</span></code> do primeiro.</p>
</section>
<section id="module-specs">
<span id="id4"></span><h3 class="translated"><span class="section-number">5.4.3. </span>Especificações de módulo<a class="headerlink" href="#module-specs" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">O mecanismo de importação utiliza diversas informações sobre cada módulo durante a importação, principalmente antes do carregamento. A maior parte das informações é comum a todos os módulos. O propósito da spec do módulo é encapsular essas informações relacionadas à importação por módulo.</p>
<p class="translated">Usar um spec durante a importação permite que o estado seja transferido entre componentes do sistema de importação, por exemplo entre o localizador que cria o spec de módulo e o carregador que o executa. Mais importante ainda, permite que o mecanismo de importação execute as operações inerentes de carregamento, enquanto que sem um spec de módulo o carregador tinha essa responsabilidade.</p>
<p class="translated">O spec do módulo é exposto no atributo <a class="reference internal" href="datamodel.html#module.__spec__" title="module.__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__</span></code></a>. A configuração oportuna do <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code> se aplica igualmente aos <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">módulos inicializados durante a inicialização do interpretador</span></a>. A única exceção é o <code class="docutils literal notranslate"><span class="pre">__main__</span></code>, cujo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code> é <a class="reference internal" href="#main-spec"><span class="std std-ref">definido como None em alguns casos</span></a>.</p>
<p class="translated">Consulte <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> para detalhes sobre o conteúdo do spec de módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.4.</span></p>
</div>
</section>
<section id="path-attributes-on-modules">
<span id="package-path-rules"></span><h3 class="translated"><span class="section-number">5.4.4. </span>Atributo __path__ dos módulos<a class="headerlink" href="#path-attributes-on-modules" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">O atributo <a class="reference internal" href="datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> deve ser uma <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequência</span></a> (possivelmente vazia) de strings enumerando os locais onde os submódulos do pacote serão encontrados. Por definição, um módulo que tenha um atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> é um <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">pacote</span></a>.</p>
<p class="translated">O atributo <a class="reference internal" href="datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> de um pacote é usado durante as importações de seus subpacotes. Dentro do mecanismo de importação, funciona da mesma forma que <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, ou seja, fornecendo uma lista de locais para procurar módulos durante a importação. Entretanto, o <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> normalmente é muito mais restrito que <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code>.</p>
<p class="translated">As mesmas regras usadas para <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> também se aplicam ao <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> de um pacote. Os <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (descritos abaixo) são consultados ao percorrer o <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> de um pacote.</p>
<p class="translated">O arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> de um pacote pode definir ou alterar o atributo <a class="reference internal" href="datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> do pacote, e esta era tipicamente a forma como os pacotes de espaço de nomes eram implementados antes da <span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>. Com a adoção da <span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>, os pacotes de espaço de nomes não precisam mais fornecer arquivos <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> contendo apenas código de manipulação do <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>; o mecanismo de importação define automaticamente o <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> corretamente para o pacote de espaço de nomes.</p>
</section>
<section id="module-reprs">
<h3 class="translated"><span class="section-number">5.4.5. </span>Representações do módulo<a class="headerlink" href="#module-reprs" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Por padrão, todos os módulos têm uma representação (repr) utilizável, no entanto, dependendo dos atributos definidos acima e do spec do módulo, você pode controlar mais explicitamente a representação dos objetos módulo.</p>
<p class="translated">Se o módulo tiver um spec (<code class="docutils literal notranslate"><span class="pre">__spec__</span></code>), o mecanismo de importação tentará gerar uma representação a partir dele. Se isso falhar ou não houver nenhuma especificação, o sistema de importação criará uma representação padrão usando qualquer informação disponível no módulo. Ele tentará usar <code class="docutils literal notranslate"><span class="pre">module.__name__</span></code>, <code class="docutils literal notranslate"><span class="pre">module.__file__</span></code> e <code class="docutils literal notranslate"><span class="pre">module.__loader__</span></code> como entrada para a representação, com padrões para qualquer informação que esteja faltando.</p>
<p class="translated">Arquivo estão as exatas regras usadas:</p>
<ul class="simple">
<li><p class="translated">Se o módulo tiver um atributo <code class="docutils literal notranslate"><span class="pre">__spec__</span></code>, a informação no spec é usada para gerar a representação. Os atributos “name”, “loader”, “origin” e “has_location” são consultados.</p></li>
<li><p class="translated">Se o módulo tiver um atributo <code class="docutils literal notranslate"><span class="pre">__file__</span></code>, ele será usado como parte da representação do módulo.</p></li>
<li><p class="translated">Se o módulo não tem <code class="docutils literal notranslate"><span class="pre">__file__</span></code> mas tem um <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> que não seja <code class="docutils literal notranslate"><span class="pre">None</span></code>, então a representação do carregador é usado como parte da representação do módulo.</p></li>
<li><p class="translated">Caso contrário, basta usar o <code class="docutils literal notranslate"><span class="pre">__name__</span></code> do módulo na representação.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span>O uso de <code class="xref py py-meth docutils literal notranslate"><span class="pre">module_repr()</span></code>, descontinuado desde o Python 3.4, foi removido no Python 3.12 e não é mais chamado durante a resolução da representação de um módulo.</p>
</div>
</section>
<section id="cached-bytecode-invalidation">
<span id="pyc-invalidation"></span><h3 class="translated"><span class="section-number">5.4.6. </span>Invalidação de bytecode em cache<a class="headerlink" href="#cached-bytecode-invalidation" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Antes do Python carregar o bytecode armazenado em cache de um arquivo <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>, ele verifica se o cache está atualizado com o arquivo fonte <code class="docutils literal notranslate"><span class="pre">.py</span></code>. Por padrão, o Python faz isso armazenando o registro de data e hora da última modificação da fonte e o tamanho no arquivo de cache ao escrevê-lo. No tempo de execução, o sistema de importação valida o arquivo de cache verificando os metadados armazenados no arquivo de cache em relação aos metadados do código-fonte.</p>
<p class="translated">Python também oferece suporte a arquivos de cache “baseados em hash”, que armazenam um hash do conteúdo do arquivo fonte em vez de seus metadados. Existem duas variantes de arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> baseados em hash: verificados e não verificados. Para arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> baseados em hash verificados, o Python valida o arquivo de cache fazendo hash do arquivo fonte e comparando o hash resultante com o hash no arquivo de cache. Se um arquivo de cache baseado em hash verificado for inválido, o Python o regenerará e gravará um novo arquivo de cache baseado em hash verificado. Para arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> baseados em hash não verificados, o Python simplesmente presume que o arquivo de cache é válido, se existir. O comportamento de validação de arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> baseados em hash pode ser substituído pelo sinalizador <a class="reference internal" href="../using/cmdline.html#cmdoption-check-hash-based-pycs"><code class="xref std std-option docutils literal notranslate"><span class="pre">--check-hash-based-pycs</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Adicionados arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> baseados em hash. Anteriormente, o Python oferecia suporte apenas à invalidação de caches de bytecode baseada em registro de data e hora.</p>
</div>
</section>
</section>
<section id="the-path-based-finder">
<h2 class="translated"><span class="section-number">5.5. </span>O localizador baseado no caminho<a class="headerlink" href="#the-path-based-finder" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-13">Conforme mencionado anteriormente, Python vem com vários localizadores de metacaminho padrão. Um deles, chamado <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code></a>), pesquisa um <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a>, que contém uma lista de <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">entradas de caminho</span></a>. Cada entrada de caminho nomeia um local para procurar módulos.</p>
<p class="translated">O próprio localizador baseado no caminho não sabe como importar nada. Em vez disso, ele percorre as entradas de caminho individuais, associando cada uma delas a um localizador de entrada de caminho que sabe como lidar com esse tipo específico de caminho.</p>
<p class="translated">O conjunto padrão de localizadores de entrada de caminho implementa toda a semântica para localizar módulos no sistema de arquivos, manipulando tipos de arquivos especiais, como código-fonte Python (arquivos <code class="docutils literal notranslate"><span class="pre">.py</span></code>), código de bytes Python (arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>) e bibliotecas compartilhadas (por exemplo, arquivos <code class="docutils literal notranslate"><span class="pre">.so</span></code>). Quando suportado pelo módulo <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> na biblioteca padrão, os localizadores de entrada de caminho padrão também lidam com o carregamento de todos esses tipos de arquivos (exceto bibliotecas compartilhadas) de arquivos zip.</p>
<p class="translated">As entradas de caminho não precisam ser limitadas aos locais do sistema de arquivos. Eles podem referir-se a URLs, consultas de banco de dados ou qualquer outro local que possa ser especificado como uma string.</p>
<p class="translated">O localizador baseado no caminho fornece ganchos e protocolos adicionais para que você possa estender e personalizar os tipos de entradas de caminho pesquisáveis. Por exemplo, se você quiser oferecer suporte a entradas de caminho como URLs de rede, poderá escrever um gancho que implemente a semântica HTTP para localizar módulos na web. Este gancho (um chamável) retornaria um <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> suportando o protocolo descrito abaixo, que foi então usado para obter um carregador para o módulo da web.</p>
<p class="translated">Uma palavra de advertência: esta seção e a anterior usam o termo <em>localizador</em>, distinguindo-os usando os termos <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">localizador de metacaminho</span></a> e <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a>. Esses dois tipos de localizadores são muito semelhantes, oferecem suporte a protocolos semelhantes e funcionam de maneira semelhante durante o processo de importação, mas é importante ter em mente que eles são sutilmente diferentes. Em particular, os localizadores de metacaminho operam no início do processo de importação, conforme a travessia de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.</p>
<p class="translated">Por outro lado, os localizadores de entrada de caminho são, em certo sentido, um detalhe de implementação do localizador baseado no caminho e, de fato, se o localizador baseado no caminho fosse removido de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, nenhuma semântica do localizador de entrada de caminho seria ser invocado.</p>
<section id="path-entry-finders">
<h3 class="translated"><span class="section-number">5.5.1. </span>Localizadores de entrada de caminho<a class="headerlink" href="#path-entry-finders" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-14">O <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> é responsável por encontrar e carregar módulos e pacotes Python cuja localização é especificada com uma string <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a>. A maioria das entradas de caminho nomeiam locais no sistema de arquivos, mas não precisam ser limitadas a isso.</p>
<p class="translated">Como um localizador de metacaminho, o <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> implementa o protocolo <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> descrito anteriormente, no entanto, ele expõe ganchos adicionais que podem ser usados para personalizar como os módulos são encontrados e carregado do <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a>.</p>
<p class="translated">Três variáveis são usadas pelo <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a>, <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> e <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. Os atributos <code class="docutils literal notranslate"><span class="pre">__path__</span></code> em objetos de pacote também são usados. Eles fornecem maneiras adicionais de personalizar o mecanismo de importação.</p>
<p class="translated"><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> contém uma lista de strings fornecendo locais de pesquisa para módulos e pacotes. Ele é inicializado a partir da variável de ambiente <span class="target" id="index-45"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> e vários outros padrões específicos de instalação e implementação. Entradas em <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> podem nomear diretórios no sistema de arquivos, arquivos zip e potencialmente outros “locais” (veja o módulo <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a>) que devem ser pesquisados por módulos, como URLs, ou consultas ao banco de dados. Apenas strings devem estar presentes em <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>; todos os outros tipos de dados são ignorados.</p>
<p class="translated">O <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> é um <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">localizador de metacaminho</span></a>, então o mecanismo de importação inicia a pesquisa no <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a> chamando o método <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> do localizador baseado no caminho conforme descrito anteriormente. Quando o argumento <code class="docutils literal notranslate"><span class="pre">path</span></code> para <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> for fornecido, será uma lista de caminhos de string a serem percorridos – normalmente o atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> de um pacote para uma importação dentro desse pacote. Se o argumento <code class="docutils literal notranslate"><span class="pre">path</span></code> for <code class="docutils literal notranslate"><span class="pre">None</span></code>, isso indica uma importação de nível superior e <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> é usado.</p>
<p class="translated">O localizador baseado no caminho itera sobre cada entrada no caminho de pesquisa e, para cada uma delas, procura um <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a>) apropriado para a entrada do caminho. Como esta pode ser uma operação custosa (por exemplo, pode haver sobrecargas de chamada <code class="docutils literal notranslate"><span class="pre">stat()</span></code> para esta pesquisa), o localizador baseado no caminho mantém um cache mapeando entradas de caminho para localizadores de entrada de caminho. Este cache é mantido em <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> (apesar do nome, este cache na verdade armazena objetos localizadores em vez de ser limitado a objetos <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importador</span></a>). Desta forma, a dispendiosa busca pelo <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> de local específico de uma <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a> só precisa ser feita uma vez. O código do usuário é livre para remover entradas de cache de <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>, forçando o localizador baseado no caminho a realizar a pesquisa de entrada de caminho novamente.</p>
<p class="translated">Se a entrada de caminho não estiver presente no cache, o localizador baseado no caminho itera sobre cada chamável em <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>. Cada um dos <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">ganchos de entrada de caminho</span></a> nesta lista é chamado com um único argumento, a entrada de caminho a ser pesquisada. Este chamável pode retornar um <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> que pode manipular a entrada de caminho ou pode levantar <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>. Um <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> é usado pelo localizador baseado no caminho para sinalizar que o gancho não consegue encontrar um <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> para aquela <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a>. A exceção é ignorada e a iteração com o <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">caminho de importação</span></a> continua. O gancho deve esperar um objeto string ou bytes; a codificação de objetos bytes depende do gancho (por exemplo, pode ser uma codificação de sistema de arquivos, UTF-8 ou outra coisa) e, se o gancho não puder decodificar o argumento, ele deve levantar <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
<p class="translated">Se a iteração <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> terminar sem que nenhum <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> seja retornado, o método <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> do localizador baseado no caminho armazenará <code class="docutils literal notranslate"><span class="pre">None</span></code> em <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> (para indicar que não há um localizador para esta entrada de caminho) e retornará <code class="docutils literal notranslate"><span class="pre">None</span></code>, indicando que este <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">localizador de metacaminho</span></a> não conseguiu encontrar o módulo.</p>
<p class="translated">Se um <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> <em>for</em> retornado por um dos chamáveis de <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">gancho de entrada de caminho</span></a> em <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>, então o seguinte protocolo é usado para solicitar ao localizador um spec de módulo, que é então usada ao carregar o módulo.</p>
<p class="translated">O diretório de trabalho atual – denotado por uma string vazia – é tratado de forma ligeiramente diferente de outras entradas em <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>. Primeiro, se o diretório de trabalho atual for considerado inexistente, nenhum valor será armazenado em <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. Segundo, o valor para o diretório de trabalho atual é pesquisado novamente para cada pesquisa de módulo. Terceiro, o caminho usado para <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> e retornado por <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_spec()</span></code></a> será o diretório de trabalho atual real e não a string vazia.</p>
</section>
<section id="path-entry-finder-protocol">
<h3 class="translated"><span class="section-number">5.5.2. </span>Protocolo do localizador de entrada de caminho<a class="headerlink" href="#path-entry-finder-protocol" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Para dar suporte a importações de módulos e pacotes inicializados e também contribuir com partes para pacotes de espaço de nomes, os localizadores de entrada de caminho devem implementar o método <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
<p class="translated"><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> recebe dois argumentos: o nome totalmente qualificado do módulo que está sendo importado e o módulo de destino (opcional). <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> retorna um spec totalmente preenchido para o módulo. Este spec sempre terá “loader” definido (com uma exceção).</p>
<p class="translated">Para indicar ao maquinário de importação que o spec representa uma <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">porção</span></a> de espaço de nomes, o localizador de entrada de caminho define <code class="docutils literal notranslate"><span class="pre">submodule_search_locations</span></code> como uma lista contendo a porção.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> substituiu <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>, ambos descontinuados, mas serão usados se <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> não estiver definido.</p>
<p class="translated">Os localizadores de entrada de caminho mais antigos podem implementar um desses dois métodos descontinuados em vez de <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code>. Os métodos ainda são respeitados para fins de compatibilidade com versões anteriores. No entanto, se <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> for implementado no localizador de entrada de caminho, os métodos legados serão ignorados.</p>
<p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> recebe um argumento, o nome totalmente qualificado do módulo que está sendo importado. <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> retorna uma tupla 2 onde o primeiro item é o carregador e o segundo item é uma <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">porção</span></a> de espaço de nomes.</p>
<p class="translated">Para compatibilidade com versões anteriores de outras implementações do protocolo de importação, muitos localizadores de entrada de caminho também dão suporte ao mesmo método tradicional <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> que os localizadores de metacaminho. No entanto, os métodos <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> do localizador de entrada de caminho nunca são chamados com um argumento <code class="docutils literal notranslate"><span class="pre">path</span></code> (espera-se que eles registrem as informações de caminho apropriadas da chamada inicial para o gancho de caminho).</p>
<p class="translated">O método <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> em localizadores de entrada de caminho foi descontinuado, pois não permite que o localizador de entrada de caminho contribua com porções para pacotes de espaço de nomes. Se <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> e <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> existirem em um localizador de entrada de caminho, o sistema de importação sempre chamará <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> em preferência a <code class="docutils literal notranslate"><span class="pre">find_module()</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span>Chamadas para <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> pelo sistema de importação vão levantar <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span><code class="docutils literal notranslate"><span class="pre">find_module()</span></code> e <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> foram removidos.</p>
</div>
</section>
</section>
<section id="replacing-the-standard-import-system">
<h2 class="translated"><span class="section-number">5.6. </span>Substituindo o sistema de importação padrão<a class="headerlink" href="#replacing-the-standard-import-system" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">O mecanismo mais confiável para substituir todo o sistema de importação é excluir o conteúdo padrão de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, substituindo-o inteiramente por um gancho de metacaminho personalizado.</p>
<p class="translated">Se for aceitável alterar apenas o comportamento de instruções de importação sem afetar outras APIs que acessam o sistema de importação, então substituir a função embutida <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> pode ser suficiente. Essa técnica também pode ser empregada no nível do módulo para alterar apenas o comportamento de instruções de importação dentro desse módulo.</p>
<p class="translated">Para impedir seletivamente a importação de alguns módulos de um gancho no início do metacaminho (em vez de desabilitar o sistema de importação padrão completamente), é suficiente levantar <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> diretamente de <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> em vez de retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>. O último indica que a busca do metacaminho deve continuar, enquanto levantar uma exceção a encerra imediatamente.</p>
</section>
<section id="package-relative-imports">
<span id="relativeimports"></span><h2 class="translated"><span class="section-number">5.7. </span>Importações relativas ao pacote<a class="headerlink" href="#package-relative-imports" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Importações relativas usam caracteres de ponto no início. Um único ponto no início indica uma importação relativa, começando com o pacote atual. Dois ou mais pontos no início indicam uma importação relativa para o(s) pai(s) do pacote atual, um nível por ponto após o primeiro. Por exemplo, dado o seguinte layout de pacote:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">package</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage1</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleX</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleY</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage2</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleZ</span><span class="o">.</span><span class="n">py</span>
    <span class="n">moduleA</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">Em <code class="docutils literal notranslate"><span class="pre">subpackage1/moduleX.py</span></code> ou <code class="docutils literal notranslate"><span class="pre">subpackage1/__init__.py</span></code>, as seguintes são importações relativas válidas:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.moduleY</span><span class="w"> </span><span class="kn">import</span> <span class="n">spam</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.moduleY</span><span class="w"> </span><span class="kn">import</span> <span class="n">spam</span> <span class="k">as</span> <span class="n">ham</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">moduleY</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..subpackage1</span><span class="w"> </span><span class="kn">import</span> <span class="n">moduleY</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..subpackage2.moduleZ</span><span class="w"> </span><span class="kn">import</span> <span class="n">eggs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..moduleA</span><span class="w"> </span><span class="kn">import</span> <span class="n">foo</span>
</pre></div>
</div>
<p class="translated">Importações absolutas podem usar a sintaxe <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;&gt;</span></code> ou <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">&lt;&gt;</span> <span class="pre">import</span> <span class="pre">&lt;&gt;</span></code>, mas importações relativas podem usar apenas a segunda forma; o motivo para isso é que:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">XXX.YYY.ZZZ</span>
</pre></div>
</div>
<p class="translated">deve expor <code class="docutils literal notranslate"><span class="pre">XXX.YYY.ZZZ</span></code> como uma expressão utilizável, mas .moduleY não é uma expressão válida.</p>
</section>
<section id="special-considerations-for-main">
<span id="import-dunder-main"></span><h2 class="translated"><span class="section-number">5.8. </span>Considerações especiais para __main__<a class="headerlink" href="#special-considerations-for-main" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">O módulo <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> é um caso especial em relação ao sistema de importação do Python. Conforme observado em <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">em outro lugar</span></a>, o módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> é inicializado diretamente na inicialização do interpretador, muito parecido com <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> e <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>. No entanto, diferentemente desses dois, ele não se qualifica estritamente como um módulo integrado. Isso ocorre porque a maneira como <code class="docutils literal notranslate"><span class="pre">__main__</span></code> é inicializado depende dos sinalizadores e outras opções com as quais o interpretador é invocado.</p>
<section id="main-spec">
<span id="id5"></span><h3 class="translated"><span class="section-number">5.8.1. </span>__main__.__spec__<a class="headerlink" href="#main-spec" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Dependendo de como <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> é inicializado, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> é definido apropriadamente ou como <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="translated">Quando o Python é iniciado com a opção <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a>, <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> é definido como o spec de módulo ou pacote correspondente. <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> também é preenchido quando o módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> é carregado como parte da execução de um diretório, arquivo zip ou outra entrada <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.</p>
<p class="translated"><a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">Nos demais casos</span></a>, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> é definido como <code class="docutils literal notranslate"><span class="pre">None</span></code>, pois o código usado para preencher o <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> não corresponde diretamente a um módulo importável:</p>
<ul class="simple">
<li><p class="translated">prompt interativo</p></li>
<li><p class="translated">opção <a class="reference internal" href="../using/cmdline.html#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a></p></li>
<li><p class="translated">executar a partir de stdin</p></li>
<li><p class="translated">executar diretamente de um arquivo de código-fonte ou bytecode</p></li>
</ul>
<p class="translated">Note que <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> é sempre <code class="docutils literal notranslate"><span class="pre">None</span></code> no último caso, <em>mesmo se</em> o arquivo pudesse ser importado diretamente como um módulo. Use a opção <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> se metadados de módulo válidos forem desejados em <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>.</p>
<p class="translated">Note também que mesmo quando <code class="docutils literal notranslate"><span class="pre">__main__</span></code> corresponde a um módulo importável e <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> é definido adequadamente, eles ainda são considerados módulos <em>distintos</em>. Isso se deve ao fato de que os blocos protegidos por verificações <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;:</span></code> são executados somente quando o módulo é usado para preencher o espaço de nomes <code class="docutils literal notranslate"><span class="pre">__main__</span></code>, e não durante a importação normal.</p>
</section>
</section>
<section id="references">
<h2 class="translated"><span class="section-number">5.9. </span>Referências<a class="headerlink" href="#references" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">O maquinário de importação evoluiu consideravelmente desde os primeiros dias do Python. A <a class="reference external" href="https://www.python.org/doc/essays/packages/">especificação original para pacotes</a> ainda está disponível para leitura, embora alguns detalhes tenham mudado desde a escrita desse documento.</p>
<p class="translated">A especificação original para <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> era <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>, com extensão subsequente em <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
<p class="translated"><span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> introduziu <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">pacotes de espaço de nomes</span></a> para Python 3.3. <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> também introduziu o protocolo <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> como uma alternativa ao <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>.</p>
<p class="translated"><span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> descreve a adição do atributo <code class="docutils literal notranslate"><span class="pre">__package__</span></code> para importações relativas explícitas em módulos principais.</p>
<p class="translated"><span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a> introduziu importações relativas absolutas e explícitas e inicialmente propôs <code class="docutils literal notranslate"><span class="pre">__name__</span></code> para semântica. <span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> eventualmente especificaria <code class="docutils literal notranslate"><span class="pre">__package__</span></code>.</p>
<p class="translated"><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0338/"><strong>PEP 338</strong></a> define módulos de execução como scripts.</p>
<p class="translated"><span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a> adiciona o encapsulamento do estado de importação por módulo em objetos spec. Ele também descarrega a maioria das responsabilidades inerentes dos carregadores de volta para o maquinário de importação. Essas mudanças permitem a descontinuação de várias APIs no sistema de importação e também a adição de novos métodos para localizadores e carregadores.</p>
<p class="translated rubric">Notas de rodapé</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fnmo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p class="translated">Veja <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>.</p>
</aside>
<aside class="footnote brackets" id="fnlo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p class="translated">A implementação de importlib evita usar o valor de retorno diretamente. Em vez disso, ela obtém o objeto do módulo procurando o nome do módulo em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. O efeito indireto disso é que um módulo importado pode substituir a si mesmo em <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Esse é um comportamento específico da implementação que não tem garantia de funcionar em outras implementações do Python.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">5. O sistema de importação</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="#packages">5.2. Pacotes</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. Pacotes regulares</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. Pacotes de espaço de nomes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. Caminho de busca</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. O cache de módulos</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. Localizadores e carregadores</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. Ganchos de importação</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. O metacaminho</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loading">5.4. Carregando</a><ul>
<li><a class="reference internal" href="#loaders">5.4.1. Carregadores</a></li>
<li><a class="reference internal" href="#submodules">5.4.2. Submódulos</a></li>
<li><a class="reference internal" href="#module-specs">5.4.3. Especificações de módulo</a></li>
<li><a class="reference internal" href="#path-attributes-on-modules">5.4.4. Atributo __path__ dos módulos</a></li>
<li><a class="reference internal" href="#module-reprs">5.4.5. Representações do módulo</a></li>
<li><a class="reference internal" href="#cached-bytecode-invalidation">5.4.6. Invalidação de bytecode em cache</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. O localizador baseado no caminho</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. Localizadores de entrada de caminho</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. Protocolo do localizador de entrada de caminho</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. Substituindo o sistema de importação padrão</a></li>
<li><a class="reference internal" href="#package-relative-imports">5.7. Importações relativas ao pacote</a></li>
<li><a class="reference internal" href="#special-considerations-for-main">5.8. Considerações especiais para __main__</a><ul>
<li><a class="reference internal" href="#main-spec">5.8.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">5.9. Referências</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="capítulo anterior"><span class="section-number">4. </span>Modelo de execução</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="expressions.html"
                          title="próximo capítulo"><span class="section-number">6. </span>Expressões</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/import.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. Expressões"
             >próximo</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de execução"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>O sistema de importação</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>