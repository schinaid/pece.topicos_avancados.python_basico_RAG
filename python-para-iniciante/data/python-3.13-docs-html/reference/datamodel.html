<!DOCTYPE html>

<html lang="pt-BR" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="3. Modelo de dados" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/datamodel.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Objetos, valores e tipos: Objetos são abstrações do Python para dados. Todos os dados em um programa Python são representados por objetos ou por relações entre objetos. (De certo modo, e em conform..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_reference_datamodel_b470097d.png" />
<meta property="og:image:alt" content="Objetos, valores e tipos: Objetos são abstrações do Python para dados. Todos os dados em um programa Python são representados por objetos ou por relações entre objetos. (De certo modo, e em conform..." />
<meta name="description" content="Objetos, valores e tipos: Objetos são abstrações do Python para dados. Todos os dados em um programa Python são representados por objetos ou por relações entre objetos. (De certo modo, e em conform..." />
<meta name="twitter:card" content="summary_large_image" />

    <title>3. Modelo de dados &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=62a4a58b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=71a39b36"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="4. Modelo de execução" href="executionmodel.html" />
    <link rel="prev" title="2. Análise léxica" href="lexical_analysis.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">3. Modelo de dados</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores e tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. A hierarquia de tipos padrão</a><ul>
<li><a class="reference internal" href="#none">3.2.1. None</a></li>
<li><a class="reference internal" href="#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="#ellipsis">3.2.3. Ellipsis</a></li>
<li><a class="reference internal" href="#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences">3.2.5. Sequências</a><ul>
<li><a class="reference internal" href="#immutable-sequences">3.2.5.1. Sequências imutáveis</a></li>
<li><a class="reference internal" href="#mutable-sequences">3.2.5.2. Sequências mutáveis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types">3.2.6. Tipos de conjuntos</a></li>
<li><a class="reference internal" href="#mappings">3.2.7. Mapeamentos</a><ul>
<li><a class="reference internal" href="#dictionaries">3.2.7.1. Dicionários</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callable-types">3.2.8. Tipos chamáveis</a><ul>
<li><a class="reference internal" href="#user-defined-functions">3.2.8.1. Funções definidas pelo usuário</a><ul>
<li><a class="reference internal" href="#special-read-only-attributes">3.2.8.1.1. Atributos especiais de somente leitura</a></li>
<li><a class="reference internal" href="#special-writable-attributes">3.2.8.1.2. Atributos especiais graváveis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instance-methods">3.2.8.2. Métodos de instância</a></li>
<li><a class="reference internal" href="#generator-functions">3.2.8.3. Funções geradoras</a></li>
<li><a class="reference internal" href="#coroutine-functions">3.2.8.4. Funções de corrotina</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">3.2.8.5. Funções geradoras assíncronas</a></li>
<li><a class="reference internal" href="#built-in-functions">3.2.8.6. Funções embutidas</a></li>
<li><a class="reference internal" href="#built-in-methods">3.2.8.7. Métodos embutidos</a></li>
<li><a class="reference internal" href="#classes">3.2.8.8. Classes</a></li>
<li><a class="reference internal" href="#class-instances">3.2.8.9. Instâncias de classe</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">3.2.9. Módulos</a><ul>
<li><a class="reference internal" href="#import-related-attributes-on-module-objects">3.2.9.1. Atributos relacionados à importação em objetos de módulo</a></li>
<li><a class="reference internal" href="#other-writable-attributes-on-module-objects">3.2.9.2. Outros atributos graváveis em objetos de módulo</a></li>
<li><a class="reference internal" href="#module-dictionaries">3.2.9.3. Dicionários do módulo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-classes">3.2.10. Classes personalizadas</a><ul>
<li><a class="reference internal" href="#special-attributes">3.2.10.1. Atributos especiais</a></li>
<li><a class="reference internal" href="#special-methods">3.2.10.2. Métodos especiais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">3.2.11. Instâncias de classe</a><ul>
<li><a class="reference internal" href="#id5">3.2.11.1. Atributos especiais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-o-objects-also-known-as-file-objects">3.2.12. Objetos de E/S (também conhecidos como objetos arquivo)</a></li>
<li><a class="reference internal" href="#internal-types">3.2.13. Tipos internos</a><ul>
<li><a class="reference internal" href="#code-objects">3.2.13.1. Objetos código</a><ul>
<li><a class="reference internal" href="#index-60">3.2.13.1.1. Atributos especiais de somente leitura</a></li>
<li><a class="reference internal" href="#methods-on-code-objects">3.2.13.1.2. Métodos de objetos código</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frame-objects">3.2.13.2. Objetos quadro</a><ul>
<li><a class="reference internal" href="#index-66">3.2.13.2.1. Atributos especiais de somente leitura</a></li>
<li><a class="reference internal" href="#index-67">3.2.13.2.2. Atributos especiais graváveis</a></li>
<li><a class="reference internal" href="#frame-object-methods">3.2.13.2.3. Métodos de objetos quadro</a></li>
</ul>
</li>
<li><a class="reference internal" href="#traceback-objects">3.2.13.3. Objetos traceback</a></li>
<li><a class="reference internal" href="#slice-objects">3.2.13.4. Objetos slice</a></li>
<li><a class="reference internal" href="#static-method-objects">3.2.13.5. Objetos método estático</a></li>
<li><a class="reference internal" href="#class-method-objects">3.2.13.6. Objetos método de classe</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#special-method-names">3.3. Nomes de métodos especiais</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalização básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando o acesso aos atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acesso a atributos de módulos</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando descritores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando descritores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalizando a criação de classe</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclasses</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolvendo entradas de MRO</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando a metaclasse apropriada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando o espaço de nomes da classe</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Executando o corpo da classe</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Criando o objeto classe</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando verificações de instância e subclasse</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. O propósito de <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos chamáveis</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando tipos contêineres</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gerenciadores de contexto da instrução with</a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Customizando argumentos posicionais na classe correspondência de padrão</a></li>
<li><a class="reference internal" href="#emulating-buffer-types">3.3.11. Emulando tipos buffer</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.12. Pesquisa de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrotinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos aguardáveis</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos corrotina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores assíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gerenciadores de contexto assíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="capítulo anterior"><span class="section-number">2. </span>Análise léxica</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="próximo capítulo"><span class="section-number">4. </span>Modelo de execução</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de execução"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análise léxica"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de dados</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1 class="translated"><span class="section-number">3. </span>Modelo de dados<a class="headerlink" href="#data-model" title="Link para este cabeçalho">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2 class="translated"><span class="section-number">3.1. </span>Objetos, valores e tipos<a class="headerlink" href="#objects-values-and-types" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-0"><em class="dfn">Objetos</em> são abstrações do Python para dados. Todos os dados em um programa Python são representados por objetos ou por relações entre objetos. (De certo modo, e em conformidade com o modelo de Von Neumann de um “computador com programa armazenado”, código também é representado por objetos.)</p>
<span class="target" id="index-1"></span><p class="translated">Todo objeto tem uma identidade, um tipo e um valor. A <em>identidade</em> de um objeto nunca muda depois de criado; você pode pensar nisso como endereço de objetos em memória. O operador <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> compara as identidades de dois objetos; a função <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> retorna um inteiro representando sua identidade.</p>
<div class="impl-detail compound">
<p class="translated">Para CPython, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> é o endereço de memória em que <code class="docutils literal notranslate"><span class="pre">x</span></code> está armazenado.</p>
</div>
<p class="translated">O tipo de um objeto determina as operações que o objeto implementa (por exemplo, “ele tem um comprimento?”) e também define os valores possíveis para objetos desse tipo. A função <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> retorna o tipo de um objeto (que é também um objeto). Como sua identidade, o <em class="dfn">tipo</em> do objeto também é imutável. <a class="footnote-reference brackets" href="#id19" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p class="translated">O <em>valor</em> de alguns objetos pode mudar. Objetos cujos valores podem mudar são descritos como <em>mutáveis</em>, objetos cujo valor não pode ser mudado uma vez que foram criados são chamados <em>imutáveis</em>. (O valor de um objeto contêiner imutável que contém uma referência a um objeto mutável pode mudar quando o valor deste último for mudado; no entanto o contêiner é ainda assim considerada imutável, pois a coleção de objetos que contém não pode ser mudada. Então a imutabilidade não é estritamente o mesmo do que não haver mudanças de valor, é mais sutil.) A mutabilidade de um objeto é determinada pelo seu tipo; por exemplo, números, strings e tuplas são imutáveis, enquanto dicionários e listas são mutáveis.</p>
<p class="translated" id="index-2">Os objetos nunca são destruídos explicitamente; no entanto, quando eles se tornam inacessíveis, eles podem ser coletados como lixo. Uma implementação tem permissão para adiar a coleta de lixo ou omiti-la completamente – é uma questão de detalhe de implementação como a coleta de lixo é implementada, desde que nenhum objeto que ainda esteja acessível seja coletado.</p>
<div class="impl-detail compound">
<p class="translated">CPython atualmente usa um esquema de contagem de referências com detecção atrasada (opcional) de lixo ligado ciclicamente, que coleta a maioria dos objetos assim que eles se tornam inacessíveis, mas não é garantido que coletará lixo contendo referências circulares. Veja a documentação do módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> para informações sobre como controlar a coleta de lixo cíclico. Outras implementações agem de forma diferente e o CPython pode mudar. Não dependa da finalização imediata dos objetos quando eles se tornarem inacessíveis (isto é, você deve sempre fechar os arquivos explicitamente).</p>
</div>
<p class="translated">Observe que o uso dos recursos de rastreamento ou depuração da implementação pode manter os objetos ativos que normalmente seriam coletáveis. Observe também que capturar uma exceção com uma instrução <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> pode manter os objetos vivos.</p>
<p class="translated">Alguns objetos contêm referências a recursos “externos”, como arquivos abertos ou janelas. Entende-se que esses recursos são liberados quando o objeto é coletado como lixo, mas como a coleta de lixo não é garantida, tais objetos também fornecem uma maneira explícita de liberar o recurso externo, geralmente um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code>. Os programas são fortemente recomendados para fechar explicitamente esses objetos. A instrução <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> e a instrução <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> fornecem maneiras convenientes de fazer isso.</p>
<p class="translated" id="index-3">Alguns objetos contêm referências a outros objetos; eles são chamados de <em>contêineres</em>. Exemplos de contêineres são tuplas, listas e dicionários. As referências fazem parte do valor de um contêiner. Na maioria dos casos, quando falamos sobre o valor de um contêiner, nos referimos aos valores, não às identidades dos objetos contidos; entretanto, quando falamos sobre a mutabilidade de um contêiner, apenas as identidades dos objetos contidos imediatamente estão implícitas. Portanto, se um contêiner imutável (como uma tupla) contém uma referência a um objeto mutável, seu valor muda se esse objeto mutável for alterado.</p>
<p class="translated">Os tipos afetam quase todos os aspectos do comportamento do objeto. Até mesmo a importância da identidade do objeto é afetada em algum sentido: para tipos imutáveis, as operações que calculam novos valores podem realmente retornar uma referência a qualquer objeto existente com o mesmo tipo e valor, enquanto para objetos mutáveis isso não é permitido. Por exemplo, após <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code>, <em>a</em> e <em>b</em> podem ou não se referir ao mesmo objeto com o valor um, dependendo da implementação. Isto ocorre porque <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> é um tipo imutável, então a referência a <code class="docutils literal notranslate"><span class="pre">1</span></code> pode ser reutilizada. Este comportamento depende da implementação usada, então não deve ser considerada confiável, mas é algo para se estar ciente ao fazer uso de testes de identidade de objeto. No entanto, após <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code>, <em>c</em> e <em>d</em> têm a garantia de referir-se a duas listas vazias diferentes e únicas. (Observe que <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">[]</span></code> atribui o <em>mesmo</em> objeto para <em>e</em> e <em>f</em>.)</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2 class="translated"><span class="section-number">3.2. </span>A hierarquia de tipos padrão<a class="headerlink" href="#the-standard-type-hierarchy" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-4">Abaixo está uma lista dos tipos que são embutidos no Python. Módulos de extensão (escritos em C, Java ou outras linguagens, dependendo da implementação) podem definir tipos adicionais. Versões futuras do Python podem adicionar tipos à hierarquia de tipo (por exemplo, números racionais, matrizes de inteiros armazenadas de forma eficiente, etc.), embora tais adições sejam frequentemente fornecidas por meio da biblioteca padrão.</p>
<p class="translated" id="index-5">Algumas das descrições de tipo abaixo contêm um parágrafo listando “atributos especiais”. Esses são atributos que fornecem acesso à implementação e não se destinam ao uso geral. Sua definição pode mudar no futuro.</p>
<section id="none">
<h3 class="translated"><span class="section-number">3.2.1. </span>None<a class="headerlink" href="#none" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-6">Este tipo possui um único valor. Existe um único objeto com este valor. Este objeto é acessado através do nome embutido <code class="docutils literal notranslate"><span class="pre">None</span></code>. É usado para significar a ausência de um valor em muitas situações, por exemplo, ele é retornado de funções que não retornam nada explicitamente. Seu valor verdade é falso.</p>
</section>
<section id="notimplemented">
<h3 class="translated"><span class="section-number">3.2.2. </span>NotImplemented<a class="headerlink" href="#notimplemented" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-7">Este tipo possui um único valor. Existe um único objeto com este valor. Este objeto é acessado através do nome embutido <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>. Os métodos numéricos e métodos de comparação rica devem retornar esse valor se não implementarem a operação para os operandos fornecidos. (O interpretador tentará então a operação refletida ou alguma outra alternativa, dependendo do operador.) Não deve ser avaliado em um contexto booleano.</p>
<p class="translated">Veja a documentação <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">Implementando as operações aritméticas</span></a> para mais detalhes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.9: </span>A avaliação de <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> em um contexto booleano foi descontinuada. Embora atualmente seja avaliada como verdadeiro, é emitida uma exceção <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>. Levantará uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> em uma versão futura do Python.</p>
</div>
</section>
<section id="ellipsis">
<h3 class="translated"><span class="section-number">3.2.3. </span>Ellipsis<a class="headerlink" href="#ellipsis" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-8">Este tipo possui um único valor. Existe um único objeto com este valor. Este objeto é acessado através do literal <code class="docutils literal notranslate"><span class="pre">...</span></code> ou do nome embutido <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> (reticências). Seu valor verdade é verdadeiro.</p>
</section>
<section id="numbers-number">
<h3 class="translated"><span class="section-number">3.2.4. </span><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><a class="headerlink" href="#numbers-number" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-9">Esses são criados por literais numéricos e retornados como resultados por operadores aritméticos e funções aritméticas embutidas. Os objetos numéricos são imutáveis; uma vez criado, seu valor nunca muda. Os números do Python são, obviamente, fortemente relacionados aos números matemáticos, mas sujeitos às limitações da representação numérica em computadores.</p>
<p class="translated">As representações de string das classes numéricas, calculadas por <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> e <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, têm as seguintes propriedades:</p>
<ul class="simple">
<li><p class="translated">Elas são literais numéricos válidos que, quando passados para seu construtor de classe, produzem um objeto com o valor do numérico original.</p></li>
<li><p class="translated">A representação está na base 10, quando possível.</p></li>
<li><p class="translated">Os zeros à esquerda, possivelmente com exceção de um único zero antes de um ponto decimal, não são mostrados.</p></li>
<li><p class="translated">Os zeros à direita, possivelmente com exceção de um único zero após um ponto decimal, não são mostrados.</p></li>
<li><p class="translated">Um sinal é mostrado apenas quando o número é negativo.</p></li>
</ul>
<p class="translated">Python distingue entre inteiros, números de ponto flutuante e números complexos:</p>
<section id="numbers-integral">
<h4 class="translated"><span class="section-number">3.2.4.1. </span><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a><a class="headerlink" href="#numbers-integral" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-10">Estes representam elementos do conjunto matemático de inteiros (positivos e negativos).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated" id="index-11">As regras para representação de inteiros têm como objetivo fornecer a interpretação mais significativa das operações de deslocamento e máscara envolvendo inteiros negativos.</p>
</div>
<p class="translated">Existem dois tipos de inteiros:</p>
<dl>
<dt class="translated">Inteiros (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p class="translated">Estes representam números em um intervalo ilimitado, sujeito apenas à memória (virtual) disponível. Para o propósito de operações de deslocamento e máscara, uma representação binária é presumida e os números negativos são representados em uma variante do complemento de 2 que dá a ilusão de uma string infinita de bits de sinal estendendo-se para a esquerda.</p>
</dd>
<dt class="translated">Booleanos (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p class="translated" id="index-12">Estes representam os valores da verdade Falsos e Verdadeiros. Os dois objetos que representam os valores <code class="docutils literal notranslate"><span class="pre">False</span></code> e <code class="docutils literal notranslate"><span class="pre">True</span></code> são os únicos objetos booleanos. O tipo booleano é um subtipo do tipo inteiro, e os valores booleanos se comportam como os valores 0 e 1, respectivamente, em quase todos os contextos, com exceção de que, quando convertidos em uma string, as strings <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> ou <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> são retornados, respectivamente.</p>
</dd>
</dl>
</section>
<section id="numbers-real-float">
<h4 class="translated"><span class="section-number">3.2.4.2. </span><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)<a class="headerlink" href="#numbers-real-float" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-13">Estes representam números de ponto flutuante de precisão dupla no nível da máquina. Você está à mercê da arquitetura da máquina subjacente (e implementação C ou Java) para o intervalo aceito e tratamento de estouro. Python não oferece suporte a números de ponto flutuante de precisão única; a economia no uso do processador e da memória, que normalmente é o motivo de usá-los, é ofuscada pela sobrecarga do uso de objetos em Python, portanto, não há razão para complicar a linguagem com dois tipos de números de ponto flutuante.</p>
</section>
<section id="numbers-complex-complex">
<h4 class="translated"><span class="section-number">3.2.4.3. </span><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)<a class="headerlink" href="#numbers-complex-complex" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-14">Estes representam números complexos como um par de números de ponto flutuante de precisão dupla no nível da máquina. As mesmas advertências se aplicam aos números de ponto flutuante. As partes reais e imaginárias de um número complexo <code class="docutils literal notranslate"><span class="pre">z</span></code> podem ser obtidas através dos atributos somente leitura <code class="docutils literal notranslate"><span class="pre">z.real</span></code> e <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>.</p>
</section>
</section>
<section id="sequences">
<h3 class="translated"><span class="section-number">3.2.5. </span>Sequências<a class="headerlink" href="#sequences" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-15">Estes representam conjuntos ordenados finitos indexados por números não negativos. A função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna o número de itens de uma sequência. Quando o comprimento de uma sequência é <em>n</em>, o conjunto de índices contém os números 0, 1, …, <em>n</em>-1. O item <em>i</em> da sequência <em>a</em> é selecionado por <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>. Algumas sequências, incluindo sequências embutidas, interpretam subscritos negativos adicionando o comprimento da sequência. Por exemplo, <code class="docutils literal notranslate"><span class="pre">a[-2]</span></code> é igual a <code class="docutils literal notranslate"><span class="pre">a[n-2]</span></code>, o penúltimo item da sequência a com comprimento <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p class="translated" id="index-16">Sequências também provê fatiamento: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> seleciona todos os itens com índice <em>k</em> de forma que <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>. Quando usada como expressão, uma fatia é uma sequência do mesmo tipo. O comentário acima sobre índices negativos também se aplica a posições de fatias negativas.</p>
<p class="translated">Algumas sequências também suportam “fatiamento estendido” com um terceiro parâmetro de “etapa”: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> seleciona todos os itens de <em>a</em> com índice <em>x</em> onde <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code> e <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.</p>
<p class="translated">As sequências são distinguidas de acordo com sua mutabilidade:</p>
<section id="immutable-sequences">
<h4 class="translated"><span class="section-number">3.2.5.1. </span>Sequências imutáveis<a class="headerlink" href="#immutable-sequences" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-17">Um objeto de um tipo de sequência imutável não pode ser alterado depois de criado. (Se o objeto contiver referências a outros objetos, esses outros objetos podem ser mutáveis e podem ser alterados; no entanto, a coleção de objetos diretamente referenciada por um objeto imutável não pode ser alterada.)</p>
<p class="translated">Os tipos a seguir são sequências imutáveis:</p>
<dl id="index-18">
<dt class="translated">Strings</dt><dd><p class="translated" id="index-19">Uma string é uma sequência de valores que representam pontos de código Unicode. Todos os pontos de código no intervalo <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> podem ser representados em uma string. Python não tem um tipo <span class="c-expr sig sig-inline c"><span class="kt">char</span></span>; em vez disso, cada ponto de código na string é representado como um objeto string com comprimento <code class="docutils literal notranslate"><span class="pre">1</span></code>. A função embutida <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> converte um ponto de código de sua forma de string para um inteiro no intervalo <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code>; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> converte um inteiro no intervalo <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> para o objeto de string correspondente de comprimento <code class="docutils literal notranslate"><span class="pre">1</span></code>. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> pode ser usado para converter uma <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> para <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> usando a codificação de texto fornecida, e <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> pode ser usado para conseguir o oposto.</p>
</dd>
<dt class="translated">Tuplas</dt><dd><p class="translated" id="index-20">Os itens de uma tupla são objetos Python arbitrários. Tuplas de dois ou mais itens são formadas por listas de expressões separadas por vírgulas. Uma tupla de um item (um “singleton”) pode ser formada afixando uma vírgula a uma expressão (uma expressão por si só não cria uma tupla, já que os parênteses devem ser usados para agrupamento de expressões). Uma tupla vazia pode ser formada por um par vazio de parênteses.</p>
</dd>
<dt class="translated">Bytes</dt><dd><p class="translated" id="index-21">Um objeto bytes é um vetor imutável. Os itens são bytes de 8 bits, representados por inteiros no intervalo 0 &lt;= x &lt; 256. Literais de bytes (como <code class="docutils literal notranslate"><span class="pre">b'abc'</span></code>) e o construtor embutido <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> podem ser usados para criar objetos bytes. Além disso, os objetos bytes podem ser decodificados em strings através do método <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a>.</p>
</dd>
</dl>
</section>
<section id="mutable-sequences">
<h4 class="translated"><span class="section-number">3.2.5.2. </span>Sequências mutáveis<a class="headerlink" href="#mutable-sequences" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-22">As sequências mutáveis podem ser alteradas após serem criadas. As notações de subscrição e fatiamento podem ser usadas como o destino da atribuição e instruções <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (<em>delete</em>, exclusão).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated" id="index-24"><span id="index-23"></span>Os módulos <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> e <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> fornecem exemplos adicionais de tipos de sequência mutáveis.</p>
</div>
<p class="translated">Atualmente, existem dois tipos de sequência mutável intrínseca:</p>
<dl>
<dt class="translated">Listas</dt><dd><p class="translated" id="index-25">Os itens de uma lista são objetos Python arbitrários. As listas são formadas colocando uma lista de expressões separada por vírgulas entre colchetes. (Observe que não há casos especiais necessários para formar listas de comprimento 0 ou 1.)</p>
</dd>
<dt class="translated">Vetores de bytes</dt><dd><p class="translated" id="index-26">Um objeto bytearray é um vetor mutável. Eles são criados pelo construtor embutido <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a>. Além de serem mutáveis (e, portanto, não-hasheável), os vetores de bytes fornecem a mesma interface e funcionalidade que os objetos imutáveis <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
</dl>
</section>
</section>
<section id="set-types">
<h3 class="translated"><span class="section-number">3.2.6. </span>Tipos de conjuntos<a class="headerlink" href="#set-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-27">Estes representam conjuntos finitos e não ordenados de objetos únicos e imutáveis. Como tal, eles não podem ser indexados por nenhum subscrito. No entanto, eles podem ser iterados, e a função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna o número de itens em um conjunto. Os usos comuns para conjuntos são testes rápidos de associação, remoção de duplicatas de uma sequência e computação de operações matemáticas como interseção, união, diferença e diferença simétrica.</p>
<p class="translated">Para elementos de conjunto, as mesmas regras de imutabilidade se aplicam às chaves de dicionário. Observe que os tipos numéricos obedecem às regras normais para comparação numérica: se dois números forem iguais (por exemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> e <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), apenas um deles pode estar contido em um conjunto.</p>
<p class="translated">Atualmente, existem dois tipos de conjuntos intrínsecos:</p>
<dl>
<dt class="translated">Conjuntos</dt><dd><p class="translated" id="index-28">Estes representam um conjunto mutável. Eles são criados pelo construtor embutido <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> e podem ser modificados posteriormente por vários métodos, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code>.</p>
</dd>
<dt class="translated">Conjuntos congelados</dt><dd><p class="translated" id="index-29">Estes representam um conjunto imutável. Eles são criados pelo construtor embutido <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a>. Como um frozenset é imutável e <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hasheável</span></a>, ele pode ser usado novamente como um elemento de outro conjunto, ou como uma chave de dicionário.</p>
</dd>
</dl>
</section>
<section id="mappings">
<h3 class="translated"><span class="section-number">3.2.7. </span>Mapeamentos<a class="headerlink" href="#mappings" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-30">Eles representam conjuntos finitos de objetos indexados por conjuntos de índices arbitrários. A notação subscrito <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> seleciona o item indexado por <code class="docutils literal notranslate"><span class="pre">k</span></code> do mapeamento <code class="docutils literal notranslate"><span class="pre">a</span></code>; isso pode ser usado em expressões e como alvo de atribuições ou instruções <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. A função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna o número de itens em um mapeamento.</p>
<p class="translated">Atualmente, há um único tipo de mapeamento intrínseco:</p>
<section id="dictionaries">
<h4 class="translated"><span class="section-number">3.2.7.1. </span>Dicionários<a class="headerlink" href="#dictionaries" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-31">Eles representam conjuntos finitos de objetos indexados por valores quase arbitrários. Os únicos tipos de valores não aceitáveis como chaves são os valores que contêm listas ou dicionários ou outros tipos mutáveis que são comparados por valor em vez de por identidade de objeto, o motivo é que a implementação eficiente de dicionários requer que o valor de hash de uma chave permaneça constante. Os tipos numéricos usados para chaves obedecem às regras normais para comparação numérica: se dois números forem iguais (por exemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> e <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), eles podem ser usados alternadamente para indexar a mesma entrada do dicionário.</p>
<p class="translated">Dicionários preservam a ordem de inserção, o que significa que as chaves serão produzidas na mesma ordem em que foram adicionadas sequencialmente no dicionário. Substituir uma chave existente não altera a ordem, no entanto, remover uma chave e inseri-la novamente irá adicioná-la ao final em vez de manter seu lugar anterior.</p>
<p class="translated">Os dicionários são mutáveis; eles podem ser criados pela notação <code class="docutils literal notranslate"><span class="pre">{}</span></code> (veja a seção <a class="reference internal" href="expressions.html#dict"><span class="std std-ref">Sintaxes de criação de dicionário</span></a>).</p>
<p class="translated" id="index-32">Os módulos de extensão <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The New Database Manager (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> e <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU database manager (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> fornecem exemplos adicionais de tipos de mapeamento, assim como o módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Dicionários não preservavam a ordem de inserção nas versões do Python anteriores à 3.6. No CPython 3.6, a ordem de inserção foi preservada, mas foi considerada um detalhe de implementação naquela época, em vez de uma garantia da linguagem.</p>
</div>
</section>
</section>
<section id="callable-types">
<h3 class="translated"><span class="section-number">3.2.8. </span>Tipos chamáveis<a class="headerlink" href="#callable-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-33">Estes são os tipos aos quais a operação de chamada de função (veja a seção <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">Chamadas</span></a>) pode ser aplicada:</p>
<section id="user-defined-functions">
<span id="user-defined-funcs"></span><h4 class="translated"><span class="section-number">3.2.8.1. </span>Funções definidas pelo usuário<a class="headerlink" href="#user-defined-functions" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-34">Um objeto função definido pelo usuário será criado pela definição de função (veja a seção <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>). A mesma deverá ser invocada com uma lista de argumentos contendo o mesmo número de itens que a lista de parâmetros formais da função.</p>
<section id="special-read-only-attributes">
<h5 class="translated"><span class="section-number">3.2.8.1.1. </span>Atributos especiais de somente leitura<a class="headerlink" href="#special-read-only-attributes" title="Link para este cabeçalho">¶</a></h5>
<table class="docutils align-default" id="index-35">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Atributo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__globals__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__globals__</span></span><a class="headerlink" href="#function.__globals__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma referência ao <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dicionário</span></code></a> que contém as <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">variáveis globais</span></a> da função – o espaço de nomes global do módulo no qual a função foi definida.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__closure__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__closure__</span></span><a class="headerlink" href="#function.__closure__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">None</span></code> ou uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> de células que contêm ligação para os nomes especificados no atributo <a class="reference internal" href="#codeobject.co_freevars" title="codeobject.co_freevars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code></a> do <a class="reference internal" href="#function.__code__" title="function.__code__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objeto</span> <span class="pre">código</span></code></a> da função.</p>
<p class="translated">Um objeto de célula tem o atributo <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>. Isso pode ser usado para obter o valor da célula, bem como definir o valor.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="special-writable-attributes">
<h5 class="translated"><span class="section-number">3.2.8.1.2. </span>Atributos especiais graváveis<a class="headerlink" href="#special-writable-attributes" title="Link para este cabeçalho">¶</a></h5>
<p class="translated" id="index-36">A maioria desses atributos verifica o tipo do valor atribuído:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Atributo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__doc__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#function.__doc__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">A string de documentação da função, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__name__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#function.__name__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome da função. Veja também: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__name__</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__qualname__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__qualname__</span></span><a class="headerlink" href="#function.__qualname__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">nome qualificado</span></a> da função. Veja também: <a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__qualname__</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.3.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__module__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#function.__module__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome do módulo em que a função foi definida ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__defaults__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__defaults__</span></span><a class="headerlink" href="#function.__defaults__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo valores de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetro</span></a> padrão para aqueles parâmetros que possuem padrões, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se nenhum parâmetro tiver um valor padrão.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__code__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__code__</span></span><a class="headerlink" href="#function.__code__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O <a class="reference internal" href="#code-objects"><span class="std std-ref">objeto código</span></a> que representa o corpo da função compilada.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__dict__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#function.__dict__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O espaço de nomes que provvê atributos de função arbitrários. Veja também: <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__dict__</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__annotations__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#function.__annotations__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dicionário</span></code></a> contendo anotações de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetros</span></a>. As chaves do dicionário são os nomes dos parâmetros e <code class="docutils literal notranslate"><span class="pre">'return'</span></code> para a anotação de retorno, se fornecida. Veja também: <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Boas práticas para anotações</span></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__kwdefaults__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__kwdefaults__</span></span><a class="headerlink" href="#function.__kwdefaults__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dicionário</span></code></a> contendo padrões apenas para <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetros</span></a> somente-nomeados.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__type_params__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#function.__type_params__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">parâmetros de tipo</span></a> de uma <a class="reference internal" href="compound_stmts.html#generic-functions"><span class="std std-ref">função genérica</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.12.</span></p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="translated">Os objetos de função também dão suporte à obtenção e definição de atributos arbitrários, que podem ser usados, por exemplo, para anexar metadados a funções. A notação de ponto de atributo regular é usada para obter e definir tais atributos.</p>
<div class="impl-detail compound">
<p class="translated">A implementação atual do CPython provê apenas atributos de função em funções definidas pelo usuário. Atributos de função em <a class="reference internal" href="#builtin-functions"><span class="std std-ref">funções embutido</span></a> podem ser suportados no futuro.</p>
</div>
<p class="translated">Informações adicionais sobre a definição de uma função podem ser obtidas de seu <a class="reference internal" href="#code-objects"><span class="std std-ref">objeto código</span></a> (acessível através do atributo <a class="reference internal" href="#function.__code__" title="function.__code__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></a>).</p>
</section>
</section>
<section id="instance-methods">
<span id="id2"></span><h4 class="translated"><span class="section-number">3.2.8.2. </span>Métodos de instância<a class="headerlink" href="#instance-methods" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-37">Um objeto método de instância combina uma classe, uma instância de classe e qualquer objeto chamável (normalmente uma função definida pelo usuário).</p>
<p class="translated" id="index-38">Atributos especiais de somente leitura:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__self__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__self__</span></span><a class="headerlink" href="#method.__self__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Refere-se ao objeto instância da classe ao qual o método é <a class="reference internal" href="#method-binding"><span class="std std-ref">vinculado</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__func__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__func__</span></span><a class="headerlink" href="#method.__func__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Refere-se ao <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">objeto função</span></a> original</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__doc__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#method.__doc__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">A documentação do método (igual a <a class="reference internal" href="#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method.__func__.__doc__</span></code></a>). Um <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">string</span></code></a> se a função original tivesse uma docstring, caso contrário <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__name__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#method.__name__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome do método (mesmo que <a class="reference internal" href="#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method.__func__.__name__</span></code></a>)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__module__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#method.__module__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome do módulo em que o método foi definido ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível.</p></td>
</tr>
</tbody>
</table>
<p class="translated">Os métodos também implementam o acesso (mas não a configuração) dos atributos arbitrários da função no <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">objeto função</span></a> subjacente.</p>
<p class="translated">Objetos método definidos pelo usuário podem ser criados ao obter um atributo de uma classe (talvez através de uma instância dessa classe), se esse atributo for um <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">objeto função</span></a> definido pelo usuário ou um objeto <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> .</p>
<p class="translated" id="method-binding">Quando um objeto método de instância é criado recuperando um <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">objeto função</span></a> definido pelo usuário de uma classe por meio de uma de suas instâncias, seu atributo <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> é a instância, e o objeto método é considerado <em>vinculado</em>. O atributo <a class="reference internal" href="#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a> do novo método é o objeto da função original.</p>
<p class="translated">Quando um objeto método de instância é criado obtendo um objeto <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> de uma classe ou instância, seu atributo <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> é a própria classe, e seu atributo <a class="reference internal" href="#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a> é o objeto função subjacente ao método de classe.</p>
<p class="translated">Quando um objeto método de instância é chamado, a função subjacente (<a class="reference internal" href="#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a>) é chamada, inserindo a instância de classe (<a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a>) na frente da lista de argumentos. Por exemplo, quando <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> é uma classe que contém uma definição para uma função <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code>, e <code class="docutils literal notranslate"><span class="pre">x</span></code> é uma instância de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, chamando <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> é equivalente a chamar <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code>.</p>
<p class="translated">Quando um objeto método de instância é derivado de um objeto <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>, a “instância de classe” armazenada em <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> será, na verdade, a própria classe, de modo que chamar <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> ou <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> é equivalente a chamar <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> sendo <code class="docutils literal notranslate"><span class="pre">f</span></code> a função subjacente.</p>
<p class="translated">É importante observar que funções definidas pelo usuário que são atributos de uma instância de classe não são convertidas em métodos vinculados; isso <em>somente</em> acontece quando a função é um atributo da classe.</p>
</section>
<section id="generator-functions">
<h4 class="translated"><span class="section-number">3.2.8.3. </span>Funções geradoras<a class="headerlink" href="#generator-functions" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-39">Uma função ou método que usa a instrução <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> (veja a seção <a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">A instrução yield</span></a>) é chamada de <em class="dfn">função geradora</em>. Tal função, quando chamada, sempre retorna um objeto <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>  que pode ser usado para executar o corpo da função: chamar o método <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> do iterador fará com que a função seja executada até que forneça um valor usando a instrução <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>. Quando a função executa uma instrução <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> ou sai do fim, uma exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> é levantada e o iterador terá alcançado o fim do conjunto de valores a serem retornados.</p>
</section>
<section id="coroutine-functions">
<h4 class="translated"><span class="section-number">3.2.8.4. </span>Funções de corrotina<a class="headerlink" href="#coroutine-functions" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-40">Uma função ou um método que é definida(o) usando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> é chamado de <em class="dfn">função de corrotina</em>. Tal função, quando chamada, retorna um objeto de <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">corrotina</span></a>. Ele pode conter expressões <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, bem como instruções <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> e <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Veja também a seção <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">Objetos corrotina</span></a>.</p>
</section>
<section id="asynchronous-generator-functions">
<h4 class="translated"><span class="section-number">3.2.8.5. </span>Funções geradoras assíncronas<a class="headerlink" href="#asynchronous-generator-functions" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-41">Uma função ou um método que é definida(o) usando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> e que usa a instrução <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> é chamada de <em class="dfn">função geradora assíncrona</em>. Tal função, quando chamada, retorna um objeto <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a> que pode ser usado em uma instrução <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> para executar o corpo da função.</p>
<p class="translated">Chamar o método <a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> do iterador assíncrono retornará um <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardável</span></a> que, quando aguardado, será executado até fornecer um valor usando a expressão <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>. Quando a função executa uma instrução vazia <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> ou chega ao final, uma exceção <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> é levantada e o iterador assíncrono terá alcançado o final do conjunto de valores a serem produzidos.</p>
</section>
<section id="built-in-functions">
<span id="builtin-functions"></span><h4 class="translated"><span class="section-number">3.2.8.6. </span>Funções embutidas<a class="headerlink" href="#built-in-functions" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-42">Um objeto função embutida é um wrapper em torno de uma função C. Exemplos de funções embutidas são <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> e <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> é um módulo embutido padrão). O número e o tipo dos argumentos são determinados pela função C. Atributos especiais de somente leitura:</p>
<ul class="simple">
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> é a string de documentação da função, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se não estiver disponível. Veja <a class="reference internal" href="#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__doc__</span></code></a>.</p></li>
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code> é o nome da função. Veja <a class="reference internal" href="#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__name__</span></code></a>.</p></li>
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é definido para <code class="docutils literal notranslate"><span class="pre">None</span></code> (mas veja o próximo item).</p></li>
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> é o nome do módulo no qual a função foi definida ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se não estiver disponível. Veja <a class="reference internal" href="#function.__module__" title="function.__module__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__module__</span></code></a>.</p></li>
</ul>
</section>
<section id="built-in-methods">
<span id="builtin-methods"></span><h4 class="translated"><span class="section-number">3.2.8.7. </span>Métodos embutidos<a class="headerlink" href="#built-in-methods" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-43">Este é realmente um disfarce diferente de uma função embutida, desta vez contendo um objeto passado para a função C como um argumento extra implícito. Um exemplo de método embutido é <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code>, presumindo que <em>alist</em> é um objeto de lista. Nesse caso, o atributo especial de somente leitura <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> é definido como o objeto denotado por <em>alist</em>. (O atributo tem a mesma semântica de <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">outros</span> <span class="pre">métodos</span> <span class="pre">de</span> <span class="pre">instância</span></code></a>.)</p>
</section>
<section id="classes">
<span id="id3"></span><h4 class="translated"><span class="section-number">3.2.8.8. </span>Classes<a class="headerlink" href="#classes" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Classes são chamáveis. Esses objetos normalmente agem como fábricas para novas instâncias de si mesmos, mas variações são possíveis para tipos de classe que substituem <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>. Os argumentos da chamada são passados para <code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> e, no caso típico, para <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> para inicializar a nova instância.</p>
</section>
<section id="class-instances">
<h4 class="translated"><span class="section-number">3.2.8.9. </span>Instâncias de classe<a class="headerlink" href="#class-instances" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Instâncias de classes arbitrárias podem ser tornados chamáveis definindo um método <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> em sua classe.</p>
</section>
</section>
<section id="modules">
<span id="module-objects"></span><h3 class="translated"><span class="section-number">3.2.9. </span>Módulos<a class="headerlink" href="#modules" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-44">Módulos são uma unidade organizacional básica do código Python, e são criados pelo <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">sistema de importação</span></a> quando invocado pela instrução <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, ou chamando funções como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> e a embutida <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>. Um objeto módulo tem um espaço de nomes implementado por um objeto <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dicionário</span></code></a> (este é o dicionário referenciado pelo atributo <a class="reference internal" href="#function.__globals__" title="function.__globals__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></a> das funções definidas no módulo). As referências de atributos são traduzidas para pesquisas neste dicionário, por exemplo, <code class="docutils literal notranslate"><span class="pre">m.x</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code>. Um objeto módulo não contém o objeto código usado para inicializar o módulo (uma vez que não é necessário depois que a inicialização é concluída).</p>
<p class="translated">A atribuição de atributo atualiza o dicionário de espaço de nomes do módulo, por exemplo, <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<section id="import-related-attributes-on-module-objects">
<span id="import-mod-attrs"></span><span id="index-45"></span><h4 class="translated"><span class="section-number">3.2.9.1. </span>Atributos relacionados à importação em objetos de módulo<a class="headerlink" href="#import-related-attributes-on-module-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Objetos de módulo têm os seguintes atributos que se relacionam ao <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">sistema de importação</span></a>. Quando um módulo é criado usando o maquinário associado ao sistema de importação, esses atributos são preenchidos com base no <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> do módulo, antes que o <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">carregador</span></a> execute e carregue o módulo.</p>
<p class="translated">Para criar um módulo dinamicamente em vez de usar o sistema de importação, é recomendado usar <a class="reference internal" href="../library/importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_from_spec()</span></code></a>, que definirá os vários atributos controlados pela importação para valores apropriados. Também é possível usar o construtor <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> para criar módulos diretamente, mas essa técnica é mais propensa a erros, pois a maioria dos atributos deve ser definida manualmente no objeto do módulo após ele ter sido criado ao usar essa abordagem.</p>
<div class="admonition caution">
<p class="admonition-title">Cuidado</p>
<p class="translated">Com exceção de <a class="reference internal" href="#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, é <strong>fortemente</strong> recomendado que você confie no <a class="reference internal" href="#module.__spec__" title="module.__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a> e seus atributos em vez de qualquer um dos outros atributos individuais listados nesta subseção. Observe que atualizar um atributo em <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code> não atualizará o atributo correspondente no próprio módulo:</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">typing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;typing&#39;, &#39;typing&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;spelling&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;typing&#39;, &#39;spelling&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;keyboard_smashing&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;keyboard_smashing&#39;, &#39;spelling&#39;)</span>
</pre></div>
</div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="module.__name__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#module.__name__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">O nome usado para identificar exclusivamente o módulo no sistema de importação. Para um módulo executado diretamente, isso será definido como <code class="docutils literal notranslate"><span class="pre">&quot;__main__&quot;</span></code>.</p>
<p class="translated">Este atributo deve ser definido como o nome totalmente qualificado do módulo. Espera-se que ele corresponda ao valor de <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.name" title="importlib.machinery.ModuleSpec.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.name</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__spec__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__spec__</span></span><a class="headerlink" href="#module.__spec__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Um registro do estado relacionado ao sistema de importação do módulo.</p>
<p class="translated">Define com <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">spec</span> <span class="pre">de</span> <span class="pre">módulo</span></code></a> que foi usado ao importar o módulo. Veja <a class="reference internal" href="import.html#module-specs"><span class="std std-ref">Especificações de módulo</span></a> para mais detalhes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.4.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__package__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__package__</span></span><a class="headerlink" href="#module.__package__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">O <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">pacote</span></a> ao qual um módulo pertence.</p>
<p class="translated">Se o módulo for de nível superior (ou seja, não fizer parte de nenhum pacote específico), o atributo deve ser definido como <code class="docutils literal notranslate"><span class="pre">''</span></code> (a string vazia). Caso contrário, deve ser definido como o nome do pacote do módulo (que pode ser igual a <a class="reference internal" href="#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__name__</span></code></a> se o módulo em si for um pacote). Veja <span class="target" id="index-130"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> para mais detalhes.</p>
<p class="translated">Este atributo é usado em vez de <a class="reference internal" href="#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> para calcular importações relativas explícitas para módulos principais. O padrão é <code class="docutils literal notranslate"><span class="pre">None</span></code> para módulos criados dinamicamente usando o construtor <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>; use <a class="reference internal" href="../library/importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_from_spec()</span></code></a> em vez disso para garantir que o atributo seja definido como <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p class="translated">É <strong>fortemente</strong> recomendado que você use <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.parent</span></code></a> em vez de <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__package__</span></code>. <a class="reference internal" href="#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> agora só é usado como fallback se <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code> não estiver definido, e esse caminho de fallback está descontinuado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Este atributo agora presume o padrão <code class="docutils literal notranslate"><span class="pre">None</span></code> para módulos criados dinamicamente usando o construtor <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Anteriormente, o atributo era opcional.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.6: </span>Espera-se que o valor de <code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> seja o mesmo que <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code></a>. <a class="reference internal" href="#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> agora é usado apenas como fallback durante a resolução de importação se <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code> não estiver definido.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.10: </span><a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> é levantada se uma resolução de importação retorna para <code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> em vez de <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span>Levanta <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> em vez de <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> ao retornar para <code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> durante a resolução de importação.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> deixará de ser definido ou levado em consideração pelo sistema de importação ou biblioteca padrão.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__loader__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__loader__</span></span><a class="headerlink" href="#module.__loader__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">O objeto <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">carregador</span></a> que o maquinário de importação usou para carregar o módulo.</p>
<p class="translated">Este atributo é útil principalmente para introspecção, mas pode ser usado para funcionalidades adicionais específicas do carregador, por exemplo, para obter dados associados a um carregador.</p>
<p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code> assume como padrão <code class="docutils literal notranslate"><span class="pre">None</span></code> para módulos criados dinamicamente usando o construtor <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>; use <a class="reference internal" href="../library/importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_from_spec()</span></code></a> para garantir que o atributo seja definido como um objeto <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">carregador</span></a>.</p>
<p class="translated">É <strong>fortemetne</strong> recomendado que você use <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.loader" title="importlib.machinery.ModuleSpec.loader"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.loader</span></code></a> em vez de <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__loader__</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>Este atributo agora presume o padrão <code class="docutils literal notranslate"><span class="pre">None</span></code> para módulos criados dinamicamente usando o construtor <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Anteriormente, o atributo era opcional.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.16: </span>A definição <code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code> em um módulo enquanto falha na definição de <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.loader</span></code> está descontinuado. No Python 3.16, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code> deixará de ser definido ou levado em consideração pelo sistema de importação ou pela biblioteca padrão.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__path__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__path__</span></span><a class="headerlink" href="#module.__path__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Uma <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequência</span></a> (possivelmente vazia) de strings enumerando os locais onde os submódulos do pacote serão encontrados. Módulos que não sejam de pacote não devem ter um atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>. Veja <a class="reference internal" href="import.html#package-path-rules"><span class="std std-ref">Atributo __path__ dos módulos</span></a> para mais detalhes.</p>
<p class="translated">É <strong>fortemente</strong> recomendado que você use <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.submodule_search_locations" title="importlib.machinery.ModuleSpec.submodule_search_locations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.submodule_search_locations</span></code></a> em vez de <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__path__</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__file__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__file__</span></span><a class="headerlink" href="#module.__file__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__cached__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__cached__</span></span><a class="headerlink" href="#module.__cached__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> e <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> são atributos opcionais que podem ou não ser definidos. Ambos os atributos devem ser um <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> quando estiverem disponíveis.</p>
<p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> indica o nome do caminho do arquivo do qual o módulo foi carregado (se carregado de um arquivo) ou o nome do caminho do arquivo da biblioteca compartilhada para módulos de extensão carregados dinamicamente de uma biblioteca compartilhada. Pode estar faltando para certos tipos de módulos, como módulos C que estão estaticamente vinculados ao interpretador, e o <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">sistema de importação</span></a> pode optar por deixá-lo sem definição se não tiver significado semântico (por exemplo, um módulo carregado de um banco de dados).</p>
<p class="translated">Se <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> estiver definido então o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> também pode ser definido, que é o caminho para qualquer versão compilada do código (por exemplo, um arquivo compilado por byte). O arquivo não precisa existir para configurar esse atributo; o caminho pode simplesmente apontar para onde o arquivo compilado existiria (veja <span class="target" id="index-131"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>).</p>
<p class="translated">Observe que <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> pode ser definido mesmo se <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> não estiver definido. No entanto, esse cenário é bastante atípico. Em última análise, o <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">carregador</span></a> é o que faz uso do spec de módulo fornecido pelo <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">localizador</span></a> (do qual <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> e <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> são derivados). Portanto, se um carregador puder carregar a partir de um módulo em cache, mas não carregar a partir de um arquivo, esse cenário atípico poderá ser apropriado.</p>
<p class="translated">É <strong>fortemente</strong> recomendado que você use <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.cached" title="importlib.machinery.ModuleSpec.cached"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.cached</span></code></a> em vez de <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__cached__</span></code>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>A definição <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> em um módulo enquanto falha na definição de <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.cached</span></code> está descontinuado. No Python 3.15, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> deixará de ser definido ou levado em consideração pelo sistema de importação ou pela biblioteca padrão.</p>
</div>
</dd></dl>

</section>
<section id="other-writable-attributes-on-module-objects">
<h4 class="translated"><span class="section-number">3.2.9.2. </span>Outros atributos graváveis em objetos de módulo<a class="headerlink" href="#other-writable-attributes-on-module-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Além dos atributos relacionados à importação listados acima, os objetos de módulo também têm os seguintes atributos graváveis:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="module.__doc__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#module.__doc__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">A string de documentação do módulo, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indisponível. Veja também: <a class="reference internal" href="../library/stdtypes.html#definition.__doc__" title="definition.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__doc__</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__annotations__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#module.__annotations__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Um dicionário contendo <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">anotações de variável</span></a>  coletadas durante a execução do corpo do módulo. Para as melhores práticas sobre como trabalhar com <a class="reference internal" href="#module.__annotations__" title="module.__annotations__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></a>, por favor veja <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Boas práticas para anotações</span></a>.</p>
</dd></dl>

</section>
<section id="module-dictionaries">
<h4 class="translated"><span class="section-number">3.2.9.3. </span>Dicionários do módulo<a class="headerlink" href="#module-dictionaries" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Os objetos de módulo também têm o seguinte atributo especial somente leitura:</p>
<dl class="py attribute" id="index-48">
<dt class="sig sig-object py" id="module.__dict__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#module.__dict__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">O espaço de nomes do módulo como um objeto dicionário. Exclusivamente entre os atributos listados aqui, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code> não pode ser acessado como uma variável global de dentro de um módulo; ele só pode ser acessado como um atributo em objetos de módulo.</p>
<div class="impl-detail compound">
<p class="translated">Por causa da maneira como CPython limpa dicionários de módulos, o dicionário do módulo será limpo quando o módulo sair do escopo, mesmo se o dicionário ainda tiver referências ativas. Para evitar isso, copie o dicionário ou mantenha o módulo por perto enquanto usa seu dicionário diretamente.</p>
</div>
</dd></dl>

</section>
</section>
<section id="custom-classes">
<span id="class-attrs-and-methods"></span><h3 class="translated"><span class="section-number">3.2.10. </span>Classes personalizadas<a class="headerlink" href="#custom-classes" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Tipos de classe personalizados são tipicamente criados por definições de classe (veja a seção <a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">Definições de classe</span></a>). Uma classe possui um espaço de nomes implementado por um objeto dicionário. As referências de atributos de classe são traduzidas para pesquisas neste dicionário, por exemplo, <code class="docutils literal notranslate"><span class="pre">C.x</span></code> é traduzido para <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> (embora haja uma série de ganchos que permitem outros meios de localizar atributos). Quando o nome do atributo não é encontrado lá, a pesquisa do atributo continua nas classes base. Essa pesquisa das classes base usa a ordem de resolução de métodos C3, que se comporta corretamente mesmo na presença de estruturas de herança em losango, onde há vários caminhos de herança que levam de volta a um ancestral comum. Detalhes adicionais sobre a ordem de resolução de métodos (MRO) C3 usado pelo Python podem ser encontrados em <a class="reference internal" href="../howto/mro.html#python-2-3-mro"><span class="std std-ref">A Ordem de Resolução de Métodos do Python 2.3</span></a>.</p>
<p class="translated" id="index-49">Quando uma referência de atributo de classe (para uma classe <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, digamos) produziria um objeto método de classe, ele é transformado em um objeto método de instância cujo atributo <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> é <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>. Quando produziria um objeto <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">staticmethod</span></code></a>, ele é transformado no objeto encapsulado pelo objeto método estático. Veja a seção <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando descritores</span></a> para outra maneira em que os atributos recuperados de uma classe podem diferir daqueles realmente contidos em seu <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.</p>
<p class="translated" id="index-50">As atribuições de atributos de classe atualizam o dicionário da classe, nunca o dicionário de uma classe base.</p>
<p class="translated" id="index-51">Um objeto classe pode ser chamado (veja acima) para produzir uma instância de classe (veja abaixo).</p>
<section id="special-attributes">
<h4 class="translated"><span class="section-number">3.2.10.1. </span>Atributos especiais<a class="headerlink" href="#special-attributes" title="Link para este cabeçalho">¶</a></h4>
<table class="docutils align-default" id="index-52">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Atributo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__name__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#type.__name__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome da classe. Veja também: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__name__</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__qualname__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__qualname__</span></span><a class="headerlink" href="#type.__qualname__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">nome qualificado</span></a> da classe. Veja também: <a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__qualname__</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__module__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#type.__module__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome do módulo no qual a classe foi definida.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__dict__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#type.__dict__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um <a class="reference internal" href="../library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">proxy</span> <span class="pre">de</span> <span class="pre">mapeamento</span></code></a> fornecendo uma visão somente leitura do espaço de nomes da classe. Veja também: <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">atributos</span> <span class="pre">__dict__</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__bases__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__bases__</span></span><a class="headerlink" href="#type.__bases__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo as bases da classe. Na maioria dos casos, para uma classe definida como <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">X(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code>, <code class="docutils literal notranslate"><span class="pre">X.__bases__</span></code> será exatamente igual a <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__doc__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#type.__doc__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">A string de documentação da classe, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se não estiver definida. Não herdado por subclasses.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__annotations__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#type.__annotations__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um dicionário contendo <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">anotações de variável</span></a> coletadas durante a execução do corpo da classe. Para melhores práticas sobre como trabalhar com <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, por favor veja <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Boas práticas para anotações</span></a>.</p>
<div class="admonition caution">
<p class="admonition-title">Cuidado</p>
<p class="translated">Acessar o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> de um objeto classe diretamente pode produzir resultados incorretos na presença de metaclasses. Além disso, o atributo pode não existir para algumas classes. Use <a class="reference internal" href="../library/inspect.html#inspect.get_annotations" title="inspect.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.get_annotations()</span></code></a> para recuperar anotações de classe com segurança.</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__type_params__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#type.__type_params__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">parâmetros de tipo</span></a> de uma <a class="reference internal" href="compound_stmts.html#generic-classes"><span class="std std-ref">classe genérica</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.12.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__static_attributes__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__static_attributes__</span></span><a class="headerlink" href="#type.__static_attributes__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo nomes de atributos dessa classe que são atribuídos por meio de <code class="docutils literal notranslate"><span class="pre">self.X</span></code> de qualquer função em seu corpo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.13.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__firstlineno__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__firstlineno__</span></span><a class="headerlink" href="#type.__firstlineno__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número da linha da primeira linha da definição de classe, incluindo decoradores. Definir o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> remove o item <code class="xref py py-attr docutils literal notranslate"><span class="pre">__firstlineno__</span></code> do dicionário do tipo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.13.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__mro__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__mro__</span></span><a class="headerlink" href="#type.__mro__" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> de classes que são consideradas ao procurar por classes bases durante resolução de métodos.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="special-methods">
<h4 class="translated"><span class="section-number">3.2.10.2. </span>Métodos especiais<a class="headerlink" href="#special-methods" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Além dos atributos especiais descritos acima, todas as classes Python também têm os dois métodos a seguir disponíveis:</p>
<dl class="py method">
<dt class="sig sig-object py" id="type.mro">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">mro</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#type.mro" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Este método pode ser substituído por uma metaclasse para personalizar a ordem de resolução de métodos para suas instâncias. Ele é chamado na instanciação da classe, e o seu resultado é armazenado em <a class="reference internal" href="#type.__mro__" title="type.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="type.__subclasses__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__subclasses__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#type.__subclasses__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Cada classe mantém uma lista de referências fracas para suas subclasses imediatas. Este método retorna uma lista de todas essas referências ainda vivas. A lista está na ordem que são definidas. Exemplo:</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;B&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="id4">
<h3 class="translated"><span class="section-number">3.2.11. </span>Instâncias de classe<a class="headerlink" href="#id4" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-53">Uma instância de classe é criada chamando um objeto classe (veja acima). Uma instância de classe tem um espaço de nomes implementado como um dicionário que é o primeiro lugar no qual as referências de atributos são pesquisadas. Quando um atributo não é encontrado lá, e a classe da instância possui um atributo com esse nome, a pesquisa continua com os atributos da classe. Se for encontrado um atributo de classe que seja um objeto função definido pelo usuário, ele é transformado em um objeto método de instância cujo atributo <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> é a instância. Métodos estáticos e métodos de classe também são transformados; veja acima em “Classes”. Veja a seção <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando descritores</span></a> para outra maneira em que os atributos de uma classe recuperados através de suas instâncias podem diferir dos objetos realmente armazenados no <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> da classe. Se nenhum atributo de classe for encontrado, e a classe do objeto tiver um método <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, este é chamado para satisfazer a pesquisa.</p>
<p class="translated" id="index-54">As atribuições e exclusões de atributos atualizam o dicionário da instância, nunca o dicionário de uma classe. Se a classe tem um método <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> ou <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a>, ele é chamado ao invés de atualizar o dicionário da instância diretamente.</p>
<p class="translated" id="index-55">As instâncias de classe podem fingir ser números, sequências ou mapeamentos se tiverem métodos com certos nomes especiais. Veja a seção <a class="reference internal" href="#specialnames"><span class="std std-ref">Nomes de métodos especiais</span></a>.</p>
<section id="id5">
<h4 class="translated"><span class="section-number">3.2.11.1. </span>Atributos especiais<a class="headerlink" href="#id5" title="Link para este cabeçalho">¶</a></h4>
<dl class="py attribute" id="index-56">
<dt class="sig sig-object py" id="object.__class__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__class__</span></span><a class="headerlink" href="#object.__class__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">A classe à qual pertence uma instância de classe.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="object.__dict__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#object.__dict__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Um dicionário ou outro objeto de mapeamento usado para armazenar atributos (graváveis) de um objeto. Nem todas as instâncias têm um atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code>; veja a seção sobre <a class="reference internal" href="#slots"><span class="std std-ref">__slots__</span></a> para mais detalhes.</p>
</dd></dl>

</section>
</section>
<section id="i-o-objects-also-known-as-file-objects">
<h3 class="translated"><span class="section-number">3.2.12. </span>Objetos de E/S (também conhecidos como objetos arquivo)<a class="headerlink" href="#i-o-objects-also-known-as-file-objects" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-57">O <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto arquivo</span></a> representa um arquivo aberto. Vários atalhos estão disponíveis para criar objetos arquivos: a função embutida <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, e também <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> e o método <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> de objetos soquete (e talvez por outras funções ou métodos fornecidos por módulos de extensão).</p>
<p class="translated">Os objetos <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> e <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> são inicializados para objetos arquivo que correspondem aos fluxos de entrada, saída e erro padrão do interpretador; eles são todos abertos em modo texto e, portanto, seguem a interface definida pela classe abstrata <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>.</p>
</section>
<section id="internal-types">
<h3 class="translated"><span class="section-number">3.2.13. </span>Tipos internos<a class="headerlink" href="#internal-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-58">Alguns tipos usados internamente pelo interpretador são expostos ao usuário. Suas definições podem mudar com versões futuras do interpretador, mas são mencionadas aqui para fins de integridade.</p>
<section id="code-objects">
<span id="id6"></span><h4 class="translated"><span class="section-number">3.2.13.1. </span>Objetos código<a class="headerlink" href="#code-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-59">Objetos código representam código Python executável <em>compilados em bytes</em> ou <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>. A diferença entre um objeto código e um objeto função é que o objeto função contém uma referência explícita aos globais da função (o módulo no qual foi definida), enquanto um objeto código não contém nenhum contexto; também os valores de argumento padrão são armazenados no objeto função, não no objeto código (porque eles representam os valores calculados em tempo de execução). Ao contrário dos objetos função, os objetos código são imutáveis e não contêm referências (direta ou indiretamente) a objetos mutáveis.</p>
<section id="index-60">
<span id="id7"></span><h5 class="translated"><span class="section-number">3.2.13.1.1. </span>Atributos especiais de somente leitura<a class="headerlink" href="#index-60" title="Link para este cabeçalho">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_name">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_name</span></span><a class="headerlink" href="#codeobject.co_name" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome da função</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_qualname">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_qualname</span></span><a class="headerlink" href="#codeobject.co_qualname" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome completo da função</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.11.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_argcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_argcount</span></span><a class="headerlink" href="#codeobject.co_argcount" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número total de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetros</span></a> posicionais (incluindo parâmetros somente-posicionais e parâmetros com valores padrão) que a função possui</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_posonlyargcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_posonlyargcount</span></span><a class="headerlink" href="#codeobject.co_posonlyargcount" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetros</span></a> somente-posicionais (incluindo argumentos com valores padrão) que a função possui</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_kwonlyargcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_kwonlyargcount</span></span><a class="headerlink" href="#codeobject.co_kwonlyargcount" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetros</span></a> somente-nomeados (incluindo argumentos com valores padrão) que a função possui</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_nlocals">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_nlocals</span></span><a class="headerlink" href="#codeobject.co_nlocals" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número de <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">variáveis locais</span></a> usadas pela função (incluindo parâmetros)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_varnames">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_varnames</span></span><a class="headerlink" href="#codeobject.co_varnames" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os nomes das variáveis locais na função (começando com os nomes dos parâmetros)</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_cellvars">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_cellvars</span></span><a class="headerlink" href="#codeobject.co_cellvars" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os nomes de <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">variáveis locais</span></a> que são referenciadas a partir de pelo menos um <a class="reference internal" href="../glossary.html#term-nested-scope"><span class="xref std std-term">escopo aninhado</span></a> de dentro da função</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_freevars">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_freevars</span></span><a class="headerlink" href="#codeobject.co_freevars" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os nomes de <a class="reference internal" href="../glossary.html#term-closure-variable"><span class="xref std std-term">variáveis livres (de clausura)</span></a> que um <a class="reference internal" href="../glossary.html#term-nested-scope"><span class="xref std std-term">escopo aninhado</span></a> referencia em um escopo externo. Veja também <a class="reference internal" href="#function.__closure__" title="function.__closure__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__closure__</span></code></a>.</p>
<p class="translated">Observação: referências a nomes globais e embutidos <em>não</em> estão incluídas.</p>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_code">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_code</span></span><a class="headerlink" href="#codeobject.co_code" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma string representando a sequência de instruções <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> na função</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_consts">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_consts</span></span><a class="headerlink" href="#codeobject.co_consts" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os literais usados pelo <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> na função</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_names">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_names</span></span><a class="headerlink" href="#codeobject.co_names" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os nomes usados pelo <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> na função</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_filename">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_filename</span></span><a class="headerlink" href="#codeobject.co_filename" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O nome do arquivo do qual o código foi compilado</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_firstlineno">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_firstlineno</span></span><a class="headerlink" href="#codeobject.co_firstlineno" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número da linha da primeira linha da função</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_lnotab">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_lnotab</span></span><a class="headerlink" href="#codeobject.co_lnotab" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Uma string que codifica o mapeamento de <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> compensa para números de linha. Para obter detalhes, consulte o código-fonte do interpretador.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Descontinuado desde a versão 3.12: </span>Este atributo de objetos código está descontinuado e pode ser removido no Python 3.15.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_stacksize">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_stacksize</span></span><a class="headerlink" href="#codeobject.co_stacksize" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O tamanho de pilha necessário do objeto código</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_flags">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_flags</span></span><a class="headerlink" href="#codeobject.co_flags" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Um número <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">inteiro</span></code></a> codificando uma série de sinalizadores para o interpretador.</p></td>
</tr>
</tbody>
</table>
<p class="translated" id="index-61">Os seguintes bits sinalizadores são definidos para <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a>: o bit <code class="docutils literal notranslate"><span class="pre">0x04</span></code> é definido se a função usa a sintaxe <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> para aceitar um número arbitrário de argumentos posicionais; o bit <code class="docutils literal notranslate"><span class="pre">0x08</span></code> é definido se a função usa a sintaxe <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> para aceitar argumentos nomeados arbitrários; o bit <code class="docutils literal notranslate"><span class="pre">0x20</span></code> é definido se a função for um gerador. Veja <a class="reference internal" href="../library/inspect.html#inspect-module-co-flags"><span class="std std-ref">Code Objects Bit Flags</span></a> para detalhes na semântica de cada sinalizadores que podem estar presentes.</p>
<p class="translated">Declarações de recursos futuros (por exemplo, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) também usam bits em <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a> para indicar se um objeto código foi compilado com um recurso específico habilitado. Veja <a class="reference internal" href="../library/__future__.html#future__._Feature.compiler_flag" title="__future__._Feature.compiler_flag"><code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code></a>.</p>
<p class="translated">Outros bits em <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a> são reservados para uso interno.</p>
<p class="translated" id="index-62">Se um objeto código representa uma função, o primeiro item em <a class="reference internal" href="#codeobject.co_consts" title="codeobject.co_consts"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code></a> é a string de documentação da função, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se indefinido.</p>
</section>
<section id="methods-on-code-objects">
<h5 class="translated"><span class="section-number">3.2.13.1.2. </span>Métodos de objetos código<a class="headerlink" href="#methods-on-code-objects" title="Link para este cabeçalho">¶</a></h5>
<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_positions">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_positions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.co_positions" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna um iterável das posições no código-fonte de cada instrução <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> no objeto código.</p>
<p class="translated">O iterador retorna <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s contendo <code class="docutils literal notranslate"><span class="pre">(start_line,</span> <span class="pre">end_line,</span> <span class="pre">start_column,</span> <span class="pre">end_column)</span></code>. A <em>i-nésima</em> tupla corresponde à posição do código-fonte que compilou para a <em>i-nésima</em> unidade de código. As informações da coluna são deslocamentos de bytes utf-8 indexados em 0 na linha de código fornecida.</p>
<p class="translated">A informação posicional pode estar ausente. Veja uma lista não-exaustiva de casos onde isso pode acontecer:</p>
<ul class="simple">
<li><p class="translated">Executando o interpretador com <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a>.</p></li>
<li><p class="translated">Carregando um arquivo pyc compilado com <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a>.</p></li>
<li><p class="translated">Tuplas posicionais correspondendo a instruções artificiais.</p></li>
<li><p class="translated">Números de linha e coluna que não podem ser representados devido a limitações específicas de implementação.</p></li>
</ul>
<p class="translated">Quando isso ocorre, alguns ou todos elementos da tupla podem ser <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.11.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Esse recurso requer o armazenamento de posições de coluna no objeto código, o que pode resultar em um pequeno aumento no uso de memória do interpretador e no uso de disco para arquivos Python compilados. Para evitar armazenar as informações extras e/ou desativar a exibição das informações extras de rastreamento, use a opção de linha de comando <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code>  <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> ou a variável de ambiente <span class="target" id="index-132"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNODEBUGRANGES"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNODEBUGRANGES</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_lines">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_lines</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.co_lines" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna um iterador que produz informações sobre intervalos sucessivos de <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>s. Cada item gerado é uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> de <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end,</span> <span class="pre">lineno)</span></code>:</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">start</span></code> (um <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) representa o deslocamento (inclusivo) do início do intervalo <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">end</span></code> (um <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) representa o deslocamento (exclusivo) do fim do intervalo <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">lineno</span></code> é um <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> representando o número da linha do intervalo do <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se os bytecodes no intervalo fornecido não tiverem número de linha</p></li>
</ul>
<p class="translated">Os itens gerados terão as seguintes propriedades:</p>
<ul class="simple">
<li><p class="translated">O primeiro intervalo gerado terá um <code class="docutils literal notranslate"><span class="pre">start</span></code> de 0.</p></li>
<li><p class="translated">Os intervalos <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end)</span></code> serão não decrescentes e consecutivos. Ou seja, para qualquer par de <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s, o <code class="docutils literal notranslate"><span class="pre">start</span></code> do segundo será igual ao <code class="docutils literal notranslate"><span class="pre">end</span></code> do primeiro.</p></li>
<li><p class="translated">Nenhum intervalo será inverso: <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">&gt;=</span> <span class="pre">start</span></code> para todos os trios.</p></li>
<li><p class="translated">A última <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> gerada terá <code class="docutils literal notranslate"><span class="pre">end</span></code> igual ao tamanho do <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>.</p></li>
</ul>
<p class="translated">Intervalos de largura zero, onde <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">==</span> <span class="pre">end</span></code>, são permitidos. Intervalos de largura zero são usados para linhas que estão presentes no código-fonte, mas foram eliminadas pelo compilador de <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-133"></span><a class="pep reference external" href="https://peps.python.org/pep-0626/"><strong>PEP 626</strong></a> - Números de linha precisos para depuração e outras ferramentas.</dt><dd><p class="translated">A PEP que introduziu o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">co_lines()</span></code>.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codeobject.replace">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.replace" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna uma cópia do objeto de código com novos valores para os campos especificados.</p>
<p class="translated">Objetos de código também são suportados pela função genérica <a class="reference internal" href="../library/copy.html#copy.replace" title="copy.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.replace()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.8.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="frame-objects">
<span id="id8"></span><h4 class="translated"><span class="section-number">3.2.13.2. </span>Objetos quadro<a class="headerlink" href="#frame-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-65">Objetos quadro representam quadros de execução. Eles podem ocorrer em <a class="reference internal" href="#traceback-objects"><span class="std std-ref">objetos traceback</span></a> e também são passados para funções de rastreamento registradas.</p>
<section id="index-66">
<span id="id9"></span><h5 class="translated"><span class="section-number">3.2.13.2.1. </span>Atributos especiais de somente leitura<a class="headerlink" href="#index-66" title="Link para este cabeçalho">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_back">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_back</span></span><a class="headerlink" href="#frame.f_back" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Aponta para o quadro de pilha anterior (em direção ao chamador), ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se este for o quadro de pilha mais abaixo.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_code">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_code</span></span><a class="headerlink" href="#frame.f_code" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O <a class="reference internal" href="#code-objects"><span class="std std-ref">objeto código</span></a> sendo executado neste quadro. Acessar este atributo levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> com os argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_locals">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_locals</span></span><a class="headerlink" href="#frame.f_locals" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O mapeamento usado pelo quadro para procurar <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">variáveis locais</span></a>. Se o quadro se referir a um <a class="reference internal" href="../glossary.html#term-optimized-scope"><span class="xref std std-term">escopo otimizado</span></a>, isso pode retornar um objeto proxy write-through.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.13: </span>Retorna um proxy para escopos otimizados.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_globals">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_globals</span></span><a class="headerlink" href="#frame.f_globals" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O dicionário usado pelo quadro para procurar <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">variáveis globais</span></a></p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_builtins">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_builtins</span></span><a class="headerlink" href="#frame.f_builtins" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O dicionário usado pelo quadro para procurar <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">nomes embutidos (intrínsecos)</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_lasti">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_lasti</span></span><a class="headerlink" href="#frame.f_lasti" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">A “instrução precisa” do objeto quadro (este é um índice na string <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> do <a class="reference internal" href="#code-objects"><span class="std std-ref">objeto código</span></a>)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="index-67">
<span id="id10"></span><h5 class="translated"><span class="section-number">3.2.13.2.2. </span>Atributos especiais graváveis<a class="headerlink" href="#index-67" title="Link para este cabeçalho">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace</span></span><a class="headerlink" href="#frame.f_trace" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Se não for <code class="docutils literal notranslate"><span class="pre">None</span></code>, esta é uma função chamada para vários eventos durante a execução do código (isso é usado por depuradores). Normalmente, um evento é disparado para cada nova linha de origem (veja <a class="reference internal" href="#frame.f_trace_lines" title="frame.f_trace_lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code></a>).</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace_lines">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace_lines</span></span><a class="headerlink" href="#frame.f_trace_lines" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Defina este atributo como <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> para desabilitar o acionamento de um evento de rastreamento para cada linha de origem.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace_opcodes">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace_opcodes</span></span><a class="headerlink" href="#frame.f_trace_opcodes" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Defina este atributo para <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> para permitir que eventos por opcode sejam solicitados. Observe que isso pode levar a um comportamento indefinido do interpretador se as exceções levantadas pela função de rastreamento escaparem para a função que está sendo rastreada.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_lineno">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_lineno</span></span><a class="headerlink" href="#frame.f_lineno" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">O número da linha atual do quadro – escrever para isso de dentro de uma função de rastreamento faz saltar para a linha dada (apenas para o quadro mais abaixo). Um depurador pode implementar um comando Jump (também conhecido como Set Next Statement) escrevendo para esse atributo.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="frame-object-methods">
<h5 class="translated"><span class="section-number">3.2.13.2.3. </span>Métodos de objetos quadro<a class="headerlink" href="#frame-object-methods" title="Link para este cabeçalho">¶</a></h5>
<p class="translated">Objetos quadro têm suporte a um método:</p>
<dl class="py method">
<dt class="sig sig-object py" id="frame.clear">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Este método limpa todas as referências a <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">variáveis locais</span></a> mantidas pelo quadro. Além disso, se o quadro pertencer a um <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">gerador</span></a>, o gerador é finalizado. Isso ajuda a quebrar os ciclos de referência que envolvem objetos quadro (por exemplo, ao capturar uma <a class="reference internal" href="../library/exceptions.html#bltin-exceptions"><span class="std std-ref">exceção</span></a> e armazenar seu <a class="reference internal" href="#traceback-objects"><span class="std std-ref">traceback</span></a> para uso posterior).</p>
<p class="translated"><a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> é levantada se o quadro estiver em execução ou suspenso.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.13: </span>Tentar limpar um quadro suspenso levanta <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> (como sempre foi o caso para quadros em execução).</p>
</div>
</dd></dl>

</section>
</section>
<section id="traceback-objects">
<span id="id11"></span><h4 class="translated"><span class="section-number">3.2.13.3. </span>Objetos traceback<a class="headerlink" href="#traceback-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-68">Objetos traceback representam o stack trace (situação da pilha de execução) de uma <a class="reference internal" href="../tutorial/errors.html#tut-errors"><span class="std std-ref">exceção</span></a>. Um objeto traceback é criado implicitamente quando ocorre uma exceção e também pode ser criado explicitamente chamando <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Objetos traceback agora podem ser instanciados explicitamente a partir de código Python.</p>
</div>
<p class="translated">Para tracebacks criados implicitamente, quando a busca por um manipulador de exceção desenrola a pilha de execução, em cada nível desenrolado um objeto traceback é inserido na frente do traceback atual. Quando um manipulador de exceção é inserido, o stack trace é disponibilizado para o programa. (Veja a seção <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">A instrução try</span></a>.) É acessível como o terceiro item da tupla retornada por <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>, e como o atributo <a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> da exceção capturada.</p>
<p class="translated">Quando o programa não contém um manipulador adequado, o stack trace é escrito (formatado de maneira adequada) no fluxo de erro padrão; se o interpretador for interativo, ele também é disponibilizado ao usuário como <a class="reference internal" href="../library/sys.html#sys.last_traceback" title="sys.last_traceback"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.last_traceback</span></code></a>.</p>
<p class="translated">Para tracebacks criados explicitamente, cabe ao criador do traceback determinar como os atributos <a class="reference internal" href="#traceback.tb_next" title="traceback.tb_next"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code></a> devem ser vinculados para formar um stack trace completo.</p>
<p class="translated" id="index-69">Atributos especiais de somente leitura:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_frame">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_frame</span></span><a class="headerlink" href="#traceback.tb_frame" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Aponta para o <a class="reference internal" href="#frame-objects"><span class="std std-ref">quadro</span></a> de execução do nível atual.</p>
<p class="translated">Acessar este atributo levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> com os argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;tb_frame&quot;</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_lineno">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_lineno</span></span><a class="headerlink" href="#traceback.tb_lineno" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Fornece o número da linha onde ocorreu a exceção</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_lasti">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_lasti</span></span><a class="headerlink" href="#traceback.tb_lasti" title="Link para esta definição">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">Indica a “instrução precisa”.</p></td>
</tr>
</tbody>
</table>
<p class="translated">O número da linha e a última instrução no traceback podem diferir do número da linha do seu <a class="reference internal" href="#frame-objects"><span class="std std-ref">objeto quadro</span></a> se a exceção ocorreu em uma instrução <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> sem cláusula except correspondente ou com uma cláusula <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>.</p>
<dl class="py attribute" id="index-70">
<dt class="sig sig-object py" id="traceback.tb_next">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_next</span></span><a class="headerlink" href="#traceback.tb_next" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">O atributo especial de escrita <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> é o próximo nível no stack trace (em direção ao quadro onde a exceção ocorreu), ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se não houver próximo nível.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Este atributo agora é gravável</p>
</div>
</dd></dl>

</section>
<section id="slice-objects">
<h4 class="translated"><span class="section-number">3.2.13.4. </span>Objetos slice<a class="headerlink" href="#slice-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-71">Objetos slice são usados para representar fatias para métodos <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Eles também são criados pela função embutida <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a>.</p>
<p class="translated" id="index-72">Atributos especiais de somente leitura: <a class="reference internal" href="../library/functions.html#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a> é o limite inferior; <a class="reference internal" href="../library/functions.html#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> é o limite superior; <a class="reference internal" href="../library/functions.html#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> é o valor da diferença entre elementos subjacentes; cada um desses atributos é <code class="docutils literal notranslate"><span class="pre">None</span></code> se omitido. Esses atributos podem ter qualquer tipo.</p>
<p class="translated">Objetos slice têm suporte a um método:</p>
<dl class="py method">
<dt class="sig sig-object py" id="slice.indices">
<span class="sig-prename descclassname"><span class="pre">slice.</span></span><span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Este método recebe um único argumento inteiro <em>length</em> e calcula informações sobre a fatia que o objeto slice descreveria se aplicado a uma sequência de itens de <em>length</em>. Ele retorna uma tupla de três inteiros; respectivamente, estes são os índices <em>start</em> e <em>stop</em> e o <em>step</em> ou comprimento de avanços da fatia. Índices ausentes ou fora dos limites são tratados de maneira consistente com fatias regulares.</p>
</dd></dl>

</section>
<section id="static-method-objects">
<h4 class="translated"><span class="section-number">3.2.13.5. </span>Objetos método estático<a class="headerlink" href="#static-method-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Objetos método estático fornecem uma forma de transformar objetos função em objetos métodos descritos acima. Um objeto método estático é um invólucro em torno de qualquer outro objeto, comumente um objeto método definido pelo usuário. Quando um objeto método estático é recuperado de uma classe ou de uma instância de classe, o objeto retornado é o objeto encapsulado, do qual não está sujeito a nenhuma transformação adicional. Objetos método estático também são chamáveis. Objetos método estático são criados pelo construtor embutido <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
</section>
<section id="class-method-objects">
<h4 class="translated"><span class="section-number">3.2.13.6. </span>Objetos método de classe<a class="headerlink" href="#class-method-objects" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Um objeto método de classe, como um objeto método estático, é um invólucro em torno de outro objeto que altera a maneira como esse objeto é recuperado de classes e instâncias de classe. O comportamento dos objetos método de classe após tal recuperação é descrito acima, sob <a class="reference internal" href="#instance-methods"><span class="std std-ref">“métodos de instância”</span></a>. Objetos método de classe são criados pelo construtor embutido <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>.</p>
</section>
</section>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2 class="translated"><span class="section-number">3.3. </span>Nomes de métodos especiais<a class="headerlink" href="#special-method-names" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-73">Uma classe pode implementar certas operações que são chamadas por sintaxe especial (como operações aritméticas ou indexação e fatiamento), definindo métodos com nomes especiais. Esta é a abordagem do Python para <em class="dfn">sobrecarga de operador</em>, permitindo que as classes definam seu próprio comportamento em relação aos operadores da linguagem. Por exemplo, se uma classe define um método chamado <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, e <code class="docutils literal notranslate"><span class="pre">x</span></code> é uma instância desta classe, então <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> é aproximadamente equivalente a <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>. Exceto onde mencionado, as tentativas de executar uma operação levantam uma exceção quando nenhum método apropriado é definido (tipicamente <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> ou <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p class="translated">Definir um método especial para <code class="docutils literal notranslate"><span class="pre">None</span></code> indica que a operação correspondente não está disponível. Por exemplo, se uma classe define <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> para <code class="docutils literal notranslate"><span class="pre">None</span></code>, a classe não é iterável, então chamar <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> em suas instâncias irá levantar um <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (sem retroceder para <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference brackets" href="#id20" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p class="translated">Ao implementar uma classe que emula qualquer tipo embutido, é importante que a emulação seja implementada apenas na medida em que faça sentido para o objeto que está sendo modelado. Por exemplo, algumas sequências podem funcionar bem com a recuperação de elementos individuais, mas extrair uma fatia pode não fazer sentido. (Um exemplo disso é a interface <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> no Document Object Model do W3C.)</p>
<section id="basic-customization">
<span id="customization"></span><h3 class="translated"><span class="section-number">3.3.1. </span>Personalização básica<a class="headerlink" href="#basic-customization" title="Link para este cabeçalho">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__new__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-74">Chamado para criar uma nova instância da classe <em>cls</em>. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> é um método estático (é um caso especial, então você não precisa declará-lo como tal) que recebe a classe da qual uma instância foi solicitada como seu primeiro argumento. Os argumentos restantes são aqueles passados para a expressão do construtor do objeto (a chamada para a classe). O valor de retorno de <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> deve ser a nova instância do objeto (geralmente uma instância de <em>cls</em>).</p>
<p class="translated">Implementações típicas criam uma nova instância da classe invocando o método <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> da superclasse usando <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> com os argumentos apropriados e, em seguida, modificando a instância recém-criada conforme necessário antes de retorná-la.</p>
<p class="translated">Se <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> é chamado durante a construção do objeto e retorna uma instância de <em>cls</em>, então o método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> da nova instância será chamado como <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code>, onde <em>self</em> é a nova instância e os argumentos restantes são os mesmos que foram passados para o construtor do objeto.</p>
<p class="translated">Se <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> não retornar uma instância de <em>cls</em>, então o método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> da nova instância não será invocado.</p>
<p class="translated"><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> destina-se principalmente a permitir que subclasses de tipos imutáveis (como int, str ou tupla) personalizem a criação de instâncias. Também é comumente substituído em metaclasses personalizadas para personalizar a criação de classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__init__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-75">Chamado após a instância ter sido criada (por <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>), mas antes de ser retornada ao chamador. Os argumentos são aqueles passados para a expressão do construtor da classe. Se uma classe base tem um método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, o método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> da classe derivada, se houver, deve chamá-lo explicitamente para garantir a inicialização apropriada da parte da classe base da instância; por exemplo: <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code>.</p>
<p class="translated">Porque <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> e <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> trabalham juntos na construção de objetos (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> para criá-lo e <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> para personalizá-lo), nenhum valor diferente de <code class="docutils literal notranslate"><span class="pre">None</span></code> pode ser retornado por <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>; fazer isso fará com que uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> seja levantada em tempo de execução.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__del__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__del__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-76">Chamado quando a instância está prestes a ser destruída. Também é chamada de finalizador ou (incorretamente) de destruidor. Se uma classe base tem um método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>, o método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> da classe derivada, se houver, deve chamá-lo explicitamente para garantir a exclusão adequada da parte da classe base da instância.</p>
<p class="translated">É possível (embora não recomendado!) para o método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> adiar a destruição da instância criando uma nova referência a ela. Isso é chamado de <em>ressurreição</em> de objeto. Depende se a implementação de <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> é chamado uma segunda vez quando um objeto ressuscitado está prestes a ser destruído; a implementação atual do <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> chama-o apenas uma vez.</p>
<p class="translated">Não há garantia de que os métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> sejam chamados para objetos que ainda existem quando o interpretador sai. <a class="reference internal" href="../library/weakref.html#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.finalize</span></code></a> fornece uma maneira direta de registrar uma função de limpeza a ser chamada quando um objeto é coletado como lixo.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> não chama diretamente <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> – o primeiro diminui a contagem de referências para <code class="docutils literal notranslate"><span class="pre">x</span></code> em um, e o segundo só é chamado quando a contagem de referências de <code class="docutils literal notranslate"><span class="pre">x</span></code> atinge zero.</p>
</div>
<div class="impl-detail compound">
<p class="translated">É possível que um ciclo de referência impeça que a contagem de referência de um objeto chegue a zero. Neste caso, mais tarde, o ciclo será detectado e deletado pelo <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">coletor de lixo cíclico</span></a>.  Uma causa comum de referências cíclicas é quando uma exceção foi capturada em uma variável local. O locals do quadro então referencia a exceção, que referencia seu próprio traceback, que referencia o locals de todos os quadros capturados no traceback.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p class="translated">Documentação do módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Aviso</p>
<p class="translated">Devido às circunstâncias precárias sob as quais os métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> são invocados, as exceções que ocorrem durante sua execução são ignoradas e um aviso é impresso em <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> em seu lugar. Em particular:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> pode ser chamado quando um código arbitrário está sendo executado, incluindo de qualquer thread arbitrária. Se <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> precisa bloquear ou invocar qualquer outro recurso de bloqueio, pode ocorrer um impasse, pois o recurso já pode ter sido levado pelo código que é interrompido para executar <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> pode ser executado durante o encerramento do interpretador. Como consequência, as variáveis globais que ele precisa acessar (incluindo outros módulos) podem já ter sido excluídas ou definidas como <code class="docutils literal notranslate"><span class="pre">None</span></code>. Python garante que os globais cujo nome comece com um único sublinhado sejam excluídos de seu módulo antes que outros globais sejam excluídos; se nenhuma outra referência a tais globais existir, isso pode ajudar a garantir que os módulos importados ainda estejam disponíveis no momento em que o método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> for chamado.</p></li>
</ul>
</div>
<span class="target" id="index-77"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__repr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado pela função embutida <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> para calcular a representação da string “oficial” de um objeto. Se possível, isso deve parecer uma expressão Python válida que pode ser usada para recriar um objeto com o mesmo valor (dado um ambiente apropriado). Se isso não for possível, uma string no formato <code class="docutils literal notranslate"><span class="pre">&lt;...alguma</span> <span class="pre">descrição</span> <span class="pre">útil...&gt;</span></code> deve ser retornada. O valor de retorno deve ser um objeto string. Se uma classe define <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a>, mas não <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, então <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> também é usado quando uma representação de string “informal” de instâncias daquela classe é necessária.</p>
<p class="translated">Isso é normalmente usado para depuração, portanto, é importante que a representação seja rica em informações e inequívoca. Uma implementação padrão é fornecida pela própria classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.</p>
<span class="target" id="index-78"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__str__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado por <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a>, a implementação padrão de <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a>, e as funções embutidas <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>, para calcular a representação da string “informal” ou agradável para exibição de um objeto. O valor de retorno deve ser um objeto <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">str</span></a>.</p>
<p class="translated">Este método difere de <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> por não haver expectativa de que <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> retorne uma expressão Python válida: uma representação mais conveniente ou concisa pode ser usada.</p>
<p class="translated">A implementação padrão definida pelo tipo embutido <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> chama <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bytes__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bytes__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-79">Chamado por <a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> para calcular uma representação de string de bytes de um objeto. Isso deve retornar um objeto <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não fornece este método.</p>
<span class="target" id="index-80"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__format__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado pela função embutida <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> e, por extensão, avaliação de <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">literais de string formatadas</span></a> e o método <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, para produzir uma representação de string “formatada” de um objeto. O argumento <em>format_spec</em> é uma string que contém uma descrição das opções de formatação desejadas. A interpretação do argumento <em>format_spec</em> depende do tipo que implementa <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a>, entretanto a maioria das classes delegará a formatação a um dos tipos embutidos ou usará uma sintaxe de opção de formatação semelhante.</p>
<p class="translated">Consulte <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">Minilinguagem de especificação de formato</span></a> para uma descrição da sintaxe de formatação padrão.</p>
<p class="translated">O valor de retorno deve ser um objeto string.</p>
<p class="translated">A implementação padrão pela classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> deve receber uma string <em>format_spec</em> vazia. Ela delega para <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.4: </span>O método __format__ do próprio <code class="docutils literal notranslate"><span class="pre">object</span></code> levanta uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> se passada qualquer string não vazia.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span><code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> é agora equivalente a <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> em vez de <code class="docutils literal notranslate"><span class="pre">format(str(x),</span> <span class="pre">'')</span></code>.</p>
</div>
</dd></dl>

<dl class="py method" id="richcmpfuncs">
<dt class="sig sig-object py" id="object.__lt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__le__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__eq__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ne__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__gt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ge__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-81">Esses são os chamados métodos de “comparação rica”. A correspondência entre os símbolos do operador e os nomes dos métodos é a seguinte: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> e <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> chama <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code>.</p>
<p class="translated">Um método de comparação rica pode retornar o singleton <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> se não implementar a operação para um determinado par de argumentos. Por convenção, <code class="docutils literal notranslate"><span class="pre">False</span></code> e <code class="docutils literal notranslate"><span class="pre">True</span></code> são retornados para uma comparação bem-sucedida. No entanto, esses métodos podem retornar qualquer valor, portanto, se o operador de comparação for usado em um contexto booleano (por exemplo, na condição de uma instrução <code class="docutils literal notranslate"><span class="pre">if</span></code>), Python irá chamar <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> no valor para determinar se o resultado for verdadeiro ou falso.</p>
<p class="translated">Por padrão, <code class="docutils literal notranslate"><span class="pre">object</span></code> implementa <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> usando <code class="docutils literal notranslate"><span class="pre">is</span></code>, retornando <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> no caso de uma comparação falsa: <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. Para <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>, por padrão ele delega para <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e inverte o resultado a menos que seja <code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Não há outras relações implícitas entre os operadores de comparação ou implementações padrão; por exemplo, o valor verdadeiro de <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> não implica <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code>. Para gerar operações de ordenação automaticamente a partir de uma única operação raiz, consulte <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>.</p>
<p class="translated">Por padrão, a classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> fornece implementações consistentes com <a class="reference internal" href="expressions.html#expressions-value-comparisons"><span class="std std-ref">Comparações de valor</span></a>: igualdade compara de acordo com a identidade do objeto, e comparações de ordem levantam <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Cada método padrão pode gerar esses resultados diretamente, mas também pode retornar <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
<p class="translated">Veja o parágrafo sobre <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> para algumas notas importantes sobre a criação de objetos <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hasheáveis</span></a> que implementam operações de comparação personalizadas e são utilizáveis como chaves de dicionário.</p>
<p class="translated">Não há versões de argumentos trocados desses métodos (a serem usados quando o argumento esquerdo não tem suporte à operação, mas o argumento direito sim); em vez disso, <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> e <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> são o reflexo um do outro, <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> e <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> são o reflexo um do outro, e <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> são seu próprio reflexo. Se os operandos são de tipos diferentes e o tipo do operando direito é uma subclasse direta ou indireta do tipo do operando esquerdo, o método refletido do operando direito tem prioridade, caso contrário, o método do operando esquerdo tem prioridade. Subclasse virtual não é considerada.</p>
<p class="translated">Quando nenhum método apropriado retorna qualquer valor diferente de <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, os operadores <code class="docutils literal notranslate"><span class="pre">==</span></code> e <code class="docutils literal notranslate"><span class="pre">!=</span></code> retornarão para <code class="docutils literal notranslate"><span class="pre">is</span></code> e <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>, respectivamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__hash__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-82">Chamado pela função embutida <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> e para operações em membros de coleções com hash incluindo <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. O método <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> deve retornar um inteiro. A única propriedade necessária é que os objetos que são comparados iguais tenham o mesmo valor de hash; é aconselhável misturar os valores hash dos componentes do objeto que também desempenham um papel na comparação dos objetos, empacotando-os em uma tupla e fazendo o hash da tupla. Exemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> trunca o valor retornado do método <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> personalizado de um objeto para o tamanho de um <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>. Isso é normalmente 8 bytes em compilações de 64 bits e 4 bytes em compilações de 32 bits. Se o <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de um objeto deve interoperar em compilações de tamanhos de bits diferentes, certifique-se de verificar a largura em todas as compilações com suporte. Uma maneira fácil de fazer isso é com <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code>.</p>
</div>
<p class="translated">Se uma classe não define um método <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, ela também não deve definir uma operação <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>; se define <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> mas não <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, suas instâncias não serão utilizáveis como itens em coleções hasheáveis. Se uma classe define objetos mutáveis e implementa um método <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, ela não deve implementar <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, uma vez que a implementação de coleções  <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hasheáveis</span></a> requer que o valor hash de uma chave seja imutável (se o valor hash do objeto mudar, estará no balde de hash errado).</p>
<p class="translated">As classes definidas pelo usuário têm os métodos <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> por padrão (herdados da classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>); com eles, todos os objetos se comparam desiguais (exceto com eles mesmos) e <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> retorna um valor apropriado tal que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> implica que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code>.</p>
<p class="translated">Uma classe que sobrescreve <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e não define <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> terá seu <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> implicitamente definido como <code class="docutils literal notranslate"><span class="pre">None</span></code>. Quando o método <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de uma classe é <code class="docutils literal notranslate"><span class="pre">None</span></code>, as instâncias da classe levantam uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> apropriada quando um programa tenta recuperar seu valor hash, e também será identificado corretamente como não-hasheável ao verificar <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<p class="translated">Se uma classe que substitui <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> precisa manter a implementação de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de uma classe base, o interpretador deve ser informado disso explicitamente pela configuração <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ClasseBase&gt;.__hash__</span></code>.</p>
<p class="translated">Se uma classe que não substitui <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> deseja suprimir o suporte a hash, deve incluir <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> na definição de classe. Uma classe que define seu próprio <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> que levanta explicitamente uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> seria incorretamente identificada como hasheável por uma chamada <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Por padrão, os valores <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> dos objetos str e bytes são “salgados” com um valor aleatório imprevisível. Embora permaneçam constantes em um processo individual do Python, eles não são previsíveis entre invocações repetidas do Python.</p>
<p class="translated">Isso se destina a fornecer proteção contra uma negação de serviço causada por entradas cuidadosamente escolhidas que exploram o pior caso de desempenho de uma inserção de dicionário, complexidade <em>O</em>(<em>n</em><sup>2</sup>). Consulte <a class="reference external" href="http://ocert.org/advisories/ocert-2011-003.html">http://ocert.org/advisories/ocert-2011-003.html</a> para obter detalhes.</p>
<p class="translated">Alterar os valores de hash afeta a ordem de iteração dos conjuntos. Python nunca deu garantias sobre essa ordem (e normalmente varia entre compilações de 32 e 64 bits).</p>
<p class="translated">Consulte também <span class="target" id="index-134"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Aleatorização de hash está habilitada por padrão.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bool__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bool__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-84">Chamado para implementar o teste de valor verdade e a operação embutida <code class="docutils literal notranslate"><span class="pre">bool()</span></code>; deve retornar <code class="docutils literal notranslate"><span class="pre">False</span></code> ou <code class="docutils literal notranslate"><span class="pre">True</span></code>. Quando este método não é definido, <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> é chamado, se estiver definido, e o objeto é considerado verdadeiro se seu resultado for diferente de zero. Se uma classe não define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> nem <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code> (o que é verdadeiro da classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si), todas as suas instâncias são consideradas verdadeiras.</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3 class="translated"><span class="section-number">3.3.2. </span>Personalizando o acesso aos atributos<a class="headerlink" href="#customizing-attribute-access" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os seguintes métodos podem ser definidos para personalizar o significado do acesso aos atributos (uso, atribuição ou exclusão de <code class="docutils literal notranslate"><span class="pre">x.name</span></code>) para instâncias de classe.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado quando o acesso padrão ao atributo falha com um <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> (ou <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> levanta uma <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> porque <em>name</em> não é um atributo de instância ou um atributo na árvore de classes para <code class="docutils literal notranslate"><span class="pre">self</span></code>; ou <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> de uma propriedade <em>name</em> levanta <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>). Este método deve retornar o valor do atributo (calculado) ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não fornece este método.</p>
<p class="translated">Observe que se o atributo for encontrado através do mecanismo normal, <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> não é chamado. (Esta é uma assimetria intencional entre <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> e <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>.) Isso é feito tanto por razões de eficiência quanto porque <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> não teria como acessar outros atributos da instância. Observe que pelo menos para variáveis de instâncias, você pode obter controle total não inserindo nenhum valor no dicionário de atributos de instância (mas, em vez disso, inserindo-os em outro objeto). Veja o método <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> abaixo para uma maneira de realmente obter controle total sobre o acesso ao atributo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getattribute__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado incondicionalmente para implementar acessos a atributo para instâncias da classe. Se a classe também define <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, o último não será chamado a menos que <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> o chame explicitamente ou levante um <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Este método deve retornar o valor do atributo (calculado) ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Para evitar recursão infinita neste método, sua implementação deve sempre chamar o método da classe base com o mesmo nome para acessar quaisquer atributos de que necessita, por exemplo, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Este método ainda pode ser ignorado ao procurar métodos especiais como resultado de invocação implícita por meio da sintaxe da linguagem ou <a class="reference internal" href="#builtin-functions"><span class="std std-ref">built-in functions</span></a>. Consulte <a class="reference internal" href="#special-lookup"><span class="std std-ref">Pesquisa de método especial</span></a>.</p>
</div>
<p class="audit-hook translated">Para acessos a certos atributos sensíveis, levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> com os argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> e <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado quando se tenta efetuar uma atribuição de atributos. Esse método é chamado em vez do mecanismo normal (ou seja, armazena o valor no dicionário da instância). <em>name</em> é o nome do atributo, <em>value</em> é o valor a ser atribuído a ele.</p>
<p class="translated">Se <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> deseja atribuir a um atributo de instância, ele deve chamar o método da classe base com o mesmo nome, por exemplo, <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code>.</p>
<p class="audit-hook translated">Para atribuições de certos atributos sensíveis, levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code> com os argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code> e <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Como <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>, mas para exclusão de atributo em vez de atribuição. Este método só deve ser implementado se <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> for significativo para o objeto.</p>
<p class="audit-hook translated">Para exclusões a certos atributos sensíveis, levanta um <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoria</span></a> <code class="docutils literal notranslate"><span class="pre">object.__delattr__</span></code> com os argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> e <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__dir__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado quando <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> é chamado com o objeto como argumento. Um iterável deve ser retornada. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> converte o iterável retornado em uma lista e o ordena.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4 class="translated"><span class="section-number">3.3.2.1. </span>Personalizando acesso a atributos de módulos<a class="headerlink" href="#customizing-module-attribute-access" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-85">Os nomes especiais <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> também podem ser usados para personalizar o acesso aos atributos dos módulos. A função <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> no nível do módulo deve aceitar um argumento que é o nome de um atributo e retornar o valor calculado ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Se um atributo não for encontrado em um objeto de módulo por meio da pesquisa normal, por exemplo <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>, então <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> é pesquisado no módulo <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> antes de levantar <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Se encontrado, ele é chamado com o nome do atributo e o resultado é retornado.</p>
<p class="translated">A função <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> não deve aceitar nenhum argumento e retorna um iterável de strings que representa os nomes acessíveis no módulo. Se presente, esta função substitui a pesquisa padrão <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> em um módulo.</p>
<p class="translated">Para uma personalização mais refinada do comportamento do módulo (definição de atributos, propriedades etc.), pode-se definir o atributo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> de um objeto de módulo para uma subclasse de <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Por exemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span><span class="w"> </span><span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Definir <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> no módulo e configurar o <code class="docutils literal notranslate"><span class="pre">__class__</span></code> do módulo só afeta as pesquisas feitas usando a sintaxe de acesso ao atributo – acessar diretamente os globais do módulo (seja por código dentro do módulo, ou por meio de uma referência ao dicionário global do módulo) não tem efeito.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>O atributo de módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> pode agora ser escrito.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.7: </span>Atributos de módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e <code class="docutils literal notranslate"><span class="pre">__dir__</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-135"></span><a class="pep reference external" href="https://peps.python.org/pep-0562/"><strong>PEP 562</strong></a> - __getattr__ e __dir__ de módulo</dt><dd><p class="translated">Descreve as funções <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> e <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> nos módulos.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4 class="translated"><span class="section-number">3.3.2.2. </span>Implementando descritores<a class="headerlink" href="#implementing-descriptors" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Os métodos a seguir se aplicam apenas quando uma instância da classe que contém o método (uma classe chamada <em>descritora</em>) aparece em uma classe proprietária <em>owner</em> (o descritor deve estar no dicionário de classe do proprietário ou no dicionário de classe para um dos seus pais). Nos exemplos abaixo, “o atributo” refere-se ao atributo cujo nome é a chave da propriedade no <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> da classe proprietária. A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não implementa quaisquer desses protocolos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__get__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__get__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para obter o atributo da classe proprietária (acesso ao atributo da classe) ou de uma instância dessa classe (acesso ao atributo da instância). O argumento opcional <em>owner</em> é a classe proprietária, enquanto <em>instance</em> é a instância pela qual o atributo foi acessado, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> quando o atributo é acessado por meio de <em>owner</em>.</p>
<p class="translated">Este método deve retornar o valor do atributo calculado ou levantar uma exceção <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p class="translated"><span class="target" id="index-136"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> especifica que <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> é um chamável com um ou dois argumentos. Os próprios descritores embutidos do Python implementam esta especificação; no entanto, é provável que algumas ferramentas de terceiros tenham descritores que requerem ambos os argumentos. A implementação de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> do próprio Python sempre passa em ambos os argumentos sejam eles requeridos ou não.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__set__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para definir o atributo em uma instância <em>instance</em> da classe proprietária para um novo valor, <em>value</em>.</p>
<p class="translated">Observe que adicionar <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> ou <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> altera o tipo de descritor para um “descritor de dados”. Consulte <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">Invocando descritores</span></a> para mais detalhes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delete__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delete__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para excluir o atributo em uma instância <em>instance</em> da classe proprietária.</p>
</dd></dl>

<p class="translated">Instâncias de descritores também podem ter o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> presente:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="object.__objclass__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__objclass__</span></span><a class="headerlink" href="#object.__objclass__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">O atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> é interpretado pelo módulo <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> como sendo a classe onde este objeto foi definido (configurar isso apropriadamente pode ajudar na introspecção em tempo de execução dos atributos dinâmicos da classe). Para chamáveis, pode indicar que uma instância do tipo fornecido (ou uma subclasse) é esperada ou necessária como o primeiro argumento posicional (por exemplo, CPython define este atributo para métodos não acoplados que são implementados em C).</p>
</dd></dl>

</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4 class="translated"><span class="section-number">3.3.2.3. </span>Invocando descritores<a class="headerlink" href="#invoking-descriptors" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Em geral, um descritor é um atributo de objeto com “comportamento de ligação”, cujo acesso ao atributo foi substituído por métodos no protocolo do descritor: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> e <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. Se qualquer um desses métodos for definido para um objeto, é considerado um descritor.</p>
<p class="translated">O comportamento padrão para acesso ao atributo é obter, definir ou excluir o atributo do dicionário de um objeto. Por exemplo, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> tem uma cadeia de pesquisa começando com <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code>, depois <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code>, e continunando pelas classes bases de <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> excluindo metaclasses.</p>
<p class="translated">No entanto, se o valor pesquisado for um objeto que define um dos métodos do descritor, Python pode substituir o comportamento padrão e invocar o método do descritor. Onde isso ocorre na cadeia de precedência depende de quais métodos descritores foram definidos e como eles foram chamados.</p>
<p class="translated">O ponto de partida para a invocação do descritor é uma ligação, <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. Como os argumentos são montados depende de <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<dl class="simple">
<dt class="translated">Chamada direta</dt><dd><p class="translated">A chamada mais simples e menos comum é quando o código do usuário invoca diretamente um método descritor: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code>.</p>
</dd>
<dt class="translated">Ligação de instâncias</dt><dd><p class="translated">Se estiver ligando a uma instância de objeto, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> é transformado na chamada: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt class="translated">Ligação de classes</dt><dd><p class="translated">Se estiver ligando a uma classe, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> é transformado na chamada: <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt class="translated">Ligação de super</dt><dd><p class="translated">Uma pesquisa pontilhada, ou <em>dotted lookup</em>, como <code class="docutils literal notranslate"><span class="pre">super(A,</span> <span class="pre">a).x</span></code> procura <code class="docutils literal notranslate"><span class="pre">a.__class__.__mro__</span></code> por uma classe base <code class="docutils literal notranslate"><span class="pre">B</span></code> seguindo <code class="docutils literal notranslate"><span class="pre">A</span></code> e então retorna <code class="docutils literal notranslate"><span class="pre">B.__dict__['x'].__get__(a,</span> <span class="pre">A)</span></code>. Se não for um descritor, <code class="docutils literal notranslate"><span class="pre">x</span></code> é retornado inalterado.</p>
</dd>
</dl>
<p class="translated">Para ligações de instâncias, a precedência de invocação do descritor depende de quais métodos do descritor são definidos. Um descritor pode definir qualquer combinação de <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> e <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. Se ele não definir <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, então acessar o atributo retornará o próprio objeto descritor, a menos que haja um valor no dicionário de instância do objeto. Se o descritor define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> e/ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>, é um descritor de dados; se não definir nenhum, é um descritor sem dados. Normalmente, os descritores de dados definem <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, enquanto os descritores sem dados têm apenas o método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>. Descritores de dados com <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> (e/ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>) definidos sempre substituem uma redefinição em um dicionário de instância. Em contraste, descritores sem dados podem ser substituídos por instâncias.</p>
<p class="translated">Os métodos Python (incluindo aqueles decorados com <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> and <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) são implementados como descritores sem dados. Assim, as instâncias podem redefinir e substituir métodos. Isso permite que instâncias individuais adquiram comportamentos que diferem de outras instâncias da mesma classe.</p>
<p class="translated">A função <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> é implementada como um descritor de dados. Da mesma forma, as instâncias não podem substituir o comportamento de uma propriedade.</p>
</section>
<section id="slots">
<span id="id13"></span><h4 class="translated"><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="#slots" title="Link para este cabeçalho">¶</a></h4>
<p class="translated"><em>__slots__</em> permite-nos declarar explicitamente membros de dados (como propriedades) e negar a criação de <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> e <em>__weakref__</em> (a menos que explicitamente declarado em <em>__slots__</em> ou disponível em uma classe base.)</p>
<p class="translated">O espaço economizado com o uso de <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> pode ser significativo. A velocidade de pesquisa de atributos também pode ser significativamente melhorada.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__slots__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__slots__</span></span><a class="headerlink" href="#object.__slots__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Esta variável de classe pode ser atribuída a uma string, iterável ou sequência de strings com nomes de variáveis usados por instâncias. <em>__slots__</em> reserva espaço para as variáveis declaradas e evita a criação automática de <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> e <em>__weakref__</em> para cada instância.</p>
</dd></dl>

<p class="translated" id="datamodel-note-slots">Observações ao uso de <em>__slots__</em>:</p>
<ul class="simple">
<li><p class="translated">Ao herdar de uma classe sem <em>__slots__</em>, os atributos <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> e <em>__weakref__</em> das instâncias sempre estarão acessíveis.</p></li>
<li><p class="translated">Sem uma variável <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, as instâncias não podem ser atribuídas a novas variáveis não listadas na definição <em>__slots__</em>. As tentativas de atribuir a um nome de variável não listado levantam <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Se a atribuição dinâmica de novas variáveis for desejada, então adicione <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> à sequência de strings na declaração de <em>__slots__</em>.</p></li>
<li><p class="translated">Sem uma variável <em>__weakref__</em> para cada instância, as classes que definem <em>__slots__</em> não suportam <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">referências</span> <span class="pre">fracas</span></code></a> para suas instâncias. Se for necessário um suporte de referência fraca, adicione <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> à sequência de strings na declaração <em>__slots__</em>.</p></li>
<li><p class="translated"><em>__slots__</em> são implementados no nível de classe criando <a class="reference internal" href="#descriptors"><span class="std std-ref">descritores</span></a> para cada nome de variável. Como resultado, os atributos de classe não podem ser usados para definir valores padrão para variáveis de instância definidas por <em>__slots__</em>; caso contrário, o atributo de classe substituiria a atribuição do descritor.</p></li>
<li><p class="translated">A ação de uma declaração <em>__slots__</em> se limita à classe em que é definida. <em>__slots__</em> declarados em uma classe base estão disponíveis nas subclasses. No entanto, instâncias de uma subclasse filha vai receber um <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> e <em>__weakref__</em> a menos que a subclasse também defina <em>__slots__</em> (que deve conter apenas nomes de quaisquer slots <em>adicionais</em>).</p></li>
<li><p class="translated">Se uma classe define um slot também definido em uma classe base, a variável de instância definida pelo slot da classe base fica inacessível (exceto por recuperar seu descritor diretamente da classe base). Isso torna o significado do programa indefinido. No futuro, uma verificação pode ser adicionada para evitar isso.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> será levantada se <em>__slots__</em> não vazios forem definidos para uma classe derivada de um tipo embutido <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">&quot;variable-length&quot;</span></code></a> como <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
<li><p class="translated">Qualquer <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterável</span></a> não string pode ser atribuído a <em>__slots__</em>.</p></li>
<li><p class="translated">Se um <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dicionário</span></code></a> for usado para atribuir <em>__slots__</em>, as chaves do dicionário serão usadas como os nomes dos slots. Os valores do dicionário podem ser usados para fornecer docstrings por atributo que serão reconhecidos por <a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> e exibidos na saída de <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p class="translated">Atribuição de <a class="reference internal" href="#object.__class__" title="object.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> funciona apenas se ambas as classes têm o mesmo <em>__slots__</em>.</p></li>
<li><p class="translated">A <a class="reference internal" href="../tutorial/classes.html#tut-multiple"><span class="std std-ref">herança múltipla</span></a> com várias classes bases com slots pode ser usada, mas apenas uma classe base tem permissão para ter atributos criados por slots (as outras classes bases devem ter layouts de slots vazios) – violações levantam <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p class="translated">Se um <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a> for usado para <em>__slots__</em>, um <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descritor</span></a> é criado para cada um dos valores do iterador. No entanto, o atributo <em>__slots__</em> será um iterador vazio.</p></li>
</ul>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3 class="translated"><span class="section-number">3.3.3. </span>Personalizando a criação de classe<a class="headerlink" href="#customizing-class-creation" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Sempre que uma classe herda de outra classe, <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> é chamado na classe base. Dessa forma, é possível escrever classes que alteram o comportamento das subclasses. Isso está intimamente relacionado aos decoradores de classe, mas onde decoradores de classe afetam apenas a classe específica à qual são aplicados, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> aplica-se apenas a futuras subclasses da classe que define o método.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__init_subclass__">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Este método é chamado sempre que a classe que contém é uma subclasse. <em>cls</em> é então a nova subclasse. Se definido como um método de instância normal, esse método é convertido implicitamente em um método de classe.</p>
<p class="translated">Argumentos nomeados dados a uma nova classe são passados para <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> da classe base. Para compatibilidade com outras classes usando <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, deve-se retirar os argumentos nomeados necessários e passar os outros para a classe base, como em:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">A implementação padrão de <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> não faz nada, mas levanta um erro se for chamada com quaisquer argumentos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">A dica da metaclasse <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> é consumida pelo resto da maquinaria de tipo, e nunca é passada para implementações <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. A metaclasse real (em vez da dica explícita) pode ser acessada como <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.6.</span></p>
</div>
</dd></dl>

<p class="translated">Quando uma classe é criada, <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__new__()</span></code> verifica as variáveis de classe e faz chamadas a funções de retorno (callback) para aqueles com um gancho <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__set_name__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set_name__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado automaticamente no momento em que a classe proprietária <em>owner</em> é criada. O objeto foi atribuído a <em>name</em> nessa classe:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>  <span class="c1"># Automaticamente chama: x.__set_name__(A, &#39;x&#39;)</span>
</pre></div>
</div>
<p class="translated">Se a variável de classe for atribuída após a criação da classe, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> não será chamado automaticamente. Se necessário, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> pode ser chamado diretamente:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span>                  <span class="c1"># O gancho não é chamado</span>
<span class="n">c</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>   <span class="c1"># Invoca manualmente o gancho</span>
</pre></div>
</div>
<p class="translated">Consulte <a class="reference internal" href="#class-object-creation"><span class="std std-ref">Criando o objeto classe</span></a> para mais detalhes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.6.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id14"></span><h4 class="translated"><span class="section-number">3.3.3.1. </span>Metaclasses<a class="headerlink" href="#metaclasses" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-88">Por padrão, as classes são construídas usando <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>. O corpo da classe é executado em um novo espaço de nomes e o nome da classe é vinculado localmente ao resultado de <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code>.</p>
<p class="translated">O processo de criação da classe pode ser personalizado passando o argumento nomeado <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> na linha de definição da classe, ou herdando de uma classe existente que incluiu tal argumento. No exemplo a seguir, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> e <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> são instâncias de <code class="docutils literal notranslate"><span class="pre">Meta</span></code>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">Quaisquer outros argumentos nomeados especificados na definição de classe são transmitidos para todas as operações de metaclasse descritas abaixo.</p>
<p class="translated">Quando uma definição de classe é executada, as seguintes etapas ocorrem:</p>
<ul class="simple">
<li><p class="translated">entradas de MRO são resolvidas;</p></li>
<li><p class="translated">a metaclasse apropriada é determinada;</p></li>
<li><p class="translated">o espaço de nomes da classe é preparada;</p></li>
<li><p class="translated">o corpo da classe é executado;</p></li>
<li><p class="translated">o objeto da classe é criado.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4 class="translated"><span class="section-number">3.3.3.2. </span>Resolvendo entradas de MRO<a class="headerlink" href="#resolving-mro-entries" title="Link para este cabeçalho">¶</a></h4>
<dl class="py method">
<dt class="sig sig-object py" id="object.__mro_entries__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mro_entries__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mro_entries__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Se uma classe base que aparece em uma definição de classe não é uma instância de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, então um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> é procurado na base. Se um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> é encontrado, a base é substituída pelo resultado de uma chamada para <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> ao criar a classe. O método é chamado com a tupla de bases original passada como parâmetro <em>bases</em>, e deve retornar uma tupla de classes que serão usadas no lugar da base. A tupla retornada pode estar vazia: nesses casos, a base original é ignorada.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><a class="reference internal" href="../library/types.html#types.resolve_bases" title="types.resolve_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.resolve_bases()</span></code></a></dt><dd><p class="translated">Dinamicamente resolve bases que não são instâncias de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/types.html#types.get_original_bases" title="types.get_original_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.get_original_bases()</span></code></a></dt><dd><p class="translated">Recupera as “bases originais” de uma classe antes das modificações feitas por <a class="reference internal" href="#object.__mro_entries__" title="object.__mro_entries__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code></a>.</p>
</dd>
<dt class="translated"><span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a></dt><dd><p class="translated">Suporte básico para módulo typing e tipos genéricos.</p>
</dd>
</dl>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<h4 class="translated"><span class="section-number">3.3.3.3. </span>Determinando a metaclasse apropriada<a class="headerlink" href="#determining-the-appropriate-metaclass" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-90">A metaclasse apropriada para uma definição de classe é determinada da seguinte forma:</p>
<ul class="simple">
<li><p class="translated">se nenhuma classe base e nenhuma metaclasse explícita forem fornecidas, então <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> é usada;</p></li>
<li><p class="translated">se uma metaclasse explícita é fornecida e <em>não</em> é uma instância de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, então ela é usada diretamente como a metaclasse;</p></li>
<li><p class="translated">se uma instância de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> é fornecida como a metaclasse explícita, ou classes bases são definidas, então a metaclasse mais derivada é usada.</p></li>
</ul>
<p class="translated">A metaclasse mais derivada é selecionada a partir da metaclasse explicitamente especificada (se houver) e das metaclasses (ou seja, <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) de todas as classes bases especificadas. A metaclasse mais derivada é aquela que é um subtipo de <em>todas</em> essas metaclasses candidatas. Se nenhuma das metaclasses candidatas atender a esse critério, a definição de classe falhará com <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4 class="translated"><span class="section-number">3.3.3.4. </span>Preparando o espaço de nomes da classe<a class="headerlink" href="#preparing-the-class-namespace" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-91">Uma vez identificada a metaclasse apropriada, o espaço de nomes da classe é preparado. Se a metaclasse tiver um atributo <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, ela será chamada como <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (onde os argumentos nomeados adicionais, se houver, vêm da definição de classe). O método <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> deve ser implementado como um <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod</span></code></a>. O espaço de nomes retornado por <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> é passado para <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, mas quando o objeto classe final é criado, o espaço de nomes é copiado para um novo <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p class="translated">Se a metaclasse não tiver o atributo <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, então o espaço de nomes da classe é inicializado como um mapeamento ordenado vazio.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-137"></span><a class="pep reference external" href="https://peps.python.org/pep-3115/"><strong>PEP 3115</strong></a> - Metaclasses no Python 3000</dt><dd><p class="translated">Introduzido o gancho de espaço de nomes <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4 class="translated"><span class="section-number">3.3.3.5. </span>Executando o corpo da classe<a class="headerlink" href="#executing-the-class-body" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-93">O corpo da classe é executado (aproximadamente) como <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code>. A principal diferença de uma chamada normal para <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> é que o escopo léxico permite que o corpo da classe (incluindo quaisquer métodos) faça referência a nomes dos escopos atual e externo quando a definição de classe ocorre dentro de uma função.</p>
<p class="translated">No entanto, mesmo quando a definição de classe ocorre dentro da função, os métodos definidos dentro da classe ainda não podem ver os nomes definidos no escopo da classe. Variáveis de classe devem ser acessadas através do primeiro parâmetro de instância ou métodos de classe, ou através da referência implícita com escopo léxico <code class="docutils literal notranslate"><span class="pre">__class__</span></code> descrita na próxima seção.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4 class="translated"><span class="section-number">3.3.3.6. </span>Criando o objeto classe<a class="headerlink" href="#creating-the-class-object" title="Link para este cabeçalho">¶</a></h4>
<p class="translated" id="index-94">Uma vez que o espaço de nomes da classe tenha sido preenchido executando o corpo da classe, o objeto classe é criado chamando <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> (os argumentos adicionais passados aqui são os mesmos passados para <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>).</p>
<p class="translated">Este objeto classe é aquele que será referenciado pela chamada a  <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> sem argumentos. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> é uma referência de clausura implícita criada pelo compilador se algum método no corpo da classe se referir a <code class="docutils literal notranslate"><span class="pre">__class__</span></code> ou <code class="docutils literal notranslate"><span class="pre">super</span></code>. Isso permite que a forma de argumento zero de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> identifique corretamente a classe sendo definida com base no escopo léxico, enquanto a classe ou instância que foi usada para fazer a chamada atual é identificada com base no primeiro argumento passado para o método.</p>
<div class="impl-detail compound">
<p class="translated">No CPython 3.6 e posterior, a célula <code class="docutils literal notranslate"><span class="pre">__class__</span></code> é passada para a metaclasse como uma entrada de <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> no espaço de nomes da classe. Se estiver presente, deve ser propagado até a chamada a <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> para que a classe seja inicializada corretamente. Não fazer isso resultará em um <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> no Python 3.8.</p>
</div>
<p class="translated">Quando usada a metaclasse padrão <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, ou qualquer metaclasse que chame <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, as seguintes etapas de personalização adicionais são executadas depois da criação do objeto classe:</p>
<ol class="arabic simple">
<li><p class="translated">O método <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> coleta todos os atributos no espaço de nomes da classe que definem um método <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a>;</p></li>
<li><p class="translated">Esses métodos <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> são chamados com a classe sendo definida e o nome atribuído para este atributo específico;</p></li>
<li><p class="translated">O gancho <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> é chamado na classe base imediata da nova classe em sua ordem de resolução de método.</p></li>
</ol>
<p class="translated">Depois que o objeto classe é criado, ele é passado para os decoradores de classe incluídos na definição de classe (se houver) e o objeto resultante é vinculado ao espaço de nomes local como a classe definida.</p>
<p class="translated">Quando uma nova classe é criada por <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, o objeto fornecido como o parâmetro do espaço de nomes é copiado para um novo mapeamento ordenado e o objeto original é descartado. A nova cópia é envolta em um proxy de somente leitura, que se torna o atributo <a class="reference internal" href="#type.__dict__" title="type.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> do objeto classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-138"></span><a class="pep reference external" href="https://peps.python.org/pep-3135/"><strong>PEP 3135</strong></a> - Novo super</dt><dd><p class="translated">Descreve a referência de clausura implícita de  <code class="docutils literal notranslate"><span class="pre">__class__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4 class="translated"><span class="section-number">3.3.3.7. </span>Usos para metaclasses<a class="headerlink" href="#uses-for-metaclasses" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Os usos potenciais para metaclasses são ilimitados. Algumas ideias que foram exploradas incluem enumeradores, criação de log, verificação de interface, delegação automática, criação automática de propriedade, proxies, estruturas e travamento/sincronização automático/a de recursos.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3 class="translated"><span class="section-number">3.3.4. </span>Personalizando verificações de instância e subclasse<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os seguintes métodos são usados para substituir o comportamento padrão das funções embutidas <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> e <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.</p>
<p class="translated">Em particular, a metaclasse <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> implementa esses métodos a fim de permitir a adição de classes base abstratas (ABCs) como “classes base virtuais” para qualquer classe ou tipo (incluindo tipos embutidos), incluindo outras ABCs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="type.__instancecheck__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__instancecheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#type.__instancecheck__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna verdadeiro se <em>instance</em> deve ser considerada uma instância (direta ou indireta) da classe <em>class</em>. Se definido, chamado para implementar <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="type.__subclasscheck__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__subclasscheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subclass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#type.__subclasscheck__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna verdadeiro se <em>subclass</em> deve ser considerada uma subclasse (direta ou indireta) da classe <em>class</em>. Se definido, chamado para implementar <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<p class="translated">Observe que esses métodos são pesquisados no tipo (metaclasse) de uma classe. Eles não podem ser definidos como métodos de classe na classe real. Isso é consistente com a pesquisa de métodos especiais que são chamados em instâncias, apenas neste caso a própria instância é uma classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-139"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a> - Introduzindo classes base abstratas</dt><dd><p class="translated">Inclui a especificação para personalizar o comportamento de <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> e <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> através de <a class="reference internal" href="#type.__instancecheck__" title="type.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> e <a class="reference internal" href="#type.__subclasscheck__" title="type.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a>, com motivação para esta funcionalidade no contexto da adição de classes base abstratas (veja o módulo <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>) para a linguagem.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3 class="translated"><span class="section-number">3.3.5. </span>Emulando tipos genéricos<a class="headerlink" href="#emulating-generic-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Quando estiver usando <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">anotações de tipo</span></a>, é frequentemente útil <em>parametrizar</em> um <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">tipo genérico</span></a> usando a notação de colchetes do Python. Por exemplo, a anotação <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> pode ser usada para indicar uma <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> em que todos os seus elementos são do tipo <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-140"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> - Dicas de tipo</dt><dd><p class="translated">Apresenta a estrutura do Python para anotações de tipo</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Tipos Generic Alias</span></a></dt><dd><p class="translated">Documentação de objetos que representam classes genéricas parametrizadas</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">Genéricos</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">genéricos definidos pelo usuário</span></a> e <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p class="translated">Documentação sobre como implementar classes genéricas que podem ser parametrizadas em tempo de execução e compreendidas por verificadores de tipo estático.</p>
</dd>
</dl>
</div>
<p class="translated">Uma classe pode <em>geralmente</em> ser parametrizada somente se ela define o método de classe especial <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__class_getitem__">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__class_getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna um objeto que representa a especialização de uma classe genérica por argumentos de tipo encontrados em <em>key</em>.</p>
<p class="translated">Quando definido em uma classe, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> é automaticamente um método de classe. Assim, não é necessário que seja decorado com <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> quando de sua definição.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4 class="translated"><span class="section-number">3.3.5.1. </span>O propósito de <em>__class_getitem__</em><a class="headerlink" href="#the-purpose-of-class-getitem" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">O propósito de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> é permitir a parametrização em tempo de execução de classes genéricas da biblioteca padrão, a fim de aplicar mais facilmente <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a> a essas classes.</p>
<p class="translated">Para implementar classes genéricas personalizadas que podem ser parametrizadas em tempo de execução e compreendidas por verificadores de tipo estáticos, os usuários devem herdar de uma classe da biblioteca padrão que já implementa <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, ou herdar de <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, que possui sua própria implementação de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p class="translated">Implementações personalizadas de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> em classes definidas fora da biblioteca padrão podem não ser compreendidas por verificadores de tipo de terceiros, como o mypy. O uso de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> em qualquer classe para fins diferentes de dicas de tipo é desencorajado.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4 class="translated"><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> versus <em>__getitem__</em><a class="headerlink" href="#class-getitem-versus-getitem" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Normalmente, a <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> de um objeto usando colchetes chamará o método de instância <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> definido na classe do objeto. No entanto, se o objeto sendo subscrito for ele mesmo uma classe, o método de classe <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> pode ser chamado em seu lugar. <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> deve retornar um objeto <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a> se estiver devidamente definido.</p>
<p class="translated">Apresentado com a <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expressão</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, o interpretador de Python segue algo parecido com o seguinte processo para decidir se <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> ou <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> deve ser chamado:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the result of the expression &#39;obj[x]&#39;&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># Se a classe de  obj define __getitem__,</span>
    <span class="c1"># chama class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Do contrário, se obj for uma classe e define __class_getitem__,</span>
    <span class="c1"># chama obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Do contrário, levanta uma exceção</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p class="translated">Em Python, todas as classes são elas mesmas instâncias de outras classes. A classe de uma classe é conhecida como <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclasse</span></a> dessa classe, e a maioria das classes tem a classe <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> como sua metaclasse. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> não define <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, o que significa que expressões como <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>, <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> e <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> resultam em chamadas para <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># lista tem a classe &quot;type&quot; como sua metaclasse, como a maioria das classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; chama &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ retorna um objeto GenericAlias:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">No entanto, se uma classe tiver uma metaclasse personalizada que define <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, subscrever a classe pode resultar em comportamento diferente. Um exemplo disso pode ser encontrado no módulo <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Classes Enum têm uma metaclasses personalizada:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta define __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># de forma que __class_getitem__ não é chamado,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># e o resultado não é um objeto GenericAlias:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-141"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a> - Suporte básico para módulo typing e tipos genéricos</dt><dd><p class="translated">Introduz <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, e define quando uma <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscrição</span></a> resulta na chamada de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> em vez de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="id15"></span><h3 class="translated"><span class="section-number">3.3.6. </span>Emulando objetos chamáveis<a class="headerlink" href="#emulating-callable-objects" title="Link para este cabeçalho">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__call__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-99">Chamado quando a instância é “chamada” como uma função; se este método for definido, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> basicamente traduz para <code class="docutils literal notranslate"><span class="pre">type(x).__call__(x,</span> <span class="pre">arg1,</span> <span class="pre">...)</span></code>. A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não fornece este método.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3 class="translated"><span class="section-number">3.3.7. </span>Emulando tipos contêineres<a class="headerlink" href="#emulating-container-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os métodos a seguir podem ser definidos para implementar objetos contêineres. Nenhum deles são fornecidos pela classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si. Os contêineres geralmente são <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequências</span></a> (tal como <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">listas</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuplas</span></code></a>) ou <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapeamentos</span></a> (com <a class="reference internal" href="../glossary.html#term-dictionary"><span class="xref std std-term">dicionários</span></a>), mas também podem representar outros contêineres. O primeiro conjunto de métodos é usado para emular uma sequência ou para emular um mapeamento; a diferença é que, para uma sequência, as chaves permitidas devem ser os inteiros <em>k</em> para os quais <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> onde <em>N</em> é o comprimento da sequência, ou objetos <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a>, que definem um intervalo de itens. Também é recomendado que os mapeamentos forneçam os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> se comportando de forma semelhante aos objetos <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dicionário</span></code></a> padrão do Python. O módulo <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> fornece uma <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">classe base abstrata</span></a> <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> para ajudar a criar esses métodos a partir de um conjunto base de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>. Sequências mutáveis devem fornecer métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, como objetos <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> padrão do Python. Finalmente, os tipos sequência devem implementar adição (significando concatenação) e multiplicação (significando repetição) definindo os métodos <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> e <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a> descritos abaixo; eles não devem definir outros operadores numéricos. É recomendado que ambos os mapeamentos e sequências implementem o método <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> para permitir o uso eficiente do operador <code class="docutils literal notranslate"><span class="pre">in</span></code>; para mapeamentos, <code class="docutils literal notranslate"><span class="pre">in</span></code> deve pesquisar as chaves do mapeamento; para sequências, ele deve pesquisar os valores. É ainda recomendado que ambos os mapeamentos e sequências implementem o método <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> para permitir a iteração eficiente através do contêiner; para mapeamentos, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> deve iterar através das chaves do objeto; para sequências, ele deve iterar por meio dos valores.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__len__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-100">Chamado para implementar a função embutida <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>. Deve retornar o comprimento do objeto, um inteiro <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. Além disso, um objeto que não define um método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> e cujo método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> retorna zero é considerado como falso em um contexto booleano.</p>
<div class="impl-detail compound">
<p class="translated">No CPython, o comprimento deve ser no máximo <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>. Se o comprimento for maior que <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code>, alguns recursos (como <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) podem levantar <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>. Para evitar levantar <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> pelo teste de valor de verdade, um objeto deve definir um método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__length_hint__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__length_hint__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para implementar <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Deve retornar um comprimento estimado para o objeto (que pode ser maior ou menor que o comprimento real). O comprimento deve ser um inteiro <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. O valor de retorno também pode ser <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, que é tratado da mesma forma como se o método <code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> não existisse. Este método é puramente uma otimização e nunca é necessário para a correção.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-101">
<p class="admonition-title">Nota</p>
<p class="translated">O fatiamento é feito exclusivamente com os três métodos a seguir. Uma chamada como</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="translated">é traduzida com</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="translated">e assim por diante. Os itens de fatia ausentes são sempre preenchidos com <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para implementar a avaliação de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Para tipos de <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequência</span></a>, as chaves aceitas devem ser inteiros. Opcionalmente, eles também podem oferecer suporte a objetos <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a>. Suporte a índice negativo também é opcional. Se <em>key</em> for de um tipo impróprio, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> pode ser levantada; se <em>key</em> for de um valor fora do conjunto de índices para a sequência (após qualquer interpretação especial de valores negativos), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> deve ser levantada. Para tipos <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapeamento</span></a>, se <em>key</em> estiver faltando (não no contêiner), <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> deve ser levantada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Os loops <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> esperam que uma <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> seja levantada para índices ilegais para permitir a detecção apropriada do fim da sequência.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Ao fazer <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscrição</span></a> de uma <em>classe</em>, o método de classe especial <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> pode ser chamado em vez de <code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. Veja <a class="reference internal" href="#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a> para mais detalhes.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para implementar a atribuição de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Mesma nota que para <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Isso só deve ser implementado para mapeamentos se os objetos suportarem alterações nos valores das chaves, ou se novas chaves puderem ser adicionadas, ou para sequências se os elementos puderem ser substituídos. As mesmas exceções devem ser levantadas para valores <em>key</em> impróprios do método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para implementar a exclusão de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Mesma nota que para <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Isso só deve ser implementado para mapeamentos se os objetos suportarem remoções de chaves, ou para sequências se os elementos puderem ser removidos da sequência. As mesmas exceções devem ser levantadas para valores <em>key</em> impróprios do método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__missing__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__missing__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado por <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> para implementar <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> para subclasses de dicionário quando a chave não estiver no dicionário.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Este método é chamado quando um <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a> é necessário para um contêiner. Este método deve retornar um novo objeto iterador que pode iterar sobre todos os objetos no contêiner. Para mapeamentos, ele deve iterar sobre as chaves do contêiner.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__reversed__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reversed__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado (se presente) pelo <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> embutido para implementar a iteração reversa. Ele deve retornar um novo objeto iterador que itera sobre todos os objetos no contêiner na ordem reversa.</p>
<p class="translated">Se o método <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> não for fornecido, o <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> embutido voltará a usar o protocolo de sequência (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> e <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). Objetos que suportam o protocolo de sequência só devem fornecer <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> se eles puderem fornecer uma implementação que seja mais eficiente do que aquela fornecida por <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a>.</p>
</dd></dl>

<p class="translated">Os operadores de teste de associação (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> e <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) são normalmente implementados como uma iteração através de um contêiner. No entanto, os objetos contêiner podem fornecer o seguinte método especial com uma implementação mais eficiente, que também não requer que o objeto seja iterável.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__contains__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para implementar operadores de teste de associação. Deve retornar verdadeiro se <em>item</em> estiver em <em>self</em>, falso caso contrário. Para objetos de mapeamento, isso deve considerar as chaves do mapeamento em vez dos valores ou pares de itens-chave.</p>
<p class="translated">Para objetos que não definem <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, o teste de associação primeiro tenta a iteração via <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, depois o protocolo de iteração de sequência antigo via <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, consulte <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">esta seção em a referência da linguagem</span></a>.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3 class="translated"><span class="section-number">3.3.8. </span>Emulando tipos numéricos<a class="headerlink" href="#emulating-numeric-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os métodos a seguir podem ser definidos para emular objetos numéricos. Métodos correspondentes a operações que não são suportadas pelo tipo particular de número implementado (por exemplo, operações bit a bit para números não inteiros) devem ser deixados indefinidos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__add__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__sub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__mul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__matmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__matmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__truediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__floordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__mod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__divmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__divmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__pow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__lshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__and__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__xor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__xor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__or__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__or__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-102">Esses métodos são chamados para implementar as operações aritméticas binárias (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>). Por exemplo, para avaliar a expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, onde <em>x</em> é uma instância de uma classe que tem um método <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">type(x).__add__(x,</span> <span class="pre">y)</span></code> é chamado. O método <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> deve ser equivalente a usar <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> e <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a>; não deve estar relacionado a <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>. Note que <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> deve ser definido para aceitar um terceiro argumento opcional se a versão ternária da função embutida <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> for suportada.</p>
<p class="translated">Se um desses métodos não suporta a operação com os argumentos fornecidos, ele deve retornar <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__radd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rsub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rtruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rtruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rfloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rfloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rdivmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rdivmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rpow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rlshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rlshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rrshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rrshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__rxor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rxor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ror__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ror__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-103">Esses métodos são chamados para implementar as operações aritméticas binárias (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) com operandos refletidos (trocados). Essas funções são chamadas apenas se o operando esquerdo não suportar a operação correspondente <a class="footnote-reference brackets" href="#id21" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> e os operandos forem de tipos diferentes. <a class="footnote-reference brackets" href="#id22" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> Por exemplo, para avaliar a expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, onde <em>y</em> é uma instância de uma classe que tem um método <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">type(y).__rsub__(y,</span> <span class="pre">x)</span></code> é chamado se <code class="docutils literal notranslate"><span class="pre">type(x).__sub__(x,</span> <span class="pre">y)</span></code> retorna <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
<p class="translated" id="index-104">Note que ternário <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> não tentará chamar <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> (as regras de coerção se tornariam muito complicadas).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Se o tipo do operando direito for uma subclasse do tipo do operando esquerdo e essa subclasse fornecer uma implementação diferente do método refletido para a operação, este método será chamado antes do método não refletido do operando esquerdo. Esse comportamento permite que as subclasses substituam as operações de seus ancestrais.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iadd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iadd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__isub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__isub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__imul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__imatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__itruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__itruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ifloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ifloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__imod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ipow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ipow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ilshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ilshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__irshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__irshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__iand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ixor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ixor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ior__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ior__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Esses métodos são chamados para implementar as atribuições aritméticas aumentadas (<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>). Esses métodos devem tentar fazer a operação no local (modificando <em>self</em>) e retornar o resultado (que poderia ser, mas não precisa ser, <em>self</em>). Se um método específico não for definido, ou se esse método retorna <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, a atribuição aumentada volta aos métodos normais. Por exemplo, se <em>x</em> é uma instância de uma classe com um método <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> equivale a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code>. Se <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> não existe, ou se <code class="docutils literal notranslate"><span class="pre">x.__iadd__(y)</span></code> retorna <code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code>, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> e <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> são considerados, como com a avaliação de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>. Em certas situações, a atribuição aumentada pode resultar em erros inesperados (veja <a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">Porque uma_tupla[i] += [‘item’] levanta uma exceção quando a adição funciona?</span></a>), mas este comportamento é na verdade parte do modelo de dados.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__neg__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__pos__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__abs__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__abs__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__invert__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__invert__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-105">Chamado para implementar as operações aritméticas unárias (<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> e <code class="docutils literal notranslate"><span class="pre">~</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__complex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__complex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__int__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__int__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__float__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__float__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-106">Chamado para implementar as funções embutidas <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> e <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>. Deve retornar um valor do tipo apropriado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__index__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__index__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado para implementar <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a>, e sempre que o Python precisar converter sem perdas o objeto numérico em um objeto inteiro (como no fatiamento ou nas funções embutidas <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> e <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>). A presença deste método indica que o objeto numérico é do tipo inteiro. Deve retornar um número inteiro.</p>
<p class="translated">Se <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> e <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> não estiverem definidos, funções embutidas correspondentes <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> e <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> recorre a <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__round__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__round__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ndigits</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__trunc__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__trunc__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__floor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py" id="object.__ceil__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ceil__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated" id="index-107">Chamado para implementar as funções embutidas <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> e <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> e <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> de <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>. A menos que <em>ndigits</em> sejam passados para <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> todos estes métodos devem retornar o valor do objeto truncado para um <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (tipicamente um <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p class="translated">A função embutida <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> retorna para <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> se nem <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> nem <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> estiverem definidos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.11: </span>A delegação de <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> para <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> foi descontinuada.</p>
</div>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3 class="translated"><span class="section-number">3.3.9. </span>Gerenciadores de contexto da instrução with<a class="headerlink" href="#with-statement-context-managers" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Um <em class="dfn">gerenciador de contexto</em> é um objeto que define o contexto de tempo de execução a ser estabelecido ao executar uma instrução <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. O gerenciador de contexto lida com a entrada e a saída do contexto de tempo de execução desejado para a execução do bloco de código. Os gerenciadores de contexto são normalmente invocados usando a instrução <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> (descrita na seção <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">A instrução with</span></a>), mas também podem ser usados invocando diretamente seus métodos.</p>
<p class="translated" id="index-108">Os usos típicos de gerenciadores de contexto incluem salvar e restaurar vários tipos de estado global, travar e destravar recursos, fechar arquivos abertos, etc.</p>
<p class="translated">Para mais informações sobre gerenciadores de contexto, veja <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos de Gerenciador de Contexto</span></a>. A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não fornece os métodos do gerenciador de contexto.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__enter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__enter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Insere o contexto de tempo de execução relacionado a este objeto. A instrução <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> vinculará o valor de retorno deste método ao(s) alvo(s) especificado(s) na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> da instrução, se houver.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__exit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__exit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Sai do contexto de tempo de execução relacionado a este objeto. Os parâmetros descrevem a exceção que fez com que o contexto fosse encerrado. Se o contexto foi encerrado sem exceção, todos os três argumentos serão <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<p class="translated">Se uma exceção for fornecida e o método desejar suprimir a exceção (ou seja, evitar que ela seja propagada), ele deve retornar um valor verdadeiro. Caso contrário, a exceção será processada normalmente ao sair deste método.</p>
<p class="translated">Observe que os métodos <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> não devem relançar a exceção passada; esta é a responsabilidade do chamador.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-142"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> - A instrução “with”</dt><dd><p class="translated">A especificação, o histórico e os exemplos para a instrução Python <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
</dd>
</dl>
</div>
</section>
<section id="customizing-positional-arguments-in-class-pattern-matching">
<span id="class-pattern-matching"></span><h3 class="translated"><span class="section-number">3.3.10. </span>Customizando argumentos posicionais na classe correspondência de padrão<a class="headerlink" href="#customizing-positional-arguments-in-class-pattern-matching" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Ao usar um nome de classe em um padrão, argumentos posicionais não são permitidos por padrão, ou seja, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> é tipicamente inválida sem suporte especial em <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. Para permitir a utilização desse tipo de padrão, a classe precisa definir um atributo <em>__match_args__</em></p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__match_args__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__match_args__</span></span><a class="headerlink" href="#object.__match_args__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Essa variável de classe pode ser atribuída a uma tupla de strings. Quando essa classe é usada em uma classe padrão com argumentos posicionais, cada argumento posicional será convertido para um argumento nomeado, usando correspondência de valor em  <em>__match_args__</em> como palavra reservada. A ausência desse atributo é equivalente a defini-lo como <code class="docutils literal notranslate"><span class="pre">()</span></code></p>
</dd></dl>

<p class="translated">Por exemplo, se <code class="docutils literal notranslate"><span class="pre">MyClass.__match_args__</span></code> é <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;center&quot;,</span> <span class="pre">&quot;right&quot;)</span></code> significa que <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(left=x,</span> <span class="pre">center=y)</span></code>. Note que o número de argumentos no padrão deve ser menor ou igual ao número de elementos em <em>__match_args__</em>; caso seja maior, a tentativa de correspondência de padrão irá levantar uma <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-143"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a> - Correspondência de Padrão Estrutural</dt><dd><p class="translated">A especificação para a instrução Python <code class="docutils literal notranslate"><span class="pre">match</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="emulating-buffer-types">
<span id="python-buffer-protocol"></span><h3 class="translated"><span class="section-number">3.3.11. </span>Emulando tipos buffer<a class="headerlink" href="#emulating-buffer-types" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">O <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">protocolo buffer</span></a> fornece uma maneira para objetos Python exporem acesso eficiente a um vetor de memória de baixo nível. Este protocolo é implementado por tipos embutido como <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>, e bibliotecas de terceiros podem definir tipos de buffer adicionais.</p>
<p class="translated">Embora os tipos buffer sejam geralmente implementados em C, também é possível implementar o protocolo em Python.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__buffer__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado quando um buffer é solicitado de <em>self</em> (por exemplo, pelo construtor de <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>). O argumento <em>flags</em> é um inteiro que representa o tipo de buffer solicitado, afetando, por exemplo, se o buffer retornado é somente leitura ou gravável. <a class="reference internal" href="../library/inspect.html#inspect.BufferFlags" title="inspect.BufferFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.BufferFlags</span></code></a> fornece uma maneira conveniente de interpretar os sinalizadores. O método deve retornar um objeto <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__release_buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__release_buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__release_buffer__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Chamado quando um buffer não é mais necessário. O argumento <em>buffer</em> é um objeto <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> que foi retornado anteriormente por <a class="reference internal" href="#object.__buffer__" title="object.__buffer__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__buffer__()</span></code></a>. O método deve liberar quaisquer recursos associados ao buffer. Este método deve retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>. Objetos buffer que não precisam executar nenhuma limpeza não são necessários para implementar este método.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.12.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-144"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/"><strong>PEP 688</strong></a> - Tornando o protocolo de buffer acessível no Python</dt><dd><p class="translated">Introduz os métodos <code class="docutils literal notranslate"><span class="pre">__buffer__</span></code> e <code class="docutils literal notranslate"><span class="pre">__release_buffer__</span></code> no Python</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a></dt><dd><p class="translated">ABC para tipos buffer.</p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3 class="translated"><span class="section-number">3.3.12. </span>Pesquisa de método especial<a class="headerlink" href="#special-method-lookup" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Para classes personalizadas, as invocações implícitas de métodos especiais só têm garantia de funcionar corretamente se definidas em um tipo de objeto, não no dicionário de instância do objeto. Esse comportamento é o motivo pelo qual o código a seguir levanta uma exceção:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p class="translated">A justificativa por trás desse comportamento está em uma série de métodos especiais como <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> e <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> que são implementados por todos os objetos, incluindo objetos de tipo. Se a pesquisa implícita desses métodos usasse o processo de pesquisa convencional, eles falhariam quando invocados no próprio objeto do tipo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p class="translated">A tentativa incorreta de invocar um método não vinculado de uma classe dessa maneira é às vezes referida como “confusão de metaclasse” e é evitada ignorando a instância ao pesquisar métodos especiais:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">Além de contornar quaisquer atributos de instância no interesse da correção, a pesquisa de método especial implícita geralmente também contorna o método <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> mesmo da metaclasse do objeto:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p class="translated">Ignorar a maquinaria de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> desta forma fornece um escopo significativo para otimizações de velocidade dentro do interpretador, ao custo de alguma flexibilidade no tratamento de métodos especiais (o método especial <em>deve</em> ser definido no próprio objeto classe para ser invocado de forma consistente pelo interpretador).</p>
</section>
</section>
<section id="coroutines">
<span id="index-112"></span><h2 class="translated"><span class="section-number">3.4. </span>Corrotinas<a class="headerlink" href="#coroutines" title="Link para este cabeçalho">¶</a></h2>
<section id="awaitable-objects">
<h3 class="translated"><span class="section-number">3.4.1. </span>Objetos aguardáveis<a class="headerlink" href="#awaitable-objects" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Um objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardável</span></a> geralmente implementa um método <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Os <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">objetos corrotina</span></a> retornados das funções <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> são aguardáveis.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Os objetos <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">iteradores geradores</span></a> retornados de geradores decorados com <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> também são aguardáveis, mas eles não implementam <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__await__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__await__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Deve retornar um <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a>. Deve ser usado para implementar objetos <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardáveis</span></a>. Por exemplo, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> implementa este método para ser compatível com a expressão <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não é aguardável e não fornece este método.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">A linguagem não impõe nenhuma restrição ao tipo ou valor dos objetos produzidos pelo iterador retornado por <code class="docutils literal notranslate"><span class="pre">__await__</span></code>, pois isso é específico para a implementação da estrutura de execução assíncrona (por exemplo, <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) que gerenciará o objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>.</p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p class="translated"><span class="target" id="index-145"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> para informações adicionais sobre objetos aguardáveis.</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id18"></span><h3 class="translated"><span class="section-number">3.4.2. </span>Objetos corrotina<a class="headerlink" href="#coroutine-objects" title="Link para este cabeçalho">¶</a></h3>
<p class="translated"><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Objetos corrotina</span></a> são objetos <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardáveis</span></a>. A execução de uma corrotina pode ser controlada chamando <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> e iterando sobre o resultado. Quando a corrotina termina a execução e retorna, o iterador levanta <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, e o atributo <a class="reference internal" href="../library/exceptions.html#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> da exceção contém o valor de retorno. Se a corrotina levantar uma exceção, ela será propagada pelo iterador. As corrotinas não devem levantar exceções <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> diretamente não tratadas.</p>
<p class="translated">As corrotinas também têm os métodos listados abaixo, que são análogos aos dos geradores (ver <a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">Métodos de iterador gerador</span></a>). No entanto, ao contrário dos geradores, as corrotinas não suportam diretamente a iteração.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5.2: </span>É uma <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> para aguardar uma corrotina mais de uma vez.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coroutine.send">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Inicia ou retoma a execução da corrotina. Se <em>value</em> for <code class="docutils literal notranslate"><span class="pre">None</span></code>, isso equivale a avançar o iterador retornado por <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Se <em>value</em> não for <code class="docutils literal notranslate"><span class="pre">None</span></code>, este método delega para o método <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> do iterador que causou a suspensão da corrotina. O resultado (valor de retorno, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ou outra exceção) é o mesmo de iterar sobre o valor de retorno <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code>, descrito acima.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.throw">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">Levanta a exceção especificada na corrotina. Este método delega ao método <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> do iterador que causou a suspensão da corrotina, se ela tiver tal método. Caso contrário, a exceção é levantada no ponto de suspensão. O resultado (valor de retorno, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ou outra exceção) é o mesmo de iterar sobre o valor de retorno <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>, descrito acima. Se a exceção não for capturada na corrotina, ela se propagará de volta para o chamador.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span>A segunda assinatura (tipo[, valor[, traceback]]) foi descontinuada e pode ser removida em uma versão futura do Python.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.close">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Faz com que a corrotina se limpe e saia. Se a corrotina for suspensa, este método primeiro delega para o método <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> do iterador que causou a suspensão da corrotina, se tiver tal método. Então ele levanta <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> no ponto de suspensão, fazendo com que a corrotina se limpe imediatamente. Por fim, a corrotina é marcada como tendo sua execução concluída, mesmo que nunca tenha sido iniciada.</p>
<p class="translated">Objetos corrotina são fechados automaticamente usando o processo acima quando estão prestes a ser destruídos.</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3 class="translated"><span class="section-number">3.4.3. </span>Iteradores assíncronos<a class="headerlink" href="#asynchronous-iterators" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Um <em>iterador assíncrono</em> pode chamar código assíncrono em seu método <code class="docutils literal notranslate"><span class="pre">__anext__</span></code>.</p>
<p class="translated">Os iteradores assíncronos podem ser usados em uma instrução <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p class="translated">A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não fornece estes métodos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aiter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aiter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Deve retornar um objeto <em>iterador assíncrono</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__anext__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Deve retornar um <em>aguardável</em> resultando em um próximo valor do iterador. Deve levantar um erro <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> quando a iteração terminar.</p>
</dd></dl>

<p class="translated">Um exemplo de objeto iterável assíncrono:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Antes do Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> poderia retornar um <em>aguardável</em> que resolveria para um <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a>.</p>
<p class="translated">A partir do Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> deve retornar um objeto iterador assíncrono. Retornar qualquer outra coisa resultará em um erro <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3 class="translated"><span class="section-number">3.4.4. </span>Gerenciadores de contexto assíncronos<a class="headerlink" href="#asynchronous-context-managers" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Um <em>gerenciador de contexto assíncrono</em> é um <em>gerenciador de contexto</em> que é capaz de suspender a execução em seus métodos <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> e <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>.</p>
<p class="translated">Os gerenciadores de contexto assíncronos podem ser usados em uma instrução <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
<p class="translated">A classe <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> em si não fornece estes métodos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aenter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aenter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Semanticamente semelhante a <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, a única diferença é que ele deve retornar um <em>aguardável</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__aexit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aexit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Semanticamente semelhante a <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, a única diferença é que ele deve retornar um <em>aguardável</em>.</p>
</dd></dl>

<p class="translated">Um exemplo de uma classe gerenciadora de contexto assíncrona:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entrando no contexto&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;saindo do contexto&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5.</span></p>
</div>
<p class="translated rubric">Notas de rodapé</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p class="translated">Em alguns casos, <em>é</em> possível alterar o tipo de um objeto, sob certas condições controladas. No entanto, geralmente não é uma boa ideia, pois pode levar a um comportamento muito estranho se for tratado incorretamente.</p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">2</a><span class="fn-bracket">]</span></span>
<p class="translated">Os métodos <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> e <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> e <a class="reference internal" href="../library/os.html#os.PathLike.__fspath__" title="os.PathLike.__fspath__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__fspath__()</span></code></a> têm um tratamento especial para isso. Outros ainda irão levantar um <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, mas podem fazer isso contando com o comportamento de que <code class="docutils literal notranslate"><span class="pre">None</span></code> não é chamável.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">3</a><span class="fn-bracket">]</span></span>
<p class="translated">“Não suportar” aqui significa que a classe não possui tal método, ou o método retorna <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>. Não defina o método como <code class="docutils literal notranslate"><span class="pre">None</span></code> se quiser forçar o fallback para o método refletido do operando correto – isso terá o efeito oposto de <em>bloquear</em> explicitamente esse fallback.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">4</a><span class="fn-bracket">]</span></span>
<p class="translated">Para operandos do mesmo tipo, presume-se que se o método não refletido – como <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> – falhar, a operação geral não será suportada, razão pela qual o método refletido não é chamado.</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">3. Modelo de dados</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores e tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. A hierarquia de tipos padrão</a><ul>
<li><a class="reference internal" href="#none">3.2.1. None</a></li>
<li><a class="reference internal" href="#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="#ellipsis">3.2.3. Ellipsis</a></li>
<li><a class="reference internal" href="#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences">3.2.5. Sequências</a><ul>
<li><a class="reference internal" href="#immutable-sequences">3.2.5.1. Sequências imutáveis</a></li>
<li><a class="reference internal" href="#mutable-sequences">3.2.5.2. Sequências mutáveis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types">3.2.6. Tipos de conjuntos</a></li>
<li><a class="reference internal" href="#mappings">3.2.7. Mapeamentos</a><ul>
<li><a class="reference internal" href="#dictionaries">3.2.7.1. Dicionários</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callable-types">3.2.8. Tipos chamáveis</a><ul>
<li><a class="reference internal" href="#user-defined-functions">3.2.8.1. Funções definidas pelo usuário</a><ul>
<li><a class="reference internal" href="#special-read-only-attributes">3.2.8.1.1. Atributos especiais de somente leitura</a></li>
<li><a class="reference internal" href="#special-writable-attributes">3.2.8.1.2. Atributos especiais graváveis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instance-methods">3.2.8.2. Métodos de instância</a></li>
<li><a class="reference internal" href="#generator-functions">3.2.8.3. Funções geradoras</a></li>
<li><a class="reference internal" href="#coroutine-functions">3.2.8.4. Funções de corrotina</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">3.2.8.5. Funções geradoras assíncronas</a></li>
<li><a class="reference internal" href="#built-in-functions">3.2.8.6. Funções embutidas</a></li>
<li><a class="reference internal" href="#built-in-methods">3.2.8.7. Métodos embutidos</a></li>
<li><a class="reference internal" href="#classes">3.2.8.8. Classes</a></li>
<li><a class="reference internal" href="#class-instances">3.2.8.9. Instâncias de classe</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">3.2.9. Módulos</a><ul>
<li><a class="reference internal" href="#import-related-attributes-on-module-objects">3.2.9.1. Atributos relacionados à importação em objetos de módulo</a></li>
<li><a class="reference internal" href="#other-writable-attributes-on-module-objects">3.2.9.2. Outros atributos graváveis em objetos de módulo</a></li>
<li><a class="reference internal" href="#module-dictionaries">3.2.9.3. Dicionários do módulo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-classes">3.2.10. Classes personalizadas</a><ul>
<li><a class="reference internal" href="#special-attributes">3.2.10.1. Atributos especiais</a></li>
<li><a class="reference internal" href="#special-methods">3.2.10.2. Métodos especiais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">3.2.11. Instâncias de classe</a><ul>
<li><a class="reference internal" href="#id5">3.2.11.1. Atributos especiais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-o-objects-also-known-as-file-objects">3.2.12. Objetos de E/S (também conhecidos como objetos arquivo)</a></li>
<li><a class="reference internal" href="#internal-types">3.2.13. Tipos internos</a><ul>
<li><a class="reference internal" href="#code-objects">3.2.13.1. Objetos código</a><ul>
<li><a class="reference internal" href="#index-60">3.2.13.1.1. Atributos especiais de somente leitura</a></li>
<li><a class="reference internal" href="#methods-on-code-objects">3.2.13.1.2. Métodos de objetos código</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frame-objects">3.2.13.2. Objetos quadro</a><ul>
<li><a class="reference internal" href="#index-66">3.2.13.2.1. Atributos especiais de somente leitura</a></li>
<li><a class="reference internal" href="#index-67">3.2.13.2.2. Atributos especiais graváveis</a></li>
<li><a class="reference internal" href="#frame-object-methods">3.2.13.2.3. Métodos de objetos quadro</a></li>
</ul>
</li>
<li><a class="reference internal" href="#traceback-objects">3.2.13.3. Objetos traceback</a></li>
<li><a class="reference internal" href="#slice-objects">3.2.13.4. Objetos slice</a></li>
<li><a class="reference internal" href="#static-method-objects">3.2.13.5. Objetos método estático</a></li>
<li><a class="reference internal" href="#class-method-objects">3.2.13.6. Objetos método de classe</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#special-method-names">3.3. Nomes de métodos especiais</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalização básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando o acesso aos atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acesso a atributos de módulos</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando descritores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando descritores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalizando a criação de classe</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclasses</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolvendo entradas de MRO</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando a metaclasse apropriada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando o espaço de nomes da classe</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Executando o corpo da classe</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Criando o objeto classe</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando verificações de instância e subclasse</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. O propósito de <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos chamáveis</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando tipos contêineres</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gerenciadores de contexto da instrução with</a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Customizando argumentos posicionais na classe correspondência de padrão</a></li>
<li><a class="reference internal" href="#emulating-buffer-types">3.3.11. Emulando tipos buffer</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.12. Pesquisa de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrotinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos aguardáveis</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos corrotina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores assíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gerenciadores de contexto assíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="capítulo anterior"><span class="section-number">2. </span>Análise léxica</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="próximo capítulo"><span class="section-number">4. </span>Modelo de execução</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de execução"
             >próximo</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análise léxica"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de dados</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>