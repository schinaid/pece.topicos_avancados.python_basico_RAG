<!DOCTYPE html>

<html lang="pt-BR" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="6. Expressões" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/expressions.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Este capítulo explica o significado dos elementos das expressões em Python. Notas de sintaxe: Neste e nos capítulos seguintes, a notação BNF estendida será usada para descrever a sintaxe, não a aná..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_reference_expressions_a1494817.png" />
<meta property="og:image:alt" content="Este capítulo explica o significado dos elementos das expressões em Python. Notas de sintaxe: Neste e nos capítulos seguintes, a notação BNF estendida será usada para descrever a sintaxe, não a aná..." />
<meta name="description" content="Este capítulo explica o significado dos elementos das expressões em Python. Notas de sintaxe: Neste e nos capítulos seguintes, a notação BNF estendida será usada para descrever a sintaxe, não a aná..." />
<meta name="twitter:card" content="summary_large_image" />

    <title>6. Expressões &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=62a4a58b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=71a39b36"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="7. Instruções simples" href="simple_stmts.html" />
    <link rel="prev" title="5. O sistema de importação" href="import.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/reference/expressions.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. Expressões</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. Conversões aritméticas</a></li>
<li><a class="reference internal" href="#atoms">6.2. Átomos</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. Identificadores (Nomes)</a><ul>
<li><a class="reference internal" href="#index-5">6.2.1.1. Desfiguração de nome privado</a></li>
</ul>
</li>
<li><a class="reference internal" href="#literals">6.2.2. Literais</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. Formas de parênteses</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. Sintaxe de criação de listas, conjuntos e dicionários</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. Sintaxes de criação de lista</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. Sintaxes de criação de conjunto</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. Sintaxes de criação de dicionário</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. Expressões geradoras</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Expressões yield</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. Métodos de iterador gerador</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. Exemplos</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. Funções geradoras assíncronas</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Métodos geradores-iteradores assíncronos</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. Primárias</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. Referências de atributo</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. Subscrições</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. Fatiamentos</a></li>
<li><a class="reference internal" href="#calls">6.3.4. Chamadas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Expressão await</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. O operador de potência</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. Operações aritméticas unárias e bit a bit</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. Operações binárias aritméticas</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. Operações de deslocamento</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. Operações binárias bit a bit</a></li>
<li><a class="reference internal" href="#comparisons">6.10. Comparações</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. Comparações de valor</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. Operações de teste de pertinência</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. Comparações de identidade</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. Operações booleanas</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. Expressões de atribuição</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. Expressões condicionais</a></li>
<li><a class="reference internal" href="#lambda">6.14. Lambdas</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. Listas de expressões</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. Ordem de avaliação</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. Precedência de operadores</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="import.html"
                          title="capítulo anterior"><span class="section-number">5. </span>O sistema de importação</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="próximo capítulo"><span class="section-number">7. </span>Instruções simples</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. Instruções simples"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. O sistema de importação"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Expressões</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="expressions">
<span id="id1"></span><h1 class="translated"><span class="section-number">6. </span>Expressões<a class="headerlink" href="#expressions" title="Link para este cabeçalho">¶</a></h1>
<p class="translated" id="index-0">Este capítulo explica o significado dos elementos das expressões em Python.</p>
<p class="translated"><strong>Notas de sintaxe:</strong> Neste e nos capítulos seguintes, a notação BNF estendida será usada para descrever a sintaxe, não a análise lexical. Quando (uma alternativa de) uma regra de sintaxe tem a forma</p>
<pre>
<strong id="grammar-token-python-grammar-name">name</strong> ::= othername
</pre>
<p class="translated">e nenhuma semântica é fornecida, a semântica desta forma de <code class="docutils literal notranslate"><span class="pre">name</span></code> é a mesma que para <code class="docutils literal notranslate"><span class="pre">othername</span></code>.</p>
<section id="arithmetic-conversions">
<span id="conversions"></span><h2 class="translated"><span class="section-number">6.1. </span>Conversões aritméticas<a class="headerlink" href="#arithmetic-conversions" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-1">Quando uma descrição de um operador aritmético abaixo usa a frase “os argumentos numéricos são convertidos em um tipo comum”, isso significa que a implementação do operador para tipos embutidos funciona da seguinte maneira:</p>
<ul class="simple">
<li><p class="translated">Se um dos argumentos for um número complexo, o outro será convertido em complexo;</p></li>
<li><p class="translated">caso contrário, se um dos argumentos for um número de ponto flutuante, o outro será convertido em ponto flutuante;</p></li>
<li><p class="translated">caso contrário, ambos devem ser inteiros e nenhuma conversão é necessária.</p></li>
</ul>
<p class="translated">Algumas regras adicionais se aplicam a certos operadores (por exemplo, uma string como um argumento à esquerda para o operador ‘%’). As extensões devem definir seu próprio comportamento de conversão.</p>
</section>
<section id="atoms">
<span id="id2"></span><h2 class="translated"><span class="section-number">6.2. </span>Átomos<a class="headerlink" href="#atoms" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-2">Os átomos são os elementos mais básicos das expressões. Os átomos mais simples são identificadores ou literais. As formas entre parênteses, colchetes ou chaves também são categorizadas sintaticamente como átomos. A sintaxe para átomos é:</p>
<pre>
<strong id="grammar-token-python-grammar-atom">atom</strong>      ::= <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-python-grammar-enclosure">enclosure</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-parenth_form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-list_display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-set_display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
              | <a class="reference internal" href="#grammar-token-python-grammar-generator_expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-yield_atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<section id="atom-identifiers">
<span id="identifiers-names"></span><h3 class="translated"><span class="section-number">6.2.1. </span>Identificadores (Nomes)<a class="headerlink" href="#atom-identifiers" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-3">Um identificador que ocorre como um átomo é um nome. Veja a seção <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">Identificadores e palavras-chave</span></a> para a definição lexical e a seção <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">Nomeação e ligação</span></a> para documentação de nomenclatura e ligação.</p>
<p class="translated" id="index-4">Quando o nome está vinculado a um objeto, a avaliação do átomo produz esse objeto. Quando um nome não está vinculado, uma tentativa de avaliá-lo levanta uma exceção <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>.</p>
<section id="index-5">
<span id="private-name-mangling"></span><span id="id3"></span><h4 class="translated"><span class="section-number">6.2.1.1. </span>Desfiguração de nome privado<a class="headerlink" href="#index-5" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Quando um identificador que ocorre textualmente em uma definição de classe começa com dois ou mais caracteres de sublinhado e não termina com dois ou mais sublinhados, ele é considerado um <em class="dfn">nome privado</em> daquela classe.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<p class="translated">As <a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">especificações de classe</span></a>.</p>
</div>
<p class="translated">Mais precisamente, os nomes privados são transformados em um formato mais longo antes que o código seja gerado para eles. Se o nome transformado tiver mais de 255 caracteres, poderá ocorrer truncamento definido pela implementação.</p>
<p class="translated">A transformação é independente do contexto sintático no qual o identificador é usado, mas apenas os seguintes identificadores privados são desfigurados:</p>
<ul>
<li><p class="translated">Qualquer nome usado como nome de uma variável que é atribuída ou lida ou qualquer nome de um atributo que está sendo acessado.</p>
<p class="translated">O atributo <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> de funções aninhadas, classes e apelidos de tipo, entretanto, não é desfigurado.</p>
</li>
<li><p class="translated">O nome dos módulos importados, por exemplo, <code class="docutils literal notranslate"><span class="pre">__spam</span></code> em <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__spam</span></code>. Se o módulo faz parte de um pacote (ou seja, seu nome contém um ponto), o nome <em>não</em> é desfigurado, por exemplo, o <code class="docutils literal notranslate"><span class="pre">__foo</span></code> em <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__foo.bar</span></code> não é desfigurado.</p></li>
<li><p class="translated">O nome de um membro importado, por exemplo, <code class="docutils literal notranslate"><span class="pre">__f</span></code> em <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">spam</span> <span class="pre">import</span> <span class="pre">__f</span></code>.</p></li>
</ul>
<p class="translated">A regra de transformação está definida da seguinte forma:</p>
<ul class="simple">
<li><p class="translated">O nome da classe, com os sublinhados iniciais removidos e um único sublinhado inicial inserido, é inserido na frente do identificador, por exemplo, o identificador <code class="docutils literal notranslate"><span class="pre">__spam</span></code> ocorrendo em uma classe chamada <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, <code class="docutils literal notranslate"><span class="pre">_Foo</span></code> ou <code class="docutils literal notranslate"><span class="pre">__Foo</span></code> é transformado em <code class="docutils literal notranslate"><span class="pre">_Foo__spam</span></code>.</p></li>
<li><p class="translated">Se o nome da classe consiste apenas em sublinhados, a transformação é a identidade, por exemplo, o identificador <code class="docutils literal notranslate"><span class="pre">__spam</span></code> que ocorre em uma classe chamada <code class="docutils literal notranslate"><span class="pre">_</span></code> ou <code class="docutils literal notranslate"><span class="pre">__</span></code> é deixado como está.</p></li>
</ul>
</section>
</section>
<section id="literals">
<span id="atom-literals"></span><h3 class="translated"><span class="section-number">6.2.2. </span>Literais<a class="headerlink" href="#literals" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-6">Python oferece suporte a strings e bytes literais e vários literais numéricos:</p>
<pre>
<strong id="grammar-token-python-grammar-literal">literal</strong> ::= <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
            | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p class="translated">A avaliação de um literal produz um objeto do tipo fornecido (string, bytes, inteiro, número de ponto flutuante, número complexo) com o valor fornecido. O valor pode ser aproximado no caso de ponto flutuante e literais imaginários (complexos). Veja a seção <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">Literais</span></a> para detalhes.</p>
<p class="translated" id="index-7">Todos os literais correspondem a tipos de dados imutáveis e, portanto, a identidade do objeto é menos importante que seu valor. Múltiplas avaliações de literais com o mesmo valor (seja a mesma ocorrência no texto do programa ou uma ocorrência diferente) podem obter o mesmo objeto ou um objeto diferente com o mesmo valor.</p>
</section>
<section id="parenthesized-forms">
<span id="parenthesized"></span><h3 class="translated"><span class="section-number">6.2.3. </span>Formas de parênteses<a class="headerlink" href="#parenthesized-forms" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-8">Um forma entre parênteses é uma lista de expressões opcional entre parênteses:</p>
<pre>
<strong id="grammar-token-python-grammar-parenth_form">parenth_form</strong> ::= &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p class="translated">Uma lista de expressões entre parênteses produz tudo o que aquela lista de expressões produz: se a lista contiver pelo menos uma vírgula, ela produzirá uma tupla; caso contrário, produz a única expressão que compõe a lista de expressões.</p>
<p class="translated" id="index-9">Um par de parênteses vazio produz um objeto tupla vazio. Como as tuplas são imutáveis, aplicam-se as mesmas regras dos literais (isto é, duas ocorrências da tupla vazia podem ou não produzir o mesmo objeto).</p>
<p class="translated" id="index-10">Observe que as tuplas não são formadas pelos parênteses, mas sim pelo uso da vírgula. A exceção é a tupla vazia, para a qual os parênteses <em>são</em> obrigatórios – permitir “nada” sem parênteses em expressões causaria ambiguidades e permitiria que erros de digitação comuns passassem sem serem detectados.</p>
</section>
<section id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3 class="translated"><span class="section-number">6.2.4. </span>Sintaxe de criação de listas, conjuntos e dicionários<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-11">Para construir uma lista, um conjunto ou um dicionário, o Python fornece uma sintaxe especial chamada “sintaxes de criação” (em inglês, <em>displays</em>), cada uma delas em dois tipos:</p>
<ul class="simple">
<li><p class="translated">o conteúdo do contêiner é listado explicitamente ou</p></li>
<li><p class="translated">eles são calculados por meio de um conjunto de instruções de laço e filtragem, chamado de <em class="dfn">compreensão</em>.</p></li>
</ul>
<p class="translated" id="index-12">Elementos de sintaxe comuns para compreensões são:</p>
<pre>
<strong id="grammar-token-python-grammar-comprehension">comprehension</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-python-grammar-comp_for">comp_for</strong>      ::= [&quot;async&quot;] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-python-grammar-comp_iter">comp_iter</strong>     ::= <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comp_if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-python-grammar-comp_if">comp_if</strong>       ::= &quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p class="translated">A compreensão consiste em uma única expressão seguida por pelo menos uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> e zero ou mais cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code>. Neste caso, os elementos do novo contêiner são aqueles que seriam produzidos considerando cada uma das cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> de um bloco, aninhando da esquerda para a direita, e avaliando a expressão para produzir um elemento cada vez que o bloco mais interno é alcançado.</p>
<p class="translated">No entanto, além da expressão iterável na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> mais à esquerda, a compreensão é executada em um escopo aninhado implicitamente separado. Isso garante que os nomes atribuídos na lista de destino não “vazem” para o escopo delimitador.</p>
<p class="translated">A expressão iterável na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> mais à esquerda é avaliada diretamente no escopo envolvente e então passada como um argumento para o escopo aninhado implicitamente. Cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> subsequentes e qualquer condição de filtro na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> mais à esquerda não podem ser avaliadas no escopo delimitador, pois podem depender dos valores obtidos do iterável mais à esquerda. Por exemplo: <code class="docutils literal notranslate"><span class="pre">[x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10)]</span></code>.</p>
<p class="translated">Para garantir que a compreensão sempre resulte em um contêiner do tipo apropriado, as expressões <code class="docutils literal notranslate"><span class="pre">yield</span></code> e <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> são proibidas no escopo aninhado implicitamente.</p>
<p class="translated" id="index-13">Desde o Python 3.6, em uma função <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> pode ser usada para iterar sobre um <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a>. Uma compreensão em uma função <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> pode consistir em uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> seguindo a expressão inicial, pode conter <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> adicional ou <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> e também pode usar expressões <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>.</p>
<p class="translated">Se uma compreensão contém cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>, ou se contém expressões <code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code> ou outras compreensões assíncronas em qualquer lugar, exceto a expressão iterável na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> mais à esquerda, ela é chamada uma <em class="dfn">compreensão assíncrona</em>. Uma compreensão assíncrona pode suspender a execução da função de corrotina em que aparece. Veja também a <span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0530/"><strong>PEP 530</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.6: </span>Compreensões assíncronas foram introduzidas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> e <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> proibidos no escopo aninhado implícito.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.11: </span>Compreensões assíncronas agora são permitidas dentro de compreensões em funções assíncronas. As compreensões externas tornam-se implicitamente assíncronas.</p>
</div>
</section>
<section id="list-displays">
<span id="lists"></span><h3 class="translated"><span class="section-number">6.2.5. </span>Sintaxes de criação de lista<a class="headerlink" href="#list-displays" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-15">Uma sintaxe de criação de lista é uma série possivelmente vazia de expressões entre colchetes:</p>
<pre>
<strong id="grammar-token-python-grammar-list_display">list_display</strong> ::= &quot;[&quot; [<a class="reference internal" href="#grammar-token-python-grammar-flexible_expression_list"><code class="xref docutils literal notranslate"><span class="pre">flexible_expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p class="translated">Uma sintaxe de criação de lista produz um novo objeto de lista, sendo o conteúdo especificado por uma lista de expressões ou uma compreensão. Quando uma lista de expressões separadas por vírgulas é fornecida, seus elementos são avaliados da esquerda para a direita e colocados no objeto de lista nessa ordem. Quando uma compreensão é fornecida, a lista é construída a partir dos elementos resultantes da compreensão.</p>
</section>
<section id="set-displays">
<span id="set"></span><h3 class="translated"><span class="section-number">6.2.6. </span>Sintaxes de criação de conjunto<a class="headerlink" href="#set-displays" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-16">Uma sintaxe de criação definida é denotada por chaves e distinguível de sintaxes de criação de dicionário pela falta de caractere de dois pontos separando chaves e valores:</p>
<pre>
<strong id="grammar-token-python-grammar-set_display">set_display</strong> ::= &quot;{&quot; (<a class="reference internal" href="#grammar-token-python-grammar-flexible_expression_list"><code class="xref docutils literal notranslate"><span class="pre">flexible_expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p class="translated">Uma sintaxe de criação de conjunto produz um novo objeto de conjunto mutável, sendo o conteúdo especificado por uma sequência de expressões ou uma compreensão. Quando uma lista de expressões separadas por vírgula é fornecida, seus elementos são avaliados da esquerda para a direita e adicionados ao objeto definido. Quando uma compreensão é fornecida, o conjunto é construído a partir dos elementos resultantes da compreensão.</p>
<p class="translated">Um conjunto vazio não pode ser construído com <code class="docutils literal notranslate"><span class="pre">{}</span></code>; este literal constrói um dicionário vazio.</p>
</section>
<section id="dictionary-displays">
<span id="dict"></span><h3 class="translated"><span class="section-number">6.2.7. </span>Sintaxes de criação de dicionário<a class="headerlink" href="#dictionary-displays" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-17">Uma sintaxe de criação de dicionário é uma série possivelmente vazia de itens de dicionário (pares chave/valor) envolto entre chaves:</p>
<pre>
<strong id="grammar-token-python-grammar-dict_display">dict_display</strong>       ::= &quot;{&quot; [<a class="reference internal" href="#grammar-token-python-grammar-dict_item_list"><code class="xref docutils literal notranslate"><span class="pre">dict_item_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-python-grammar-dict_item_list">dict_item_list</strong>     ::= <a class="reference internal" href="#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-dict_item">dict_item</strong>          ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-python-grammar-dict_comprehension">dict_comprehension</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p class="translated">Uma sintaxe de criação de dicionário produz um novo objeto dicionário.</p>
<p class="translated">Se for fornecida uma sequência separada por vírgulas de itens de dicionário, eles são avaliados da esquerda para a direita para definir as entradas do dicionário: cada objeto chave é usado como uma chave no dicionário para armazenar o valor correspondente. Isso significa que você pode especificar a mesma chave várias vezes na lista de itens de dicionário, e o valor final do dicionário para essa chave será o último dado.</p>
<p class="translated" id="index-18">Um asterisco duplo <code class="docutils literal notranslate"><span class="pre">**</span></code> denota <em class="dfn">desempacotamento do dicionário</em>. Seu operando deve ser um <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapeamento</span></a>. Cada item de mapeamento é adicionado ao novo dicionário. Os valores posteriores substituem os valores já definidos por itens de dicionário anteriores e desempacotamentos de dicionário anteriores.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5: </span>Desempacotando em sintaxes de criação de dicionário, originalmente proposto pela <span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p class="translated">Uma compreensão de dict, em contraste com as compreensões de lista e conjunto, precisa de duas expressões separadas por dois pontos, seguidas pelas cláusulas usuais “for” e “if”. Quando a compreensão é executada, os elementos chave e valor resultantes são inseridos no novo dicionário na ordem em que são produzidos.</p>
<p class="translated" id="index-20">Restrições nos tipos de valores de chave são listadas anteriormente na seção <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">A hierarquia de tipos padrão</span></a>. (Para resumir, o tipo de chave deve ser <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hasheável</span></a>, que exclui todos os objetos mutáveis.) Não são detectadas colisões entre chaves duplicadas; o último valor (textualmente mais à direita na sintaxe de criação) armazenado para um determinado valor de chave prevalece.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Antes do Python 3.8, em compreensões de dict, a ordem de avaliação de chave e valor não era bem definida. No CPython, o valor foi avaliado antes da chave. A partir de 3.8, a chave é avaliada antes do valor, conforme proposto pela <span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a>.</p>
</div>
</section>
<section id="generator-expressions">
<span id="genexpr"></span><h3 class="translated"><span class="section-number">6.2.8. </span>Expressões geradoras<a class="headerlink" href="#generator-expressions" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-22">Uma expressão geradora é uma notação geradora compacta entre parênteses:</p>
<pre>
<strong id="grammar-token-python-grammar-generator_expression">generator_expression</strong> ::= &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p class="translated">Uma expressão geradora produz um novo objeto gerador. Sua sintaxe é a mesma das compreensões, exceto pelo fato de estar entre parênteses em vez de colchetes ou chaves.</p>
<p class="translated">As variáveis usadas na expressão geradora são avaliadas lentamente quando o método <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> é chamado para o objeto gerador (da mesma forma que os geradores normais). No entanto, a expressão iterável na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> mais à esquerda é avaliada imediatamente e o <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a> é imediatamente criado para aquele iterável, de modo que um erro produzido enquanto cria o iterador será emitido no ponto em que a expressão geradora é definida, em vez de no ponto em que o primeiro valor é recuperado. Cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> subsequentes e qualquer condição de filtro na cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> mais à esquerda não podem ser avaliadas no escopo delimitador, pois podem depender dos valores obtidos do iterável mais à esquerda. Por exemplo: <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10))</span></code>.</p>
<p class="translated">Os parênteses podem ser omitidos em chamadas com apenas um argumento. Veja a seção <a class="reference internal" href="#calls"><span class="std std-ref">Chamadas</span></a> para detalhes.</p>
<p class="translated">Para evitar interferir com a operação esperada da própria expressão geradora, as expressões <code class="docutils literal notranslate"><span class="pre">yield</span></code> e <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> são proibidas no gerador definido implicitamente.</p>
<p class="translated">Se uma expressão geradora contém cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> ou expressões <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, ela é chamada de <em class="dfn">expressão geradora assíncrona</em>. Uma expressão geradora assíncrona retorna um novo objeto gerador assíncrono, que é um iterador assíncrono (consulte <a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">Iteradores assíncronos</span></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.6: </span>Expressões geradoras assíncronas foram introduzidas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.7: </span>Antes do Python 3.7, as expressões geradoras assíncronas só podiam aparecer em corrotinas <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. A partir da versão 3.7, qualquer função pode usar expressões geradoras assíncronas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> e <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> proibidos no escopo aninhado implícito.</p>
</div>
</section>
<section id="yield-expressions">
<span id="yieldexpr"></span><h3 class="translated"><span class="section-number">6.2.9. </span>Expressões yield<a class="headerlink" href="#yield-expressions" title="Link para este cabeçalho">¶</a></h3>
<pre id="index-23">
<strong id="grammar-token-python-grammar-yield_atom">yield_atom</strong>       ::= &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-python-grammar-yield_from">yield_from</strong>       ::= &quot;yield&quot; &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-yield_expression">yield_expression</strong> ::= &quot;yield&quot; <a class="reference internal" href="#grammar-token-python-grammar-yield_list"><code class="xref docutils literal notranslate"><span class="pre">yield_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-yield_from"><code class="xref docutils literal notranslate"><span class="pre">yield_from</span></code></a>
</pre>
<p class="translated">A expressão yield é usada ao definir uma função <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generadora</span></a> ou uma função <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">geradora assíncrona</span></a> e, portanto, só pode ser usada no corpo de uma definição de função. Usar uma expressão yield no corpo de uma função faz com que essa função seja uma função geradora, e usá-la no corpo de uma função <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> faz com que essa função de corrotina seja uma função geradora assíncrona. Por exemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">():</span>  <span class="c1"># define uma função geradora</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">agen</span><span class="p">():</span> <span class="c1"># define uma função geradora assíncrona</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p class="translated">Devido a seus efeitos colaterais no escopo recipiente, as expressões <code class="docutils literal notranslate"><span class="pre">yield</span></code> não são permitidas como parte dos escopos definidos implicitamente usados para implementar compreensões e expressões geradoras.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.8: </span>Expressões yield proibidas nos escopos aninhados implicitamente usados para implementar compreensões e expressões geradoras.</p>
</div>
<p class="translated">As funções geradoras são descritas abaixo, enquanto as funções geradoras assíncronas são descritas separadamente na seção <a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">Funções geradoras assíncronas</span></a></p>
<p class="translated">Quando uma função geradora é chamada, ela retorna um iterador conhecido como gerador. Esse gerador então controla a execução da função geradora. A execução começa quando um dos métodos do gerador é chamado. Nesse momento, a execução segue para a primeira expressão yield, onde é suspensa novamente, retornando o valor de <a class="reference internal" href="#grammar-token-python-grammar-yield_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_list</span></code></a> ao chamador do gerador, ou <code class="docutils literal notranslate"><span class="pre">None</span></code> se <a class="reference internal" href="#grammar-token-python-grammar-yield_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_list</span></code></a> é omitido. Por suspenso, queremos dizer que todo o estado local é retido, incluindo as chamadas atuais de variáveis locais, o ponteiro de instrução, a pilha de avaliação interna e o estado de qualquer tratamento de exceção. Quando a execução é retomada chamando um dos métodos do gerador, a função pode prosseguir exatamente como se a expressão yield fosse apenas outra chamada externa. O valor da expressão yield após a retomada depende do método que retomou a execução. Se <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> for usado (tipicamente através de uma <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ou do <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> embutido) então o resultado será <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Caso contrário, se <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> for usado, o resultado será o valor passado para esse método.</p>
<p class="translated" id="index-24">Tudo isso torna as funções geradoras bastante semelhantes às corrotinas; cedem múltiplas vezes, possuem mais de um ponto de entrada e sua execução pode ser suspensa. A única diferença é que uma função geradora não pode controlar onde a execução deve continuar após o seu rendimento; o controle é sempre transferido para o chamador do gerador.</p>
<p class="translated">Expressões yield são permitidas em qualquer lugar em uma construção <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>. Se o gerador não for retomado antes de ser finalizado (ao atingir uma contagem de referências zero ou ao ser coletado como lixo), o método <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> do iterador de gerador será chamado, permitindo que quaisquer cláusulas <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> pendentes sejam executadas.</p>
<p class="translated" id="index-25">Quando <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> é usado, a expressão fornecida deve ser iterável. Os valores produzidos pela iteração desse iterável são passados diretamente para o chamador dos métodos do gerador atual. Quaisquer valores passados com <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> e quaisquer exceções passadas com <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> são passados para o iterador subjacente se ele tiver os métodos apropriados. Se este não for o caso, então <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> irá levantar <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> ou <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, enquanto <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> irá apenas levantar a exceção passada imediatamente.</p>
<p class="translated">Quando o iterador subjacente estiver completo, o atributo <a class="reference internal" href="../library/exceptions.html#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> da instância <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> gerada torna-se o valor da expressão yield. Ele pode ser definido explicitamente ao levantar <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ou automaticamente quando o subiterador é um gerador (retornando um valor do subgerador).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.3: </span>Adicionado <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> para delegar o fluxo de controle a um subiterador.</p>
</div>
<p class="translated">Os parênteses podem ser omitidos quando a expressão yield é a única expressão no lado direito de uma instrução de atribuição.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver também</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - Simple Generators</dt><dd><p class="translated">A proposta para adicionar geradores e a instrução <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> ao Python.</p>
</dd>
<dt class="translated"><span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> - Corrotinas via Geradores Aprimorados</dt><dd><p class="translated">A proposta de aprimorar a API e a sintaxe dos geradores, tornando-os utilizáveis como simples corrotinas.</p>
</dd>
<dt class="translated"><span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0380/"><strong>PEP 380</strong></a> - Sintaxe para Delegar a um Subgerador</dt><dd><p class="translated">A proposta de introduzir a sintaxe <a class="reference internal" href="#grammar-token-python-grammar-yield_from"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code></a>, facilitando a delegação a subgeradores.</p>
</dd>
<dt class="translated"><span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> - Geradores assíncronos</dt><dd><p class="translated">A proposta que se expandiu em <span class="target" id="index-120"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> adicionando recursos de gerador a funções de corrotina.</p>
</dd>
</dl>
</div>
<section id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-31"></span><h4 class="translated"><span class="section-number">6.2.9.1. </span>Métodos de iterador gerador<a class="headerlink" href="#generator-iterator-methods" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Esta subseção descreve os métodos de um iterador gerador. Eles podem ser usados para controlar a execução de uma função geradora.</p>
<p class="translated">Observe que chamar qualquer um dos métodos do gerador abaixo quando o gerador já estiver em execução levanta uma exceção <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<dl class="py method" id="index-32">
<dt class="sig sig-object py" id="generator.__next__">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Inicia a execução de uma função geradora ou a retoma na última expressão yield executada. Quando uma função geradora é retomada com um método <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>, a expressão yield atual sempre é avaliada como <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. A execução então continua para a próxima expressão yield, onde o gerador é suspenso novamente, e o valor de <a class="reference internal" href="#grammar-token-python-grammar-yield_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_list</span></code></a> é retornado para o chamador de <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>. Se o gerador sair sem produzir outro valor, uma exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> será levantada.</p>
<p class="translated">Este método é normalmente chamado implicitamente, por exemplo por um laço <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>, ou pela função embutida <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.send">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retoma a execução e “envia” um valor para a função geradora. O argumento <em>value</em> torna-se o resultado da expressão yield atual. O método <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> retorna o próximo valor gerado pelo gerador, ou levanta <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> se o gerador sair sem produzir outro valor. Quando <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> é chamado para iniciar o gerador, ele deve ser chamado com <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> como argumento, porque não há nenhuma expressão yield que possa receber o valor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.throw">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">Levanta uma exceção no ponto em que o gerador foi pausado e retorna o próximo valor gerado pela função geradora. Se o gerador sair sem gerar outro valor, uma exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> será levantada. Se a função geradora não detectar a exceção passada ou levanta uma exceção diferente, essa exceção se propagará para o chamador.</p>
<p class="translated">Em uso típico, isso é chamado com uma única instância de exceção semelhante à forma como a palavra reservada <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> é usada.</p>
<p class="translated">Para compatibilidade com versões anteriores, no entanto, a segunda assinatura é suportada, seguindo uma convenção de versões mais antigas do Python. O argumento <em>type</em> deve ser uma classe de exceção e <em>value</em> deve ser uma instância de exceção. Se o <em>valor</em> não for fornecido, o construtor <em>tipo</em> será chamado para obter uma instância. Se <em>traceback</em> for fornecido, ele será definido na exceção, caso contrário, qualquer atributo <a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> existente armazenado em <em>value</em> poderá ser limpo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span>A segunda assinatura (tipo[, valor[, traceback]]) foi descontinuada e pode ser removida em uma versão futura do Python.</p>
</div>
</dd></dl>

<dl class="py method" id="index-33">
<dt class="sig sig-object py" id="generator.close">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Levanta uma exceção <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> no ponto onde a função geradora foi pausada (equivalente a chamar <code class="docutils literal notranslate"><span class="pre">throw(GeneratorExit)</span></code>) A exceção é levantada pela expressão yield onde o gerador foi pausado. Se a função geradora captura a exceção, e retorna um valor, este valor é retornado de <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>. Se a função geradora já estiver fechada ou levantar <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (por não capturar a exceção), <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> retornará <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Se o gerador produzir um valor, uma exceção <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> é levantada. Se o gerador levantar qualquer outra exceção, ela será propagada para o chamador. Se o gerador já saiu devido a uma exceção ou saída normal, <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> retorna <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> e tem nenhum outro efeito.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.13: </span>Se um gerador retornar um valor ao ser fechado, o valor será retornado por <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="examples">
<span id="index-34"></span><h4 class="translated"><span class="section-number">6.2.9.2. </span>Exemplos<a class="headerlink" href="#examples" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Aqui está um exemplo simples que demonstra o comportamento de geradores e funções geradoras:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A execução inicia quando &#39;next()&#39; é chamada pela primeira vez.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Não se esqueça de fazer uma limpeza quando &#39;close()&#39; for chamada.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">A execução inicia quando &#39;next()&#39; é chamada pela primeira vez.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Não se esqueça de fazer uma limpeza quando &#39;close()&#39; for chamada.</span>
</pre></div>
</div>
<p class="translated">Para exemplos usando <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>, consulte a <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: Syntax for Delegating to a Subgenerator</span></a> em “O que há de novo no Python.”</p>
</section>
<section id="asynchronous-generator-functions">
<span id="id4"></span><h4 class="translated"><span class="section-number">6.2.9.3. </span>Funções geradoras assíncronas<a class="headerlink" href="#asynchronous-generator-functions" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">A presença de uma expressão yield em uma função ou método definido usando a <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> define ainda mais a função como uma função <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">geradora assíncrona</span></a>.</p>
<p class="translated">Quando uma função geradora assíncrona é chamada, ela retorna um iterador assíncrono conhecido como objeto gerador assíncrono. Esse objeto controla a execução da função geradora. Um objeto gerador assíncrono é normalmente usado em uma instrução <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> em uma função de corrotina de forma análoga a como um objeto gerador seria usado em uma instrução <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
<p class="translated">A chamada de um dos métodos do gerador assíncrono retorna um objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardável</span></a>, e a execução começa quando esse objeto é aguardado. Nesse momento, a execução prossegue até a primeira expressão yield, onde é suspensa novamente, retornando o valor de <a class="reference internal" href="#grammar-token-python-grammar-yield_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_list</span></code></a> para a corrotina em aguardo. Assim como ocorre com um gerador, a suspensão significa que todo o estado local é mantido, inclusive as ligações atuais das variáveis locais, o ponteiro de instruções, a pilha de avaliação interna e o estado de qualquer tratamento de exceção. Quando a execução é retomada, aguardando o próximo objeto retornado pelos métodos do gerador assíncrono, a função pode prosseguir exatamente como se a expressão de rendimento fosse apenas outra chamada externa. O valor da expressão yield após a retomada depende do método que retomou a execução.  Se <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> for usado, o resultado será <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Caso contrário, se <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> for usado, o resultado será o valor passado para esse método.</p>
<p class="translated">Se um gerador assíncrono encerrar mais cedo por <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, pela tarefa que fez sua chamada ser cancelada ou por outras exceções, o código de limpeza assíncrona do gerador será executado e possivelmente levantará alguma exceção ou acessará as variáveis de contexto em um contexto inesperado – talvez após o tempo de vida das tarefas das quais ele depende, ou durante o laço de eventos de encerramento quando o gancho de coleta de lixo do gerador assíncrono for chamado. Para prevenir isso, o chamador deve encerrar explicitamente o gerador assíncrono chamando o método <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> para finalizar o gerador e, por fim, desconectá-lo do laço de eventos.</p>
<p class="translated">Em uma função geradora assíncrona, expressões de yield são permitidas em qualquer lugar em uma construção <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>. No entanto, se um gerador assíncrono não for retomado antes de ser finalizado (alcançando uma contagem de referência zero ou sendo coletado pelo coletor de lixo), então uma expressão de yield dentro de um construção <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> pode resultar em uma falha na execução das cláusulas pendentes de <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>. Nesse caso, é responsabilidade do laço de eventos ou escalonador que executa o gerador assíncrono chamar o método <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> do gerador iterador assíncrono e executar o objeto corrotina resultante, permitindo assim que quaisquer cláusulas pendentes de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> sejam executadas.</p>
<p class="translated">Para cuidar da finalização após o término do laço de eventos, um laço de eventos deve definir uma função <em>finalizer</em> que recebe um gerador assíncrono e provavelmente chama <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> e executa a corrotina. Este <em>finalizer</em> pode ser registrado chamando <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>. Quando iterado pela primeira vez, um gerador assíncrono armazenará o <em>finalizer</em> registrado para ser chamado na finalização. Para um exemplo de referência de um método <em>finalizer</em>, consulte a implementação de <code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> em <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p class="translated">O expressão <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> é um erro de sintaxe quando usado em uma função geradora assíncrona.</p>
</section>
<section id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-35"></span><h4 class="translated"><span class="section-number">6.2.9.4. </span>Métodos geradores-iteradores assíncronos<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="Link para este cabeçalho">¶</a></h4>
<p class="translated">Esta subseção descreve os métodos de um iterador gerador assíncrono, que são usados para controlar a execução de uma função geradora.</p>
<dl class="py method" id="index-36">
<dt class="sig sig-object py" id="agen.__anext__">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna um objeto aguardável que, quando executado, começa a executar o gerador assíncrono ou o retoma na última expressão yield executada. Quando uma função geradora assíncrona é retomada com o método <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, a expressão yield atual sempre avalia para <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> no objeto aguardável retornado, que, quando executado, continuará para a próxima expressão yield. O valor de <a class="reference internal" href="#grammar-token-python-grammar-yield_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_list</span></code></a> da expressão yield é o valor da exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> levantada pela corrotina em conclusão. Se o gerador assíncrono sair sem produzir outro valor, o objeto aguardável em vez disso levanta uma exceção <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>, sinalizando que a iteração assíncrona foi concluída.</p>
<p class="translated">Este método é normalmente chamado implicitamente por um laço <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.asend">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">asend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna um objeto aguardável que, quando executado, retoma a execução do gerador assíncrono. Assim como o método <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> para um gerador, isso “envia” um valor para a função geradora assíncrona, e o argumento <em>value</em> se torna o resultado da expressão de yield atual. O objeto aguardável retornado pelo método <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> retornará o próximo valor produzido pelo gerador como o valor da exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> levantada, ou lança <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> se o gerador assíncrono sair sem produzir outro valor. Quando <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> é chamado para iniciar o gerador assíncrono, ele deve ser chamado com <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> como argumento, pois não há expressão yield que possa receber o valor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.athrow">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="Link para esta definição">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">Retorna um objeto aguardável que gera uma exceção do tipo <code class="docutils literal notranslate"><span class="pre">type</span></code> no ponto em que o gerador assíncrono foi pausado, e retorna o próximo valor produzido pela função geradora como o valor da exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> levantada. Se o gerador assíncrono terminar sem produzir outro valor, uma exceção <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> é levantada pelo objeto aguardável. Se a função geradora não capturar a exceção passada ou gerar uma exceção diferente, então quando o objeto aguardável for executado, essa exceção se propagará para o chamador do objeto aguardável.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.12: </span>A segunda assinatura (tipo[, valor[, traceback]]) foi descontinuada e pode ser removida em uma versão futura do Python.</p>
</div>
</dd></dl>

<dl class="py method" id="index-37">
<dt class="sig sig-object py" id="agen.aclose">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="Link para esta definição">¶</a></dt>
<dd><p class="translated">Retorna um objeto aguardável que, quando executado, levantará uma <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> na função geradora assíncrona no ponto em que foi pausada. Se a função geradora assíncrona sair de forma normal, se estiver já estiver fechada ou levantar <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (não capturando a exceção), então o objeto aguardável retornado levantará uma exceção <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>. Quaisquer outros objetos aguardáveis retornados por chamadas subsequentes à função geradora assíncrona levantarão uma exceção <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Se a função geradora assíncrona levantar um valor, um <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> será lançado pelo objeto aguardável. Se a função geradora assíncrona levantar qualquer outra exceção, ela será propagada para o chamador do objeto aguardável. Se a função geradora assíncrona já tiver saído devido a uma exceção ou saída normal, então chamadas posteriores ao método <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> retornarão um objeto aguardável que não faz nada.</p>
</dd></dl>

</section>
</section>
</section>
<section id="primaries">
<span id="id5"></span><h2 class="translated"><span class="section-number">6.3. </span>Primárias<a class="headerlink" href="#primaries" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-38">Primárias representam as operações mais fortemente vinculadas da linguagem. Sua sintaxe é:</p>
<pre>
<strong id="grammar-token-python-grammar-primary">primary</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<section id="attribute-references">
<span id="id6"></span><h3 class="translated"><span class="section-number">6.3.1. </span>Referências de atributo<a class="headerlink" href="#attribute-references" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-39">Uma referência de atributo é um primário seguido de um ponto e um nome.</p>
<pre>
<strong id="grammar-token-python-grammar-attributeref">attributeref</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p class="translated" id="index-40">A primária deve avaliar para um objeto de um tipo que tem suporte a referências de atributo, o que a maioria dos objetos faz. Este objeto é então solicitado a produzir o atributo cujo nome é o identificador. O tipo e o valor produzido são determinados pelo objeto. Várias avaliações da mesma referência de atributo podem produzir diferentes objetos.</p>
<p class="translated">Esta produção pode ser personalizada substituindo o método <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> ou o método <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>. O método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> é chamado primeiro e retorna um valor ou levanta uma <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> se o atributo não estiver disponível.</p>
<p class="translated">Se for levantada uma <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> e o objeto tiver um método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>, esse método será chamado como alternativa.</p>
</section>
<section id="subscriptions">
<span id="id7"></span><h3 class="translated"><span class="section-number">6.3.2. </span>Subscrições<a class="headerlink" href="#subscriptions" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-42"><span id="index-41"></span>A subscrição de uma instância de uma classe de <a class="reference internal" href="datamodel.html#sequence-types"><span class="std std-ref">classe de contêiner</span></a> geralmente selecionará um elemento do contêiner. A subscrição de uma <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">classe genérica</span></a> geralmente retornará um objeto <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a>.</p>
<pre>
<strong id="grammar-token-python-grammar-subscription">subscription</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-flexible_expression_list"><code class="xref docutils literal notranslate"><span class="pre">flexible_expression_list</span></code></a> &quot;]&quot;
</pre>
<p class="translated">Quando um objeto é subscrito, o interpretador avaliará o primário e a lista de expressões.</p>
<p class="translated">O primário deve ser avaliado como um objeto que dê suporte à subscrição. Um objeto pode prover suporte a subscrição através da definição de um ou ambos <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>. Quando o primário é subscrito, o resultado avaliado da lista de expressões será passado para um desses métodos. Para mais detalhes sobre quando <code class="docutils literal notranslate"><span class="pre">__class_getitem__</span></code> é chamado em vez de <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, veja <a class="reference internal" href="datamodel.html#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a>.</p>
<p class="translated">Se a lista de expressões contiver pelo menos uma vírgula ou  se alguma das expressões for estrelada, ela será avaliada como uma <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> contendo os itens da lista de expressões. Caso contrário, a lista de expressões será avaliada como o valor do único membro da lista.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.11: </span>Expressões em uma lista de expressões podem ser estreladas. Veja a <span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a>.</p>
</div>
<p class="translated">Para objetos embutido, existem dois tipos de objetos que oferecem suporte a subscrição via <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>:</p>
<ol class="arabic simple">
<li><p class="translated">Mapeamentos. Se o primário for um <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapeamento</span></a>, a lista de expressões deve ser avaliada como um objeto cujo valor é uma das chaves do mapeamento, e a subscrição seleciona o valor no mapeamento que corresponde a essa chave. Um exemplo de classe de mapeamento integrada é a classe <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.</p></li>
<li><p class="translated">Sequências. Se o primário for uma <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequência</span></a>, a lista de expressões deve ser avaliada como <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> ou <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> (conforme discutido na seção seguinte). Exemplos de classes de sequência embutidas incluem as classes <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
</ol>
<p class="translated">A sintaxe formal não faz nenhuma provisão especial para índices negativos em <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequências</span></a>. No entanto, todas as sequências embutidas fornecem um método <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> que interpreta índices negativos adicionando o comprimento da sequência ao índice para que, por exemplo, <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> selecione o último item de <code class="docutils literal notranslate"><span class="pre">x</span></code>. O valor resultante deve ser um número inteiro não negativo menor que o número de itens na sequência, e a subscrição seleciona o item cujo índice é esse valor (contando a partir de zero). Como o suporte para índices negativos e fatiamento ocorre no método <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> do objeto, as subclasses que substituem esse método precisarão adicionar explicitamente esse suporte.</p>
<p class="translated" id="index-44">Uma <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">string</span></code></a> é um tipo especial de sequência cujos itens são <em>caracteres</em>. Um caractere não é um tipo de dados separado, mas uma string de exatamente um caractere.</p>
</section>
<section id="slicings">
<span id="id8"></span><h3 class="translated"><span class="section-number">6.3.3. </span>Fatiamentos<a class="headerlink" href="#slicings" title="Link para este cabeçalho">¶</a></h3>
<p class="translated" id="index-46"><span id="index-45"></span>Um fatiamento seleciona um intervalo de itens em um objeto sequência (por exemplo, uma string, tupla ou lista). As fatias podem ser usadas como expressões ou como alvos em instruções de atribuição ou <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. A sintaxe para um fatiamento:</p>
<pre>
<strong id="grammar-token-python-grammar-slicing">slicing</strong>      ::= <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-python-grammar-slice_list">slice_list</strong>   ::= <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-slice_item">slice_item</strong>   ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-proper_slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-python-grammar-proper_slice">proper_slice</strong> ::= [<a class="reference internal" href="#grammar-token-python-grammar-lower_bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-upper_bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-python-grammar-lower_bound">lower_bound</strong>  ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-upper_bound">upper_bound</strong>  ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-stride">stride</strong>       ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p class="translated">Há ambiguidade na sintaxe formal aqui: qualquer coisa que se pareça com uma lista de expressões também se parece com uma lista de fatias, portanto qualquer subscrição pode ser interpretada como um fatiamento. Em vez de complicar ainda mais a sintaxe, isso é eliminado pela definição de que, neste caso, a interpretação como uma subscrição tem prioridade sobre a interpretação como um fatiamento (este é o caso se a lista de fatias não contiver uma fatia adequada).</p>
<p class="translated" id="index-47">A semântica para um fatiamento é a seguinte. O primário é indexado (usando o mesmo método <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> da subscrição normal) com uma chave que é construída a partir da lista de fatias, como segue. Se a lista de fatias contiver pelo menos uma vírgula, a chave será uma tupla contendo a conversão dos itens da fatia; caso contrário, a conversão do item de fatia isolada é a chave. A conversão de um item de fatia que é uma expressão é essa expressão. A conversão de uma fatia adequada é um objeto fatia (veja a seção <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">A hierarquia de tipos padrão</span></a>) cujos <a class="reference internal" href="../library/functions.html#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>, <a class="reference internal" href="../library/functions.html#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> e <a class="reference internal" href="../library/functions.html#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> atributos são os valores das expressões fornecidas como limite inferior, limite superior e passo, respectivamente, substituindo <code class="docutils literal notranslate"><span class="pre">None</span></code> pelas expressões ausentes.</p>
</section>
<section id="calls">
<span id="index-48"></span><span id="id9"></span><h3 class="translated"><span class="section-number">6.3.4. </span>Chamadas<a class="headerlink" href="#calls" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Uma chamada chama um objeto que é um chamável (por exemplo, uma <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">função</span></a>) com uma série possivelmente vazia de <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">argumentos</span></a>:</p>
<pre>
<strong id="grammar-token-python-grammar-call">call</strong>                 ::= <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-python-grammar-argument_list">argument_list</strong>        ::= <a class="reference internal" href="#grammar-token-python-grammar-positional_arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                         [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                         | <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                         | <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-python-grammar-positional_arguments">positional_arguments</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-positional_item"><code class="xref docutils literal notranslate"><span class="pre">positional_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-positional_item"><code class="xref docutils literal notranslate"><span class="pre">positional_item</span></code></a>)*
<strong id="grammar-token-python-grammar-positional_item">positional_item</strong>      ::= <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-starred_and_keywords">starred_and_keywords</strong> ::= (&quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                         (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-python-grammar-keywords_arguments">keywords_arguments</strong>   ::= (<a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                         (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-python-grammar-keyword_item">keyword_item</strong>         ::= <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p class="translated">Uma vírgula final opcional pode estar presente após os argumentos posicionais e nomeados, mas não afeta a semântica.</p>
<p class="translated" id="index-49">O primário deve ser avaliado como um objeto que pode ser chamado (funções definidas pelo usuário, funções embutidas, métodos de objetos embutidos, objetos de classe, métodos de instâncias de classe e todos os objetos que possuem um método <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> são chamáveis). Todas as expressões de argumento são avaliadas antes da tentativa de chamada. Consulte a seção <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a> para a sintaxe das listas formais de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parâmetros</span></a>.</p>
<p class="translated">Se houver argumentos nomeados, eles serão primeiro convertidos em argumentos posicionais, como segue. Primeiro, é criada uma lista de slots não preenchidos para os parâmetros formais. Se houver N argumentos posicionais, eles serão colocados nos primeiros N slots. A seguir, para cada argumento nomeado, o identificador é usado para determinar o slot correspondente (se o identificador for igual ao primeiro nome formal do parâmetro, o primeiro slot será usado e assim por diante). Se o slot já estiver preenchido, uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> será levantada. Caso contrário, o argumento é colocado no slot, preenchendo-o (mesmo que a expressão seja <code class="docutils literal notranslate"><span class="pre">None</span></code>, ela preenche o slot). Quando todos os argumentos forem processados, os slots ainda não preenchidos serão preenchidos com o valor padrão correspondente da definição da função. (Os valores padrão são calculados, uma vez, quando a função é definida; assim, um objeto mutável, como uma lista ou dicionário usado como valor padrão, será compartilhado por todas as chamadas que não especificam um valor de argumento para o slot correspondente; isso deve geralmente ser evitado.) Se houver algum slot não preenchido para o qual nenhum valor padrão for especificado, uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> será levantada. Caso contrário, a lista de slots preenchidos será usada como lista de argumentos para a chamada.</p>
<div class="impl-detail compound">
<p class="translated">Uma implementação pode fornecer funções integradas cujos parâmetros posicionais não possuem nomes, mesmo que sejam ‘nomeados’ para fins de documentação e que, portanto, não possam ser fornecidos por nomes. No CPython, este é o caso de funções implementadas em C que usam <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> para analisar seus argumentos.</p>
</div>
<p class="translated">Se houver mais argumentos posicionais do que slots de parâmetros formais, uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> será levantada, a menos que um parâmetro formal usando a sintaxe <code class="docutils literal notranslate"><span class="pre">*identificador</span></code> esteja presente; neste caso, esse parâmetro formal recebe uma tupla contendo os argumentos posicionais em excesso (ou uma tupla vazia se não houver argumentos posicionais em excesso).</p>
<p class="translated">Se algum argumento nomeado não corresponder a um nome de parâmetro formal, uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> é levantada, a menos que um parâmetro formal usando a sintaxe <code class="docutils literal notranslate"><span class="pre">**identificador</span></code> esteja presente; neste caso, esse parâmetro formal recebe um dicionário contendo os argumentos nomeados em excesso (usando os nomes como chaves e os valores dos argumentos como valores correspondentes), ou um (novo) dicionário vazio se não houver argumentos nomeados em excesso.</p>
<p class="translated" id="index-50">Se a sintaxe <code class="docutils literal notranslate"><span class="pre">*expressão</span></code> aparecer na chamada da função, <code class="docutils literal notranslate"><span class="pre">expressão</span></code> deverá ser avaliada como <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterável</span></a>. Os elementos desses iteráveis são tratados como se fossem argumentos posicionais adicionais. Para a chamada <code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code>, se <em>y</em> for avaliado como uma sequência <em>y1</em>, …, <em>yM</em>, isso é equivalente a uma chamada com M+4 argumentos posicionais <em>x1</em>, <em>x2</em>, <em>y1</em>, …, <em>yM</em>, <em>x3</em>, <em>x4</em>.</p>
<p class="translated">Uma consequência disso é que embora a sintaxe <code class="docutils literal notranslate"><span class="pre">*expressão</span></code> possa aparecer <em>depois</em> de argumentos nomeados explícitos, ela é processada <em>antes</em> dos argumentos nomeados (e de quaisquer argumentos de <code class="docutils literal notranslate"><span class="pre">**expressão</span></code> – veja abaixo). Então:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p class="translated">É incomum que ambos os argumentos nomeados e a sintaxe <code class="docutils literal notranslate"><span class="pre">*expressão</span></code> sejam usados na mesma chamada, portanto, na prática, essa confusão não surge com frequência.</p>
<p class="translated" id="index-51">Se a sintaxe <code class="docutils literal notranslate"><span class="pre">**expressão</span></code> aparecer na chamada de função, <code class="docutils literal notranslate"><span class="pre">expressão</span></code> deve ser avaliada como um <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapeamento</span></a>, cujo conteúdo é tratado como argumentos nomeados adicionais. Se um parâmetro que corresponde a uma chave já recebeu um valor (por um argumento nomeado explícito ou de outro desempacotamento), uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> é levantada.</p>
<p class="translated">Quando <code class="docutils literal notranslate"><span class="pre">**expressão</span></code> é usada, cada chave neste mapeamento deve ser uma string. Cada valor do mapeamento é atribuído ao primeiro parâmetro formal elegível para atribuição de nomeas cujo nome é igual à chave. Uma chave não precisa ser um identificador Python (por exemplo, <code class="docutils literal notranslate"><span class="pre">&quot;max-temp</span> <span class="pre">°F&quot;</span></code> é aceitável, embora não corresponda a nenhum parâmetro formal que possa ser declarado). Se não houver correspondência com um parâmetro formal, o par chave-valor é coletado pelo parâmetro <code class="docutils literal notranslate"><span class="pre">**</span></code>, se houver, ou se não houver, uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> é levantada.</p>
<p class="translated">Parâmetros formais usando a sintaxe <code class="docutils literal notranslate"><span class="pre">*identificador</span></code> ou <code class="docutils literal notranslate"><span class="pre">**identificador</span></code> não podem ser usados como slots de argumentos posicionais ou como nomes de argumentos nomeados.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Alterado na versão 3.5: </span>Chamadas de função aceitam qualquer número de desempacotamentos <code class="docutils literal notranslate"><span class="pre">*</span></code> e <code class="docutils literal notranslate"><span class="pre">**</span></code>, argumentos posicionais podem seguir desempacotamentos iteráveis (<code class="docutils literal notranslate"><span class="pre">*</span></code>) e argumentos nomeados podem seguir desempacotamentos de dicionário (<code class="docutils literal notranslate"><span class="pre">**</span></code>). Originalmente proposto pela <span class="target" id="index-122"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p class="translated">Uma chamada sempre retorna algum valor, possivelmente <code class="docutils literal notranslate"><span class="pre">None</span></code>, a menos que levanta uma exceção. A forma como esse valor é calculado depende do tipo do objeto chamável.</p>
<p class="translated">Se for…</p>
<dl>
<dt class="translated">uma função definida por usuário:</dt><dd><p class="translated" id="index-53">O bloco de código da função é executado, passando-lhe a lista de argumentos. A primeira coisa que o bloco de código fará é vincular os parâmetros formais aos argumentos; isso é descrito na seção <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>. Quando o bloco de código executa uma instrução <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, isso especifica o valor de retorno da chamada de função. Se a execução atingir o final do bloco de código sem executar uma instrução <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, o valor de retorno será <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt class="translated">um método embutido ou uma função embutida:</dt><dd><p class="translated" id="index-54">O resultado fica por conta do interpretador; veja <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">Funções embutidas</span></a> para descrições de funções embutidas e métodos embutidos.</p>
</dd>
<dt class="translated">um objeto classe:</dt><dd><p class="translated" id="index-55">Uma nova instância dessa classe é retornada.</p>
</dd>
<dt class="translated">um método de instância de classe:</dt><dd><p class="translated" id="index-56">A função correspondente definida pelo usuário é chamada, com uma lista de argumentos que é maior que a lista de argumentos da chamada: a instância se torna o primeiro argumento.</p>
</dd>
<dt class="translated">uma instância de classe:</dt><dd><p class="translated" id="index-57">A classe deve definir um método <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a>; o efeito é então o mesmo como se esse método fosse chamado.</p>
</dd>
</dl>
</section>
</section>
<section id="await-expression">
<span id="await"></span><span id="index-58"></span><h2 class="translated"><span class="section-number">6.4. </span>Expressão await<a class="headerlink" href="#await-expression" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Suspende a execução de <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">corrotina</span></a> em um objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">aguardável</span></a>. Só pode ser usado dentro de uma <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">função de corrotina</span></a>.</p>
<pre>
<strong id="grammar-token-python-grammar-await_expr">await_expr</strong> ::= &quot;await&quot; <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5.</span></p>
</div>
</section>
<section id="the-power-operator">
<span id="power"></span><h2 class="translated"><span class="section-number">6.5. </span>O operador de potência<a class="headerlink" href="#the-power-operator" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-59">O operador de potência vincula-se com mais força do que os operadores unários à sua esquerda; ele se vincula com menos força do que os operadores unários à sua direita. A sintaxe é:</p>
<pre>
<strong id="grammar-token-python-grammar-power">power</strong> ::= (<a class="reference internal" href="#grammar-token-python-grammar-await_expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>) [&quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p class="translated">Assim, em uma sequência sem parênteses de operadores de potência e unários, os operadores são avaliados da direita para a esquerda (isso não restringe a ordem de avaliação dos operandos): <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> resulta em <code class="docutils literal notranslate"><span class="pre">-1</span></code> .</p>
<p class="translated">O operador de potência tem a mesma semântica que a função embutida <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, quando chamado com dois argumentos: ele produz seu argumento esquerdo elevado à potência de seu argumento direito. Os argumentos numéricos são primeiro convertidos em um tipo comum e o resultado é desse tipo.</p>
<p class="translated">Para operandos int, o resultado tem o mesmo tipo que os operandos, a menos que o segundo argumento seja negativo; nesse caso, todos os argumentos são convertidos em ponto flutuante e um resultado ponto flutuante é entregue. Por exemplo, <code class="docutils literal notranslate"><span class="pre">10**2</span></code> retorna <code class="docutils literal notranslate"><span class="pre">100</span></code>, mas <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> retorna <code class="docutils literal notranslate"><span class="pre">0.01</span></code>.</p>
<p class="translated">Elevar <code class="docutils literal notranslate"><span class="pre">0.0</span></code> a uma potência negativa resulta em uma exceção <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>. Elevar um número negativo a uma potência fracionária resulta em um número <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>. (Em versões anteriores, levantava <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.)</p>
<p class="translated">Esta operação pode ser personalizada usando os métodos especial <a class="reference internal" href="datamodel.html#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a>.</p>
</section>
<section id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2 class="translated"><span class="section-number">6.6. </span>Operações aritméticas unárias e bit a bit<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-60">Todas as operações aritméticas unárias e bit a bit têm a mesma prioridade:</p>
<pre>
<strong id="grammar-token-python-grammar-u_expr">u_expr</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p class="translated" id="index-61">O operador unário <code class="docutils literal notranslate"><span class="pre">-</span></code> (menos) produz a negação de seu argumento numérico; a operação pode ser substituída pelo método especial <a class="reference internal" href="datamodel.html#object.__neg__" title="object.__neg__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__neg__()</span></code></a>.</p>
<p class="translated" id="index-62">O operador unário <code class="docutils literal notranslate"><span class="pre">+</span></code> (mais) produz seu argumento numérico inalterado; a operação pode ser substituída pelo método especial <a class="reference internal" href="datamodel.html#object.__pos__" title="object.__pos__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pos__()</span></code></a>.</p>
<p class="translated" id="index-63">O operador unário <code class="docutils literal notranslate"><span class="pre">~</span></code> (inverter) produz a inversão bit a bit de seu argumento inteiro. A inversão bit a bit de <code class="docutils literal notranslate"><span class="pre">x</span></code> é definida como <code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code>. Aplica-se apenas a números inteiros ou a objetos personalizados que substituem o método especial <a class="reference internal" href="datamodel.html#object.__invert__" title="object.__invert__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__invert__()</span></code></a>.</p>
<p class="translated" id="index-64">Em todos os três casos, se o argumento não tiver o tipo adequado, uma exceção <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> é levantada.</p>
</section>
<section id="binary-arithmetic-operations">
<span id="binary"></span><h2 class="translated"><span class="section-number">6.7. </span>Operações binárias aritméticas<a class="headerlink" href="#binary-arithmetic-operations" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-65">As operações aritméticas binárias possuem os níveis de prioridade convencionais. Observe que algumas dessas operações também se aplicam a determinados tipos não numéricos. Além do operador potência, existem apenas dois níveis, um para operadores multiplicativos e outro para operadores aditivos:</p>
<pre>
<strong id="grammar-token-python-grammar-m_expr">m_expr</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
           <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
           <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-python-grammar-a_expr">a_expr</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p class="translated" id="index-66">O operador <code class="docutils literal notranslate"><span class="pre">*</span></code> (multiplicação) produz o produto de seus argumentos. Os argumentos devem ser números ou um argumento deve ser um número inteiro e o outro deve ser uma sequência. No primeiro caso, os números são convertidos para um tipo comum e depois multiplicados. Neste último caso, é realizada a repetição da sequência; um fator de repetição negativo produz uma sequência vazia.</p>
<p class="translated">Esta operação pode ser personalizada usando os métodos especial <a class="reference internal" href="datamodel.html#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a>.</p>
<p class="translated" id="index-67">O operador <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (arroba) deve ser usado para multiplicação de matrizes. Nenhum tipo embutido do Python implementa este operador.</p>
<p class="translated">Esta operação pode ser personalizada usando os métodos especial <a class="reference internal" href="datamodel.html#object.__matmul__" title="object.__matmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__matmul__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rmatmul__" title="object.__rmatmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmatmul__()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5.</span></p>
</div>
<p class="translated" id="index-68">Os operadores <code class="docutils literal notranslate"><span class="pre">/</span></code> (divisão) e <code class="docutils literal notranslate"><span class="pre">//</span></code> (divisão pelo piso) produzem o quociente de seus argumentos. Os argumentos numéricos são primeiro convertidos em um tipo comum. A divisão de inteiros produz um ponto flutuante, enquanto a divisão pelo piso de inteiros resulta em um inteiro; o resultado é o da divisão matemática com a função ‘floor’ aplicada ao resultado. A divisão por zero levanta a exceção <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>.</p>
<p class="translated">A operação de divisão pode ser personalizada usando os métodos especiais <a class="reference internal" href="datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rtruediv__" title="object.__rtruediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rtruediv__()</span></code></a>. A operação de divisão pelo piso pode ser personalizada usando os métodos especiais <a class="reference internal" href="datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rfloordiv__" title="object.__rfloordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rfloordiv__()</span></code></a>.</p>
<p class="translated" id="index-69">O operador <code class="docutils literal notranslate"><span class="pre">%</span></code> (módulo) produz o restante da divisão do primeiro argumento pelo segundo. Os argumentos numéricos são primeiro convertidos em um tipo comum. Um argumento zero à direita levanta a exceção <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>. Os argumentos podem ser números de ponto flutuante, por exemplo, <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> é igual a <code class="docutils literal notranslate"><span class="pre">0.34</span></code> (já que <code class="docutils literal notranslate"><span class="pre">3.14</span></code> é igual a <code class="docutils literal notranslate"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code>.) O operador módulo sempre produz um resultado com o mesmo sinal do seu segundo operando (ou zero); o valor absoluto do resultado é estritamente menor que o valor absoluto do segundo operando <a class="footnote-reference brackets" href="#id19" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p class="translated">Os operadores de divisão pelo piso e módulo são conectados pela seguinte identidade: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code>. A divisão pelo piso e o módulo também estão conectados com a função embutida <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code>. <a class="footnote-reference brackets" href="#id20" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p class="translated">Além de realizar a operação de módulo em números, o operador <code class="docutils literal notranslate"><span class="pre">%</span></code> também é sobrecarregado por objetos string para realizar a formatação de string no estilo antigo (também conhecida como interpolação). A sintaxe para formatação de string é descrita na Referência da Biblioteca Python, seção <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">Formatação de string no estilo printf</span></a>.</p>
<p class="translated">A operação <em>módulo</em> pode ser personalizada usando os métodos especial <a class="reference internal" href="datamodel.html#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rmod__" title="object.__rmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmod__()</span></code></a>.</p>
<p class="translated">O operador de divisão pelo piso, o operador de módulo e a função <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> não são definidos para números complexos. Em vez disso, converta para um número de ponto flutuante usando a função <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> se apropriado.</p>
<p class="translated" id="index-70">O operador <code class="docutils literal notranslate"><span class="pre">+</span></code> (adição) produz a soma de seus argumentos. Os argumentos devem ser números ou sequências do mesmo tipo. No primeiro caso, os números são convertidos para um tipo comum e depois somados. Neste último caso, as sequências são concatenadas.</p>
<p class="translated">Esta operação pode ser personalizada usando os métodos especial <a class="reference internal" href="datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>.</p>
<p class="translated" id="index-71">O operador <code class="docutils literal notranslate"><span class="pre">-</span></code> (subtração) produz a diferença de seus argumentos. Os argumentos numéricos são primeiro convertidos em um tipo comum.</p>
<p class="translated">Esta operação pode ser personalizada usando os métodos especial <a class="reference internal" href="datamodel.html#object.__sub__" title="object.__sub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a>.</p>
</section>
<section id="shifting-operations">
<span id="shifting"></span><h2 class="translated"><span class="section-number">6.8. </span>Operações de deslocamento<a class="headerlink" href="#shifting-operations" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-72">As operações de deslocamento têm menor prioridade que as operações aritméticas:</p>
<pre>
<strong id="grammar-token-python-grammar-shift_expr">shift_expr</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p class="translated">Esses operadores aceitam números inteiros como argumentos. Eles deslocam o primeiro argumento para a esquerda ou para a direita pelo número de bits fornecido pelo segundo argumento.</p>
<p class="translated">A operação de deslocamento à esquerda pode ser personalizada usando os métodos especiais <a class="reference internal" href="datamodel.html#object.__lshift__" title="object.__lshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lshift__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rlshift__" title="object.__rlshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rlshift__()</span></code></a>. A operação de deslocamento à direita pode ser personalizada usando os métodos especiais <a class="reference internal" href="datamodel.html#object.__rshift__" title="object.__rshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rshift__()</span></code></a> e <a class="reference internal" href="datamodel.html#object.__rrshift__" title="object.__rrshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rrshift__()</span></code></a>.</p>
<p class="translated" id="index-73">Um deslocamento para a direita por <em>n</em> bits é definido como divisão pelo piso por <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code>. Um deslocamento à esquerda por <em>n</em> bits é definido como multiplicação com <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code>.</p>
</section>
<section id="binary-bitwise-operations">
<span id="bitwise"></span><h2 class="translated"><span class="section-number">6.9. </span>Operações binárias bit a bit<a class="headerlink" href="#binary-bitwise-operations" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-74">Cada uma das três operações bit a bit tem um nível de prioridade diferente:</p>
<pre>
<strong id="grammar-token-python-grammar-and_expr">and_expr</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-python-grammar-xor_expr">xor_expr</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-python-grammar-or_expr">or_expr</strong>  ::= <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p class="translated" id="index-75">O operador <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> produz o E (AND) bit a bit de seus argumentos, que devem ser inteiros ou um deles deve ser um objeto personalizado substituindo os métodos especiais <a class="reference internal" href="datamodel.html#object.__and__" title="object.__and__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code></a> ou <a class="reference internal" href="datamodel.html#object.__rand__" title="object.__rand__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rand__()</span></code></a>.</p>
<p class="translated" id="index-76">O operador <code class="docutils literal notranslate"><span class="pre">^</span></code> produz o XOR bit a bit (OU exclusivo) de seus argumentos, que devem ser inteiros ou um deles deve ser um objeto personalizado sobrescrevendo os métodos especiais <a class="reference internal" href="datamodel.html#object.__xor__" title="object.__xor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__xor__()</span></code></a> ou <a class="reference internal" href="datamodel.html#object.__rxor__" title="object.__rxor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rxor__()</span></code></a>.</p>
<p class="translated" id="index-77">O operador <code class="docutils literal notranslate"><span class="pre">|</span></code> produz o OU (OR) bit a bit de seus argumentos, que devem ser inteiros ou um deles deve ser um objeto personalizado sobrescrevendo os métodos especiais <a class="reference internal" href="datamodel.html#object.__or__" title="object.__or__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code></a> ou <a class="reference internal" href="datamodel.html#object.__ror__" title="object.__ror__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ror__()</span></code></a>.</p>
</section>
<section id="comparisons">
<span id="id12"></span><h2 class="translated"><span class="section-number">6.10. </span>Comparações<a class="headerlink" href="#comparisons" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-78">Ao contrário de C, todas as operações de comparação em Python têm a mesma prioridade, que é menor do que qualquer operação aritmética, de deslocamento ou bit a bit. Também diferentemente de C, expressões como <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> têm a interpretação que é convencional em matemática:</p>
<pre>
<strong id="grammar-token-python-grammar-comparison">comparison</strong>    ::= <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> (<a class="reference internal" href="#grammar-token-python-grammar-comp_operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)*
<strong id="grammar-token-python-grammar-comp_operator">comp_operator</strong> ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                  | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p class="translated">Comparações produzem valores booleanos: <code class="docutils literal notranslate"><span class="pre">True</span></code> ou <code class="docutils literal notranslate"><span class="pre">False</span></code>. <em class="dfn">métodos de comparação rica</em> personalizados podem retornar valores não booleanos. Neste caso, o Python chamará <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> nesse valor em contextos booleanos.</p>
<p class="translated" id="index-79">As comparações podem ser encadeadas arbitrariamente, por exemplo, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>, exceto que <code class="docutils literal notranslate"><span class="pre">y</span></code> é avaliado apenas uma vez (mas em ambos os casos <code class="docutils literal notranslate"><span class="pre">z</span></code> não é avaliado quando <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> é considerado falso).</p>
<p class="translated">Formalmente, se <em>a</em>, <em>b</em>, <em>c</em>, …, <em>y</em>, <em>z</em> são expressões e <em>op1</em>, <em>op2</em>, …, <em>opN</em> são operadores de comparação, então <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">e</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">e</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code>, exceto que cada expressão é avaliada no máximo uma vez.</p>
<p class="translated">Observe que <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> não implica qualquer tipo de comparação entre <em>a</em> e <em>c</em>, de modo que, por exemplo, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> é perfeitamente válido (embora talvez não seja bonito).</p>
<section id="value-comparisons">
<span id="expressions-value-comparisons"></span><h3 class="translated"><span class="section-number">6.10.1. </span>Comparações de valor<a class="headerlink" href="#value-comparisons" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os operadores <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> e <code class="docutils literal notranslate"><span class="pre">!=</span></code> comparam os valores de dois objetos. Os objetos não precisam ser do mesmo tipo.</p>
<p class="translated">O capítulo <a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">Objetos, valores e tipos</span></a> afirma que os objetos possuem um valor (além do tipo e da identidade). O valor de um objeto é uma noção bastante abstrata em Python: por exemplo, não existe um método de acesso canônico para o valor de um objeto. Além disso, não há exigência de que o valor de um objeto seja construído de uma maneira específica, por exemplo. composto por todos os seus atributos de dados. Os operadores de comparação implementam uma noção específica de qual é o valor de um objeto. Pode-se pensar neles como definindo o valor de um objeto indiretamente, por meio de sua implementação de comparação.</p>
<p class="translated">Como todos os tipos são subtipos (diretos ou indiretos) de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, eles herdam o comportamento de comparação padrão de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>. Os tipos podem personalizar seu comportamento de comparação implementando <em class="dfn">métodos de comparação rica</em> como <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, descrito em <a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">Personalização básica</span></a>.</p>
<p class="translated">O comportamento padrão para comparação de igualdade (<code class="docutils literal notranslate"><span class="pre">==</span></code> e <code class="docutils literal notranslate"><span class="pre">!=</span></code>) é baseado na identidade dos objetos. Consequentemente, a comparação da igualdade de instâncias com a mesma identidade resulta em igualdade, e a comparação da igualdade de instâncias com identidades diferentes resulta em desigualdade. Uma motivação para este comportamento padrão é o desejo de que todos os objetos sejam reflexivos (ou seja, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> implica <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>).</p>
<p class="translated">Uma comparação de ordem padrão (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> e <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) não é fornecida; uma tentativa levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Uma motivação para este comportamento padrão é a falta de um invariante semelhante ao da igualdade.</p>
<p class="translated">O comportamento da comparação de igualdade padrão, de que instâncias com identidades diferentes são sempre desiguais, pode contrastar com o que os tipos precisarão ter uma definição sensata de valor de objeto e igualdade baseada em valor. Esses tipos precisarão personalizar seu comportamento de comparação e, de fato, vários tipos embutidos fizeram isso.</p>
<p class="translated">A lista a seguir descreve o comportamento de comparação dos tipos embutidos mais importantes.</p>
<ul>
<li><p class="translated">Números de tipos numéricos embutidos (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">Tipos numéricos — int, float, complex</span></a>) e dos tipos de biblioteca padrão <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> e <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> podem ser comparados dentro e entre seus tipos, com a restrição que os números complexos não oferecem suporte a comparação de ordens. Dentro dos limites dos tipos envolvidos, eles comparam matematicamente (algoritmicamente) corretos sem perda de precisão.</p>
<p class="translated">Os valores não numéricos <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> e <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('NaN')</span></code> são especiais. Qualquer comparação ordenada de um número com um valor que não é um número é falsa. Uma implicação contraintuitiva é que os valores que não são numéricos não são iguais a si mesmos. Por exemplo, se <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">float('NaN')</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> e <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> são todos falsos, enquanto <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> é verdadeiro. Esse comportamento é compatível com IEEE 754.</p>
</li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">None</span></code> e <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> são singletons. <span class="target" id="index-123"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> aconselha que comparações para singletons devem sempre ser feitas com <code class="docutils literal notranslate"><span class="pre">is</span></code> ou <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>, nunca com os operadores de igualdade.</p></li>
<li><p class="translated">Sequências binárias (instâncias de <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) podem ser comparadas dentro e entre seus tipos. Eles comparam lexicograficamente usando os valores numéricos de seus elementos.</p></li>
<li><p class="translated">Strings (instâncias de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) são comparadas lexicograficamente usando os pontos de código Unicode numéricos (o resultado da função embutida <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a>) de seus caracteres. <a class="footnote-reference brackets" href="#id21" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p class="translated">Strings e sequências binárias não podem ser comparadas diretamente.</p>
</li>
<li><p class="translated">Sequências (instâncias de <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a>) podem ser comparadas apenas dentro de cada um de seus tipos, com a restrição de que intervalos não oferecem suporte a comparação de ordem. A comparação de igualdade entre esses tipos resulta em desigualdade, e a comparação ordenada entre esses tipos levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p class="translated">As sequências são comparadas lexicograficamente usando a comparação de elementos correspondentes. Os contêineres embutidos normalmente presumem que objetos idênticos são iguais a si mesmos. Isso permite ignorar testes de igualdade para objetos idênticos para melhorar o desempenho e manter seus invariantes internos.</p>
<p class="translated">A comparação lexicográfica entre coleções embutidas funciona da seguinte forma:</p>
<ul class="simple">
<li><p class="translated">Para que duas coleções sejam comparadas iguais, elas devem ser do mesmo tipo, ter o mesmo comprimento e cada par de elementos correspondentes deve ser comparado igual (por exemplo, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> é false porque o tipo não é o mesmo).</p></li>
<li><p class="translated">Coleções que oferecem suporte a comparação de ordem são ordenadas da mesma forma que seus primeiros elementos desiguais (por exemplo, <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> tem o mesmo valor que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>). Se um elemento correspondente não existir, a coleção mais curta é ordenada primeiro (por exemplo, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> é verdadeiro).</p></li>
</ul>
</li>
<li><p class="translated">Mapeamentos (instâncias de <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) comparam iguais se e somente se eles tiverem pares <code class="docutils literal notranslate"><span class="pre">(chave,</span> <span class="pre">valor)</span></code> iguais. A comparação de igualdade das chaves e valores reforça a reflexividade.</p>
<p class="translated">Comparações de ordem (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> e <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) levantam <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</li>
<li><p class="translated">Conjuntos (instâncias de <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> ou <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>) podem ser comparados dentro e entre seus tipos.</p>
<p class="translated">Eles definem operadores de comparação de ordem para significar testes de subconjunto e superconjunto. Essas relações não definem ordenações totais (por exemplo, os dois conjuntos <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> e <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> não são iguais, nem subconjuntos um do outro, nem superconjuntos um do outro). Consequentemente, conjuntos não são argumentos apropriados para funções que dependem de ordenação total (por exemplo, <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> e <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> produzem resultados indefinidos dada uma lista de conjuntos como entradas) .</p>
<p class="translated">A comparação de conjuntos reforça a reflexividade de seus elementos.</p>
</li>
<li><p class="translated">A maioria dos outros tipos embutidos não possui métodos de comparação implementados, portanto, eles herdam o comportamento de comparação padrão.</p></li>
</ul>
<p class="translated">As classes definidas pelo usuário que personalizam seu comportamento de comparação devem seguir algumas regras de consistência, se possível:</p>
<ul>
<li><p class="translated">A comparação da igualdade deve ser reflexiva. Em outras palavras, objetos idênticos devem ser comparados iguais:</p>
<blockquote>
<div><p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> implica em <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p class="translated">A comparação deve ser simétrica. Em outras palavras, as seguintes expressões devem ter o mesmo resultado:</p>
<blockquote>
<div><p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p class="translated">A comparação deve ser transitiva. Os seguintes exemplos (não exaustivos) ilustram isso:</p>
<blockquote>
<div><p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> implica em <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> implica em <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p class="translated">A comparação inversa deve resultar na negação booleana. Em outras palavras, as seguintes expressões devem ter o mesmo resultado:</p>
<blockquote>
<div><p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (pra classificação total)</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> e <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (pra classificação total)</p>
</div></blockquote>
<p class="translated">As duas últimas expressões aplicam-se a coleções totalmente ordenadas (por exemplo, a sequências, mas não a conjuntos ou mapeamentos). Veja também o decorador <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a>.</p>
</li>
<li><p class="translated">O resultado <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> deve ser consistente com a igualdade. Objetos iguais devem ter o mesmo valor de hash ou ser marcados como não-hasheáveis.</p></li>
</ul>
<p class="translated">Python não impõe essas regras de consistência. Na verdade, os valores não numéricos são um exemplo de não cumprimento dessas regras.</p>
</section>
<section id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3 class="translated"><span class="section-number">6.10.2. </span>Operações de teste de pertinência<a class="headerlink" href="#membership-test-operations" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os operadores <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> e <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> testam se um operando é membro ou não de outro. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> é avaliado como <code class="docutils literal notranslate"><span class="pre">True</span></code> se <em>x</em> for membro de <em>s</em>, e <code class="docutils literal notranslate"><span class="pre">False</span></code> caso contrário. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> retorna a negação de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code>. Todas as sequências e tipos de conjuntos embutidos oferecem suporte a isso, assim como o dicionário, para o qual <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> testa se o dicionário tem uma determinada chave. Para tipos de contêiner como list, tuple, set, frozenset, dict ou Collections.deque, a expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> é equivalente a <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code>.</p>
<p class="translated">Para os tipos string e bytes, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> é <code class="docutils literal notranslate"><span class="pre">True</span></code> se e somente se <em>x</em> for uma substring de <em>y</em>. Um teste equivalente é <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code>. Strings vazias são sempre consideradas uma substring de qualquer outra string, então <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> retornará <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p class="translated">Para classes definidas pelo usuário que definem o método <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> se <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> retorna um valor verdadeiro, e <code class="docutils literal notranslate"><span class="pre">False</span></code> caso contrário.</p>
<p class="translated">Para classes definidas pelo usuário que não definem <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, mas definem <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> é <code class="docutils literal notranslate"><span class="pre">True</span></code> se algum valor <code class="docutils literal notranslate"><span class="pre">z</span></code>, para a qual a expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">z</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> é verdadeira, é produzida durante a iteração sobre <code class="docutils literal notranslate"><span class="pre">y</span></code>. Se uma exceção for levantada durante a iteração, é como se <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> tivesse levantado essa exceção.</p>
<p class="translated">Por último, o protocolo de iteração de estilo antigo é tentado: se uma classe define <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> é <code class="docutils literal notranslate"><span class="pre">True</span></code> se, e somente se, houver um índice inteiro não negativo <em>i</em> tal que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y[i]</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code>, e nenhum índice inteiro inferior levanta a exceção <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. (Se qualquer outra exceção for levantada, é como se <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> levantasse essa exceção).</p>
<p class="translated" id="index-81">O operador <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> é definido para ter o valor verdade inverso de <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>.</p>
</section>
<section id="is-not">
<span id="is"></span><span id="index-82"></span><span id="identity-comparisons"></span><h3 class="translated"><span class="section-number">6.10.3. </span>Comparações de identidade<a class="headerlink" href="#is-not" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Os operadores <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> e <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> testam a identidade de um objeto: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> é verdadeiro se, e somente se, <em>x</em> e <em>y</em> são o mesmo objeto. A identidade de um objeto é determinada usando a função <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> produz o valor verdade inverso. <a class="footnote-reference brackets" href="#id22" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
</section>
</section>
<section id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2 class="translated"><span class="section-number">6.11. </span>Operações booleanas<a class="headerlink" href="#boolean-operations" title="Link para este cabeçalho">¶</a></h2>
<pre id="index-83">
<strong id="grammar-token-python-grammar-or_test">or_test</strong>  ::= <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-python-grammar-and_test">and_test</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-python-grammar-not_test">not_test</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p class="translated">No contexto de operações booleanas, e também quando expressões são usadas por instruções de fluxo de controle, os seguintes valores são interpretados como falsos: <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, zero numérico de todos os tipos e strings e contêineres vazios (incluindo strings, tuplas, listas, dicionários, conjuntos e frozensets). Todos os outros valores são interpretados como verdadeiros. Objetos definidos pelo usuário podem personalizar seu valor verdade fornecendo um método <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>.</p>
<p class="translated" id="index-84">O operador <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> produz <code class="docutils literal notranslate"><span class="pre">True</span></code> se seu argumento for falso, <code class="docutils literal notranslate"><span class="pre">False</span></code> caso contrário.</p>
<p class="translated" id="index-85">A expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> primeiro avalia <em>x</em>; se <em>x</em> for falso, seu valor será retornado; caso contrário, <em>y</em> será avaliado e o valor resultante será retornado.</p>
<p class="translated" id="index-86">A expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> primeiro avalia <em>x</em>; se <em>x</em> for verdadeiro, seu valor será retornado; caso contrário, <em>y</em> será avaliado e o valor resultante será retornado.</p>
<p class="translated">Observe que nem <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> nem <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> restringem o valor e o tipo que retornam para <code class="docutils literal notranslate"><span class="pre">False</span></code> e <code class="docutils literal notranslate"><span class="pre">True</span></code>, mas sim retornam o último argumento avaliado. Isso às vezes é útil, por exemplo, se <code class="docutils literal notranslate"><span class="pre">s</span></code> é uma string que deve ser substituída por um valor padrão se estiver vazia, a expressão <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> produz o valor desejado. Como <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> precisa criar um novo valor, ele retorna um valor booleano independente do tipo de seu argumento (por exemplo, <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'foo'</span></code> produz <code class="docutils literal notranslate"><span class="pre">False</span></code> em vez de <code class="docutils literal notranslate"><span class="pre">''</span></code>.)</p>
</section>
<section id="assignment-expressions">
<span id="index-87"></span><span id="id15"></span><h2 class="translated"><span class="section-number">6.12. </span>Expressões de atribuição<a class="headerlink" href="#assignment-expressions" title="Link para este cabeçalho">¶</a></h2>
<pre>
<strong id="grammar-token-python-grammar-assignment_expression">assignment_expression</strong> ::= [<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;:=&quot;] <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p class="translated">Uma expressão de atribuição (às vezes também chamada de “expressão nomeada” ou “morsa”) atribui um <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a> a um <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">identifier</span></code></a>, ao mesmo tempo que retorna o valor de <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a>.</p>
<p class="translated">Um caso de uso comum é ao lidar com expressões regulares correspondentes:</p>
<div class="translated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">matching</span> <span class="o">:=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Ou, ao processar um fluxo de arquivos em partes:</p>
<div class="translated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">9000</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">As expressões de atribuição devem ser colocadas entre parênteses quando usadas como instruções de expressão e quando usadas como subexpressões em expressões de fatiamento, condicionais, de lambda, de argumento nomeado e de if de compreensão e em instruções <code class="docutils literal notranslate"><span class="pre">assert</span></code>, <code class="docutils literal notranslate"><span class="pre">with</span></code> e <code class="docutils literal notranslate"><span class="pre">assignment</span></code>. Em todos os outros lugares onde eles podem ser usados, os parênteses não são necessários, inclusive nas instruções <code class="docutils literal notranslate"><span class="pre">if</span></code> e <code class="docutils literal notranslate"><span class="pre">while</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.8: </span>Veja <span class="target" id="index-124"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> para mais detalhes sobre expressões de atribuição.</p>
</div>
</section>
<section id="conditional-expressions">
<span id="if-expr"></span><h2 class="translated"><span class="section-number">6.13. </span>Expressões condicionais<a class="headerlink" href="#conditional-expressions" title="Link para este cabeçalho">¶</a></h2>
<pre id="index-89">
<strong id="grammar-token-python-grammar-conditional_expression">conditional_expression</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-python-grammar-expression">expression</strong>             ::= <a class="reference internal" href="#grammar-token-python-grammar-conditional_expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-lambda_expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
</pre>
<p class="translated">Expressões condicionais (às vezes chamadas de “operador ternário”) têm a prioridade mais baixa de todas as operações Python.</p>
<p class="translated">A expressão <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> primeiro avalia a condição, <em>C</em> em vez de <em>x</em>. Se <em>C</em> for verdadeiro, <em>x</em> é avaliado e seu valor é retornado; caso contrário, <em>y</em> será avaliado e seu valor será retornado.</p>
<p class="translated">Veja <span class="target" id="index-125"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> para mais detalhes sobre expressões condicionais.</p>
</section>
<section id="lambda">
<span id="lambdas"></span><span id="id16"></span><h2 class="translated"><span class="section-number">6.14. </span>Lambdas<a class="headerlink" href="#lambda" title="Link para este cabeçalho">¶</a></h2>
<pre id="index-91">
<strong id="grammar-token-python-grammar-lambda_expr">lambda_expr</strong> ::= &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-python-grammar-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p class="translated">Expressões lambda (às vezes chamadas de funções lambda) são usadas para criar funções anônimas. A expressão <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">parameters:</span> <span class="pre">expression</span></code> produz um objeto função. O objeto sem nome se comporta como um objeto de função definido com:</p>
<div class="translated highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(parâmetros):
    return expressão
</pre></div>
</div>
<p class="translated">Veja a seção <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a> para a sintaxe das listas de parâmetros. Observe que as funções criadas com expressões lambda não podem conter instruções ou anotações.</p>
</section>
<section id="expression-lists">
<span id="exprlists"></span><h2 class="translated"><span class="section-number">6.15. </span>Listas de expressões<a class="headerlink" href="#expression-lists" title="Link para este cabeçalho">¶</a></h2>
<pre id="index-92">
<strong id="grammar-token-python-grammar-starred_expression">starred_expression</strong>       ::= [&quot;*&quot;] <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-python-grammar-flexible_expression">flexible_expression</strong>      ::= <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>
<strong id="grammar-token-python-grammar-flexible_expression_list">flexible_expression_list</strong> ::= <a class="reference internal" href="#grammar-token-python-grammar-flexible_expression"><code class="xref docutils literal notranslate"><span class="pre">flexible_expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-flexible_expression"><code class="xref docutils literal notranslate"><span class="pre">flexible_expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_expression_list">starred_expression_list</strong>  ::= <a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-expression_list">expression_list</strong>          ::= <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-yield_list">yield_list</strong>               ::= <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a> &quot;,&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_expression_list"><code class="xref docutils literal notranslate"><span class="pre">starred_expression_list</span></code></a>]
</pre>
<p class="translated" id="index-93">Exceto quando parte de uma sintaxe de criação de lista ou conjunto, uma lista de expressões contendo pelo menos uma vírgula produz uma tupla. O comprimento da tupla é o número de expressões na lista. As expressões são avaliadas da esquerda para a direita.</p>
<p class="translated" id="index-94">Um asterisco <code class="docutils literal notranslate"><span class="pre">*</span></code> denota <em class="dfn">desempacotamento de iterável</em>. Seu operando deve ser um <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterável</span></a>. O iterável é expandido em uma sequência de itens, que são incluídos na nova tupla, lista ou conjunto, no local do desempacotamento.</p>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.5: </span>Desempacotamento de iterável em listas de expressões, originalmente proposta pela <span class="target" id="index-126"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Adicionado na versão 3.11: </span>Qualquer item em uma lista de expressões pode ser estrelado. Veja a <span class="target" id="index-127"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a>.</p>
</div>
<p class="translated" id="index-97">Uma vírgula final é necessária apenas para criar uma tupla de um item, como <code class="docutils literal notranslate"><span class="pre">1,</span></code>; é opcional em todos os outros casos. Uma única expressão sem vírgula final não cria uma tupla, mas produz o valor dessa expressão. (Para criar uma tupla vazia, use um par vazio de parênteses: <code class="docutils literal notranslate"><span class="pre">()</span></code>.)</p>
</section>
<section id="evaluation-order">
<span id="evalorder"></span><h2 class="translated"><span class="section-number">6.16. </span>Ordem de avaliação<a class="headerlink" href="#evaluation-order" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-98">Python avalia expressões da esquerda para a direita. Observe que ao avaliar uma tarefa, o lado direito é avaliado antes do lado esquerdo.</p>
<p class="translated">Nas linhas a seguir, as expressões serão avaliadas na ordem aritmética de seus sufixos:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</section>
<section id="operator-precedence">
<span id="operator-summary"></span><h2 class="translated"><span class="section-number">6.17. </span>Precedência de operadores<a class="headerlink" href="#operator-precedence" title="Link para este cabeçalho">¶</a></h2>
<p class="translated" id="index-99">A tabela a seguir resume a precedência de operadores no Python, da precedência mais alta (mais vinculativa) à precedência mais baixa (menos vinculativa). Os operadores na mesma caixa têm a mesma precedência. A menos que a sintaxe seja fornecida explicitamente, os operadores são binários. Os operadores na mesma caixa agrupam-se da esquerda para a direita (exceto exponenciação e expressões condicionais, que agrupam da direita para a esquerda).</p>
<p class="translated">Observe que comparações, testes de pertinência e testes de identidade têm todos a mesma precedência e possuem um recurso de encadeamento da esquerda para a direita, conforme descrito na seção <a class="reference internal" href="#comparisons"><span class="std std-ref">Comparações</span></a>.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Operador</p></th>
<th class="head"><p class="translated">Descrição</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">(expressions...)</span></code>,</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">[expressões...]</span></code>, <code class="docutils literal notranslate"><span class="pre">{chave:</span> <span class="pre">valor...}</span></code>, <code class="docutils literal notranslate"><span class="pre">{expressões...}</span></code></p>
</td>
<td><p class="translated">Expressão entre parênteses ou de ligação, sintaxe de criação de lista, sintaxe de criação de dicionário, sintaxe de criação de conjunto</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">x[índice]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[índice:índice]</span></code>, <code class="docutils literal notranslate"><span class="pre">x(argumentos...)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.atributo</span></code></p></td>
<td><p class="translated">subscrição, fatiamento, chamada, referência a atributo</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span> <span class="pre">x</span></code></a></p></td>
<td><p class="translated">Expressão await</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p class="translated">Exponenciação <a class="footnote-reference brackets" href="#id23" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></p></td>
<td><p class="translated">positivo, negativo, NEGAÇÃO (NOT) bit a bit</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p class="translated">Multiplicação, multiplicação de matrizes, divisão, divisão pelo piso, resto <a class="footnote-reference brackets" href="#id24" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p class="translated">Adição e subtração</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
<td><p class="translated">Deslocamentos</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p class="translated">E (AND) bit a bit</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p class="translated">OU EXCLUSIVO (XOR) bit a bit</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p class="translated">OU (OR) bit a bit</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p class="translated">Comparações, incluindo testes de pertinência e testes de identidade</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></a></p></td>
<td><p class="translated">NEGAÇÃO (NOT) booleana</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></p></td>
<td><p class="translated">E (AND) booleano</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></p></td>
<td><p class="translated">OU (OR) booleano</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#if-expr"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> – <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></p></td>
<td><p class="translated">Expressão condicional</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></p></td>
<td><p class="translated">Expressão lambda</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p class="translated">Expressão de atribuição</p></td>
</tr>
</tbody>
</table>
<p class="translated rubric">Notas de rodapé</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">1</a><span class="fn-bracket">]</span></span>
<p class="translated">Embora <code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> seja verdadeiro matematicamente, para números flutuantes pode não ser verdadeiro numericamente devido ao arredondamento. Por exemplo, e presumindo uma plataforma na qual um float Python seja um número de precisão dupla IEEE 754, para que <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> tenha o mesmo sinal que <code class="docutils literal notranslate"><span class="pre">1e100</span></code>, o resultado calculado é <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code>, que é numericamente exatamente igual a <code class="docutils literal notranslate"><span class="pre">1e100</span></code>. A função <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> retorna um resultado cujo sinal corresponde ao sinal do primeiro argumento e, portanto, retorna <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> neste caso. Qual abordagem é mais apropriada depende da aplicação.</p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">2</a><span class="fn-bracket">]</span></span>
<p class="translated">Se x estiver muito próximo de um múltiplo inteiro exato de y, é possível que <code class="docutils literal notranslate"><span class="pre">x//y</span></code> seja maior que <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> devido ao arredondamento. Nesses casos, Python retorna o último resultado, para preservar que <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> esteja muito próximo de <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">3</a><span class="fn-bracket">]</span></span>
<p class="translated">O padrão Unicode distingue entre <em class="dfn">pontos de código</em> (por exemplo, U+0041) e <em class="dfn">caracteres abstratos</em> (por exemplo, “LATIN CAPITAL LETTER A”). Embora a maioria dos caracteres abstratos em Unicode sejam representados apenas por meio de um ponto de código, há vários caracteres abstratos que também podem ser representados por meio de uma sequência de mais de um ponto de código. Por exemplo, o caractere abstrato “LATIN CAPITAL LETTER C WITH CEDILLA” pode ser representado como um único <em class="dfn">caractere pré-composto</em> na posição de código U+00C7, ou como uma sequência de um <em class="dfn">caractere base</em> na posição de código U+0043 (LATIN CAPITAL LETTER C), seguido por um <em class="dfn">caractere de combinação</em> na posição de código U+0327 (COMBINING CEDILLA).</p>
<p class="translated">Os operadores de comparação em strings são comparados no nível dos pontos de código Unicode. Isso pode ser contraintuitivo para os humanos. Por exemplo, <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> é <code class="docutils literal notranslate"><span class="pre">False</span></code>, mesmo que ambas as strings representem o mesmo caractere abstrato “LATIN CAPITAL LETTER C WITH CEDILLA”.</p>
<p class="translated">Para comparar strings no nível de caracteres abstratos (ou seja, de uma forma intuitiva para humanos), use <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a>.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">4</a><span class="fn-bracket">]</span></span>
<p class="translated">Devido à coleta de lixo automática, às listas livres e à natureza dinâmica dos descritores, você pode notar um comportamento aparentemente incomum em certos usos do operador <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, como aqueles que envolvem comparações entre métodos de instância ou constantes. Confira a documentação para obter mais informações.</p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">5</a><span class="fn-bracket">]</span></span>
<p class="translated">O operador de potência <code class="docutils literal notranslate"><span class="pre">**</span></code> liga-se com menos força do que um operador aritmético ou unário bit a bit à sua direita, ou seja, <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> é <code class="docutils literal notranslate"><span class="pre">0.5</span></code>.</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">6</a><span class="fn-bracket">]</span></span>
<p class="translated">O operador <code class="docutils literal notranslate"><span class="pre">%</span></code> também é usado para formatação de strings; a mesma precedência se aplica.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. Expressões</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. Conversões aritméticas</a></li>
<li><a class="reference internal" href="#atoms">6.2. Átomos</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. Identificadores (Nomes)</a><ul>
<li><a class="reference internal" href="#index-5">6.2.1.1. Desfiguração de nome privado</a></li>
</ul>
</li>
<li><a class="reference internal" href="#literals">6.2.2. Literais</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. Formas de parênteses</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. Sintaxe de criação de listas, conjuntos e dicionários</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. Sintaxes de criação de lista</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. Sintaxes de criação de conjunto</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. Sintaxes de criação de dicionário</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. Expressões geradoras</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Expressões yield</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. Métodos de iterador gerador</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. Exemplos</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. Funções geradoras assíncronas</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Métodos geradores-iteradores assíncronos</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. Primárias</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. Referências de atributo</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. Subscrições</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. Fatiamentos</a></li>
<li><a class="reference internal" href="#calls">6.3.4. Chamadas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Expressão await</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. O operador de potência</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. Operações aritméticas unárias e bit a bit</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. Operações binárias aritméticas</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. Operações de deslocamento</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. Operações binárias bit a bit</a></li>
<li><a class="reference internal" href="#comparisons">6.10. Comparações</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. Comparações de valor</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. Operações de teste de pertinência</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. Comparações de identidade</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. Operações booleanas</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. Expressões de atribuição</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. Expressões condicionais</a></li>
<li><a class="reference internal" href="#lambda">6.14. Lambdas</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. Listas de expressões</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. Ordem de avaliação</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. Precedência de operadores</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="import.html"
                          title="capítulo anterior"><span class="section-number">5. </span>O sistema de importação</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="próximo capítulo"><span class="section-number">7. </span>Instruções simples</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. Instruções simples"
             >próximo</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. O sistema de importação"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >A Referência da Linguagem Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Expressões</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>