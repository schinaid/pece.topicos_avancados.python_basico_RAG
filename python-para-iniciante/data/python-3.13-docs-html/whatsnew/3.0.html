<!DOCTYPE html>

<html lang="pt-BR" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="O que há de novo no Python 3.0" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/3.0.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Autor, Guido van Rossum,. Este artigo explica os novos recursos do Python 3.0, em comparação com o 2.6. O Python 3.0, também conhecido como “Python 3000” ou “Py3K”, é o primeiro lançamento do Pytho..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_whatsnew_3.0_52d2b56b.png" />
<meta property="og:image:alt" content="Autor, Guido van Rossum,. Este artigo explica os novos recursos do Python 3.0, em comparação com o 2.6. O Python 3.0, também conhecido como “Python 3000” ou “Py3K”, é o primeiro lançamento do Pytho..." />
<meta name="description" content="Autor, Guido van Rossum,. Este artigo explica os novos recursos do Python 3.0, em comparação com o 2.6. O Python 3.0, também conhecido como “Python 3000” ou “Py3K”, é o primeiro lançamento do Pytho..." />
<meta name="twitter:card" content="summary_large_image" />

    <title>O que há de novo no Python 3.0 &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=62a4a58b"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=71a39b36"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="copyright" title="Direitos autorais" href="../copyright.html" />
    <link rel="next" title="O que há de novo no Python 2.7" href="2.7.html" />
    <link rel="prev" title="O que há de novo no Python 3.1" href="3.1.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/3.0.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">O que há de novo no Python 3.0</a><ul>
<li><a class="reference internal" href="#common-stumbling-blocks">Obstáculos comuns</a><ul>
<li><a class="reference internal" href="#print-is-a-function">print é uma função</a></li>
<li><a class="reference internal" href="#views-and-iterators-instead-of-lists">Visualizações e iteradores em vez de listas</a></li>
<li><a class="reference internal" href="#ordering-comparisons">Comparações de ordenação</a></li>
<li><a class="reference internal" href="#integers">Inteiros</a></li>
<li><a class="reference internal" href="#text-vs-data-instead-of-unicode-vs-8-bit">Texto vs. Dados em vez de Unicode vs. 8 bits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-syntax-changes">Visão geral das alterações da sintaxe</a><ul>
<li><a class="reference internal" href="#new-syntax">Nova sintaxe</a></li>
<li><a class="reference internal" href="#changed-syntax">Sintaxe alterada</a></li>
<li><a class="reference internal" href="#removed-syntax">Sintaxe removida</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes-already-present-in-python-2-6">Mudanças já presentes no Python 2.6</a></li>
<li><a class="reference internal" href="#library-changes">Mudanças na biblioteca</a></li>
<li><a class="reference internal" href="#pep-3101-a-new-approach-to-string-formatting"><strong>PEP 3101</strong>: Uma nova abordagem para formatação de strings</a></li>
<li><a class="reference internal" href="#changes-to-exceptions">Mudanças para exceções</a></li>
<li><a class="reference internal" href="#miscellaneous-other-changes">Outras mudanças diversas</a><ul>
<li><a class="reference internal" href="#operators-and-special-methods">Operadores e métodos especiais</a></li>
<li><a class="reference internal" href="#builtins">Funções embutidas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">Mudanças a construções e API C</a></li>
<li><a class="reference internal" href="#performance">Desempenho</a></li>
<li><a class="reference internal" href="#porting-to-python-3-0">Portando para o Python 3.0</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="3.1.html"
                          title="capítulo anterior">O que há de novo no Python 3.1</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="2.7.html"
                          title="próximo capítulo">O que há de novo no Python 2.7</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/3.0.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="O que há de novo no Python 2.7"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="3.1.html" title="O que há de novo no Python 3.1"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">O que há de novo no Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">O que há de novo no Python 3.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-3-0">
<h1 class="translated">O que há de novo no Python 3.0<a class="headerlink" href="#what-s-new-in-python-3-0" title="Link para este cabeçalho">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">Autor<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">Guido van Rossum</p>
</dd>
</dl>
<p class="translated">Este artigo explica os novos recursos do Python 3.0, em comparação com o 2.6. O Python 3.0, também conhecido como “Python 3000” ou “Py3K”, é o primeiro lançamento do Python <em>intencionalmente incompatível com versões anteriores</em>. O Python 3.0 foi lançado em 3 de dezembro de 2008. Há mais mudanças do que em um lançamento típico, e mais que são importantes para todos os usuários do Python. No entanto, depois de digerir as mudanças, você verá que o Python realmente não mudou tanto assim – em geral, estamos principalmente corrigindo aborrecimentos bem conhecidos, e removendo muita sujeira antiga.</p>
<p class="translated">Este artigo não tenta fornecer uma especificação completa de todos os novos recursos, mas tenta dar uma visão geral conveniente. Para detalhes completos, você deve consultar a documentação do Python 3.0 e/ou as muitas PEPs referenciadas no texto. Se você quiser entender a implementação completa e a lógica de design para um recurso específico, as PEPs geralmente têm mais detalhes do que a documentação regular; mas observe que as PEPs geralmente não são mantidas atualizadas depois que um recurso foi totalmente implementado.</p>
<p class="translated">Devido a restrições de tempo, este documento não está tão completo quanto deveria ser. Como sempre para um novo lançamento, o arquivo <code class="docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> na distribuição fonte contém uma riqueza de informações detalhadas sobre cada pequena coisa que foi alterada.</p>
<section id="common-stumbling-blocks">
<h2 class="translated">Obstáculos comuns<a class="headerlink" href="#common-stumbling-blocks" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Esta seção lista as poucas mudanças que provavelmente irão lhe atrapalhar se você estiver acostumado com o Python 2.5.</p>
<section id="print-is-a-function">
<h3 class="translated">print é uma função<a class="headerlink" href="#print-is-a-function" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">A instrução <code class="docutils literal notranslate"><span class="pre">print</span></code> foi substituída por uma função <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>, com argumentos nomeados para substituir a maior parte da sintaxe especial da antiga instrução <code class="docutils literal notranslate"><span class="pre">print</span></code> (<span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-3105/"><strong>PEP 3105</strong></a>). Exemplos:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Antigo</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;The answer is&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span>
<span class="n">Novo</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The answer is&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

<span class="n">Antigo</span><span class="p">:</span> <span class="nb">print</span> <span class="n">x</span><span class="p">,</span>           <span class="c1"># Vírgula no final suprime nova linha</span>
<span class="n">Novo</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>  <span class="c1"># Anexa um espaço em vez de uma nova linha</span>

<span class="n">Antigo</span><span class="p">:</span> <span class="nb">print</span>              <span class="c1"># Exibe uma nova linha</span>
<span class="n">Novo</span><span class="p">:</span> <span class="nb">print</span><span class="p">()</span>            <span class="c1"># Você precisa chamar a função!</span>

<span class="n">Antigo</span><span class="p">:</span> <span class="nb">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;fatal error&quot;</span>
<span class="n">Novo</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fatal error&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="n">Antigo</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>       <span class="c1"># Exibe repr((x, y))</span>
<span class="n">Novo</span><span class="p">:</span> <span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>      <span class="c1"># Não é o mesmo que print(x, y)!</span>
</pre></div>
</div>
<p class="translated">Você também pode personalizar o separador entre itens, por exemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Há &lt;&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;&gt; possibilidades!&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">que produz:</p>
<div class="translated highlight-none notranslate"><div class="highlight"><pre><span></span>Há &lt;4294967296&gt; possibilidades!
</pre></div>
</div>
<p class="translated">Nota:</p>
<ul class="simple">
<li><p class="translated">A função <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> não tem suporte ao recurso “softspace” da antiga instrução <code class="docutils literal notranslate"><span class="pre">print</span></code>. Por exemplo, no Python 2.x, <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;A\n&quot;,</span> <span class="pre">&quot;B&quot;</span></code> escreveria <code class="docutils literal notranslate"><span class="pre">&quot;A\nB\n&quot;</span></code>; mas no Python 3.0, <code class="docutils literal notranslate"><span class="pre">print(&quot;A\n&quot;,</span> <span class="pre">&quot;B&quot;)</span></code> escreve <code class="docutils literal notranslate"><span class="pre">&quot;A\n</span> <span class="pre">B\n&quot;</span></code>.</p></li>
<li><p class="translated">Inicialmente, você vai se pegar digitando o antigo <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">x</span></code> bastante no modo interativo. É hora de treinar seus dedos para digitar <code class="docutils literal notranslate"><span class="pre">print(x)</span></code> em vez disso!</p></li>
<li><p class="translated">Ao usar a ferramenta de conversão de fonte para fonte <code class="docutils literal notranslate"><span class="pre">2to3</span></code>, todas as instruções <code class="docutils literal notranslate"><span class="pre">print</span></code> são automaticamente convertidas em chamadas de função <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>, então isso geralmente não é um problema para projetos maiores.</p></li>
</ul>
</section>
<section id="views-and-iterators-instead-of-lists">
<h3 class="translated">Visualizações e iteradores em vez de listas<a class="headerlink" href="#views-and-iterators-instead-of-lists" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Algumas APIs conhecidas não retornam mais listas:</p>
<ul>
<li><p class="translated">Os métodos <a class="reference internal" href="../library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> de <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> retornam visualizações, ou “views”, em vez de listas. Por exemplo, isso não funciona mais: <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">d.keys();</span> <span class="pre">k.sort()</span></code>. Use <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">sorted(d)</span></code> em vez disso (isso funciona no Python 2.5 também e é igualmente eficiente).</p></li>
<li><p class="translated">Além disso, os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.iterkeys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.iteritems()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.itervalues()</span></code> não são mais suportados.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> e <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> retornam iteradores. Se você realmente precisa de uma lista e as sequências de entrada são todas de comprimento igual, uma solução rápida é envolver <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> em <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a>, por exemplo, <code class="docutils literal notranslate"><span class="pre">list(map(...))</span></code>, mas uma solução melhor é frequentemente usar uma compreensão de lista (especialmente quando o código original usa <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>), ou reescrever o código para que ele não precise de uma lista. Particularmente complicado é <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> invocado para os efeitos colaterais da função; a transformação correta é usar um laço <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> regular (já que criar uma lista seria apenas desperdício).</p>
<p class="translated">Se as sequências de entrada não tiverem o mesmo comprimento, <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> irá parar no término da mais curta das sequências. Para compatibilidade total com <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> do Python 2.x, também envolva as sequências em <a class="reference internal" href="../library/itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a>, por exemplo, <code class="docutils literal notranslate"><span class="pre">map(func,</span> <span class="pre">*sequences)</span></code> se torna <code class="docutils literal notranslate"><span class="pre">list(map(func,</span> <span class="pre">itertools.zip_longest(*sequences)))</span></code>.</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a> agora se comporta como <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> costumava se comportar, exceto que funciona com valores de tamanho arbitrário. Este último não existe mais.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> agora retorna um iterador.</p></li>
</ul>
</section>
<section id="ordering-comparisons">
<h3 class="translated">Comparações de ordenação<a class="headerlink" href="#ordering-comparisons" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">O Python 3.0 simplificou as regras para ordenar comparações:</p>
<ul class="simple">
<li><p class="translated">Os operadores de comparação de ordenação (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) levantam uma exceção TypeError quando os operandos não têm uma ordenação natural significativa. Assim, expressões como <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&gt;</span> <span class="pre">None</span></code> ou <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&lt;=</span> <span class="pre">len</span></code> não são mais válidas e, por exemplo, <code class="docutils literal notranslate"><span class="pre">None</span> <span class="pre">&lt;</span> <span class="pre">None</span></code> levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> em vez de retornar <code class="docutils literal notranslate"><span class="pre">False</span></code>. Um corolário é que classificar uma lista heterogênea não faz mais sentido – todos os elementos devem ser comparáveis entre si. Observe que isso não se aplica aos operadores <code class="docutils literal notranslate"><span class="pre">==</span></code> e <code class="docutils literal notranslate"><span class="pre">!=</span></code>: objetos de diferentes tipos incomparáveis sempre são comparados de forma diferente entre si.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sorted()</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> não aceitam mais o argumento <em>cmp</em> fornecendo uma função de comparação. Use o argumento <em>key</em> em vez disso. N.B. os argumentos <em>key</em> e <em>reverse</em> agora são “somente-nomeados”.</p></li>
<li><p class="translated">A função <code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code> deve ser tratada como extinta, e o método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> não é mais suportado. Use <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> para classificação, <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> com <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> e outras comparações avançadas conforme necessário. (Se você realmente precisa da funcionalidade <code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code>, pode usar a expressão <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&gt;</span> <span class="pre">b)</span> <span class="pre">-</span> <span class="pre">(a</span> <span class="pre">&lt;</span> <span class="pre">b)</span></code> como o equivalente para <code class="docutils literal notranslate"><span class="pre">cmp(a,</span> <span class="pre">b)</span></code>.)</p></li>
</ul>
</section>
<section id="integers">
<h3 class="translated">Inteiros<a class="headerlink" href="#integers" title="Link para este cabeçalho">¶</a></h3>
<ul class="simple">
<li><p class="translated"><span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a>: Essencialmente, <code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code> foi renomeado para <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. Ou seja, há apenas um tipo integral embutido, chamado <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>; mas ele se comporta principalmente como o antigo tipo <code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code>.</p></li>
<li><p class="translated"><span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>: Uma expressão como <code class="docutils literal notranslate"><span class="pre">1/2</span></code> retorna um float. Use <code class="docutils literal notranslate"><span class="pre">1//2</span></code> para obter o comportamento de truncamento. (A última sintaxe existe há anos, pelo menos desde o Python 2.2.)</p></li>
<li><p class="translated">A constante <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxint</span></code> foi removida, pois não há mais um limite para o valor de inteiros. No entanto, <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> pode ser usado como um inteiro maior do que qualquer lista prática ou índice de string. Ele está em conformidade com o tamanho inteiro “natural” da implementação e é tipicamente o mesmo que <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxint</span></code> em versões anteriores na mesma plataforma (assumindo as mesmas opções de construção).</p></li>
<li><p class="translated">O <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de um inteiro longo não inclui mais o <code class="docutils literal notranslate"><span class="pre">L</span></code> final, então o código que remove esse caractere incondicionalmente cortará o último dígito. (Use <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> em vez disso.)</p></li>
<li><p class="translated">Literais octais não estão mais no formato <code class="docutils literal notranslate"><span class="pre">0720</span></code>; em vez disso, use <code class="docutils literal notranslate"><span class="pre">0o720</span></code>.</p></li>
</ul>
</section>
<section id="text-vs-data-instead-of-unicode-vs-8-bit">
<h3 class="translated">Texto vs. Dados em vez de Unicode vs. 8 bits<a class="headerlink" href="#text-vs-data-instead-of-unicode-vs-8-bit" title="Link para este cabeçalho">¶</a></h3>
<p class="translated">Tudo o que você achava que sabia sobre dados binários e Unicode mudou.</p>
<ul class="simple">
<li><p class="translated">O Python 3.0 usa os conceitos de <em>texto</em> e <em>dados</em> (binários) em vez de strings Unicode e strings de 8 bits. Todo texto é Unicode; no entanto, o Unicode <em>codificado</em> é representado como dados binários. O tipo usado para armazenar texto é <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, o tipo usado para armazenar dados é <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. A maior diferença com a situação 2.x é que qualquer tentativa de misturar texto e dados no Python 3.0 levanta <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, enquanto que se você misturasse strings Unicode e de 8 bits no Python 2.x, funcionaria se a string de 8 bits contivesse apenas bytes de 7 bits (ASCII), mas você obteria <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> se contivesse valores não ASCII. Esse comportamento específico de valor causou inúmeras caras tristes ao longo dos anos.</p></li>
<li><p class="translated">Como consequência dessa mudança na filosofia, praticamente todo código que usa Unicode, codificações ou dados binários provavelmente terá que mudar. A mudança é para melhor, pois no mundo 2.x havia vários bugs relacionados à mistura de texto codificado e não codificado. Para estar preparado no Python 2.x, comece a usar <code class="xref py py-class docutils literal notranslate"><span class="pre">unicode</span></code> para todo texto não codificado e <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> apenas para dados binários ou codificados. Então a ferramenta <code class="docutils literal notranslate"><span class="pre">2to3</span></code> fará a maior parte do trabalho para você.</p></li>
<li><p class="translated">Você não pode mais usar literais <code class="docutils literal notranslate"><span class="pre">u&quot;...&quot;</span></code> para texto Unicode. No entanto, você deve usar literais <code class="docutils literal notranslate"><span class="pre">b&quot;...&quot;</span></code> para dados binários.</p></li>
<li><p class="translated">Como os tipos <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> não podem ser misturados, você deve sempre converter explicitamente entre eles. Use <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> para ir de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> para <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, e <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> para ir de <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> para <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Você também pode usar <code class="docutils literal notranslate"><span class="pre">bytes(s,</span> <span class="pre">encoding=...)</span></code> e <code class="docutils literal notranslate"><span class="pre">str(b,</span> <span class="pre">encoding=...)</span></code>, respectivamente.</p></li>
<li><p class="translated">Assim como <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, o tipo <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> é imutável. Há um tipo <em>mutável</em> separado para armazenar dados binários em buffer, <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Quase todas as APIs que aceitam <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> também aceitam <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. A API mutável é baseada em <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.MutableSequence</span></code></a>.</p></li>
<li><p class="translated">Todas as contrabarras em literais de strings brutas são interpretadas literalmente. Isso significa que os escapes <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> e <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> em strings brutas não são tratados de forma especial. Por exemplo, <code class="docutils literal notranslate"><span class="pre">r'\u20ac'</span></code> é uma string de 6 caracteres no Python 3.0, enquanto no 2.6, <code class="docutils literal notranslate"><span class="pre">ur'\u20ac'</span></code> era o único caractere “euro”. (É claro que essa mudança afeta apenas literais de strings brutas; o caractere euro é <code class="docutils literal notranslate"><span class="pre">'\u20ac'</span></code> no Python 3.0.)</p></li>
<li><p class="translated">O tipo abstrato embutido <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> foi removido. Use <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> em vez disso. Os tipos <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> não têm funcionalidade suficiente em comum para garantir uma classe base compartilhada. A ferramenta <code class="docutils literal notranslate"><span class="pre">2to3</span></code> (veja abaixo) substitui cada ocorrência de <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> por <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p></li>
<li><p class="translated">Arquivos abertos como arquivos texto (ainda o modo padrão para <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>) sempre usam uma codificação para mapear entre strings (na memória) e bytes (no disco). Arquivos binários (abertos com um <code class="docutils literal notranslate"><span class="pre">b</span></code> no argumento mode) sempre usam bytes na memória. Isso significa que se um arquivo for aberto usando um modo ou codificação incorretos, a E/S provavelmente falhará ruidosamente, em vez de produzir dados incorretos silenciosamente. Isso também significa que até mesmo usuários Unix terão que especificar o modo correto (texto ou binário) ao abrir um arquivo. Há uma codificação padrão dependente da plataforma, que em plataformas Unixy pode ser definida com a variável de ambiente <code class="docutils literal notranslate"><span class="pre">LANG</span></code> (e às vezes também com algumas outras variáveis de ambiente relacionadas à localidade específicas da plataforma). Em muitos casos, mas não em todos, o padrão do sistema é UTF-8; você nunca deve contar com esse padrão. Qualquer aplicação que leia ou escreva mais do que texto ASCII puro provavelmente deve ter uma maneira de substituir a codificação. Não há mais necessidade de usar os fluxos com reconhecimento de codificação no módulo <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>.</p></li>
<li><p class="translated">Os valores iniciais de <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> e <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> agora são arquivos texto somente unicode (ou seja, são instâncias de <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>). Para ler e gravar dados de bytes com esses fluxos, você precisa usar o atributo <a class="reference internal" href="../library/io.html#io.TextIOBase.buffer" title="io.TextIOBase.buffer"><code class="xref py py-data docutils literal notranslate"><span class="pre">io.TextIOBase.buffer</span></code></a> deles.</p></li>
<li><p class="translated">Nomes de arquivo são passados e retornados de APIs como strings (Unicode). Isso pode apresentar problemas específicos de plataforma porque em algumas plataformas nomes de arquivo são strings de bytes arbitrárias. (Por outro lado, no Windows nomes de arquivo são armazenados nativamente como Unicode.) Como solução alternativa, a maioria das APIs (por exemplo, <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> e muitas funções no módulo <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>) que aceitam nomes de arquivo aceitam objetos <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> assim como strings, e algumas APIs têm uma maneira de pedir um valor de retorno <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Assim, <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> retorna uma lista de instâncias <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> se o argumento for uma instância <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, e <a class="reference internal" href="../library/os.html#os.getcwdb" title="os.getcwdb"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwdb()</span></code></a> retorna o diretório de trabalho atual como uma instância <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Observe que quando <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> retorna uma lista de strings, os nomes de arquivos que não podem ser decodificados corretamente são omitidos em vez de levantar <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p></li>
<li><p class="translated">Algumas APIs de sistema como <a class="reference internal" href="../library/os.html#os.environ" title="os.environ"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.environ</span></code></a> e <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> também podem apresentar problemas quando os bytes disponibilizados pelo sistema não são interpretáveis usando a codificação padrão. Definir a variável <code class="docutils literal notranslate"><span class="pre">LANG</span></code> e executar o programa novamente é provavelmente a melhor abordagem.</p></li>
<li><p class="translated"><span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-3138/"><strong>PEP 3138</strong></a>: A <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de uma string não escapa mais caracteres não-ASCII. No entanto, ele ainda escapa caracteres de controle e pontos de código com status não imprimível no padrão Unicode.</p></li>
<li><p class="translated"><span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-3120/"><strong>PEP 3120</strong></a>: A codificação de fontes padrão agora é UTF-8.</p></li>
<li><p class="translated"><span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-3131/"><strong>PEP 3131</strong></a>: Letras não ASCII agora são permitidas em identificadores. (No entanto, a biblioteca padrão permanece somente ASCII, com exceção dos nomes dos colaboradores nos comentários.)</p></li>
<li><p class="translated">Os módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">StringIO</span></code> e <code class="xref py py-mod docutils literal notranslate"><span class="pre">cStringIO</span></code> se foram. Em vez disso, importe o módulo <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> e use <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> ou <a class="reference internal" href="../library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> para texto e dados, respectivamente.</p></li>
<li><p class="translated">Veja também o guia <a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">Unicode</span></a>, que foi atualizado para o Python 3.0.</p></li>
</ul>
</section>
</section>
<section id="overview-of-syntax-changes">
<h2 class="translated">Visão geral das alterações da sintaxe<a class="headerlink" href="#overview-of-syntax-changes" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Esta seção fornece uma breve visão geral de cada mudança <em>sintática</em> no Python 3.0.</p>
<section id="new-syntax">
<h3 class="translated">Nova sintaxe<a class="headerlink" href="#new-syntax" title="Link para este cabeçalho">¶</a></h3>
<ul>
<li><p class="translated"><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-3107/"><strong>PEP 3107</strong></a>: Anotações de argumento de função e valor de retorno. Isso fornece uma maneira padronizada de anotar os parâmetros e o valor de retorno de uma função. Não há semântica anexada a essas anotações, exceto que elas podem ser introspectadas em tempo de execução usando o atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>. A intenção é encorajar a experimentação por meio de metaclasses, decoradores ou frameworks.</p></li>
<li><p class="translated"><span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-3102/"><strong>PEP 3102</strong></a>: Argumentos somente-nomeados. Parâmetros nomeados que ocorrem após <code class="docutils literal notranslate"><span class="pre">*args</span></code> na lista de parâmetros <em>devem</em> ser especificados usando a sintaxe dos nomes na chamada. Você também pode usar um <code class="docutils literal notranslate"><span class="pre">*</span></code> simples na lista de parâmetros para indicar que não aceita uma lista de argumentos de comprimento variável, mas tem argumentos somente-nomeados.</p></li>
<li><p class="translated">Argumentos nomeados são permitidos após a lista de classes base em uma definição de classe. Isso é usado pela nova convenção para especificar uma metaclasse (veja a próxima seção), mas pode ser usado para outros propósitos também, desde que a metaclasse dê suporte.</p></li>
<li><p class="translated"><span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-3104/"><strong>PEP 3104</strong></a>: instrução <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a>. Usando <code class="docutils literal notranslate"><span class="pre">nonlocal</span> <span class="pre">x</span></code>, agora você pode atribuir diretamente a uma variável em um escopo externo (mas não global). <code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> é uma nova palavra reservada.</p></li>
<li><p class="translated"><span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-3132/"><strong>PEP 3132</strong></a>: Desempacotamento iterável estendido. Agora você pode escrever coisas como <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">*rest</span> <span class="pre">=</span> <span class="pre">some_sequence</span></code>. E até mesmo <code class="docutils literal notranslate"><span class="pre">*rest,</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">stuff</span></code>. O objeto <code class="docutils literal notranslate"><span class="pre">rest</span></code> é sempre uma lista (possivelmente vazia); o lado direito pode ser qualquer iterável. Exemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Isso define <em>a</em> como <code class="docutils literal notranslate"><span class="pre">0</span></code>, <em>b</em> como <code class="docutils literal notranslate"><span class="pre">4</span></code> e <em>rest</em> como <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>.</p>
</li>
<li><p class="translated">Compreensões de dicionário: <code class="docutils literal notranslate"><span class="pre">{k:</span> <span class="pre">v</span> <span class="pre">for</span> <span class="pre">k,</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">stuff}</span></code> significa a mesma coisa que <code class="docutils literal notranslate"><span class="pre">dict(stuff)</span></code>, mas é mais flexível. (Isto é <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0274/"><strong>PEP 274</strong></a> justificada. :-)</p></li>
<li><p class="translated">Definir literais, por exemplo, <code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">2}</span></code>. Note que <code class="docutils literal notranslate"><span class="pre">{}</span></code> é um dicionário vazio; use <code class="docutils literal notranslate"><span class="pre">set()</span></code> para um conjunto vazio. Compreensões de conjuntos também são suportadas; por exemplo, <code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">stuff}</span></code> significa a mesma coisa que <code class="docutils literal notranslate"><span class="pre">set(stuff)</span></code>, mas é mais flexível.</p></li>
<li><p class="translated">Novos literais octais, por exemplo, <code class="docutils literal notranslate"><span class="pre">0o720</span></code> (já em 2.6). Os antigos literais octais (<code class="docutils literal notranslate"><span class="pre">0720</span></code>) se foram.</p></li>
<li><p class="translated">Novos literais binários, por exemplo, <code class="docutils literal notranslate"><span class="pre">0b1010</span></code> (já em 2.6), e há uma nova função embutida correspondente, <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>.</p></li>
<li><p class="translated">Literais de bytes são introduzidos com um <code class="docutils literal notranslate"><span class="pre">b</span></code> ou <code class="docutils literal notranslate"><span class="pre">B</span></code> no início, e há uma nova função embutida correspondente, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a>.</p></li>
</ul>
</section>
<section id="changed-syntax">
<h3 class="translated">Sintaxe alterada<a class="headerlink" href="#changed-syntax" title="Link para este cabeçalho">¶</a></h3>
<ul>
<li><p class="translated"><span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-3109/"><strong>PEP 3109</strong></a> e <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a>: nova sintaxe da instrução <a class="reference internal" href="../reference/simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a>: <code class="samp docutils literal notranslate"><span class="pre">raise</span> <span class="pre">[</span><em><span class="pre">expr</span></em> <span class="pre">[from</span> <em><span class="pre">expr</span></em><span class="pre">]]</span></code>. Veja abaixo.</p></li>
<li><p class="translated"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> e <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> agora são palavras reservadas. (Desde a versão 2.6, na verdade.)</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> e <code class="docutils literal notranslate"><span class="pre">None</span></code> são palavras reservadas. (A versão 2.6 já aplicava parcialmente as restrições em <code class="docutils literal notranslate"><span class="pre">None</span></code>.)</p></li>
<li><p class="translated">Alteração de <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> <em>exc</em>, <em>var</em> para <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> <em>exc</em> <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> <em>var</em>. Veja a <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-3110/"><strong>PEP 3110</strong></a>.</p></li>
<li><p class="translated"><span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-3115/"><strong>PEP 3115</strong></a>: Nova sintaxe de metaclasse. Em vez de:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">M</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">agora você deve usar:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">M</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">A variável global do módulo <code class="xref py py-data docutils literal notranslate"><span class="pre">__metaclass__</span></code> não é mais suportada. (Era uma ajuda para facilitar a mudança do padrão para classes de novo estilo sem derivar cada classe de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.)</p>
</li>
<li><p class="translated">As compreensões de lista não têm mais suporte a mais a forma sintática <code class="samp docutils literal notranslate"><span class="pre">[...</span> <span class="pre">for</span> <em><span class="pre">var</span></em> <span class="pre">in</span> <em><span class="pre">item1</span></em><span class="pre">,</span> <em><span class="pre">item2</span></em><span class="pre">,</span> <span class="pre">...]</span></code>. Use <code class="samp docutils literal notranslate"><span class="pre">[...</span> <span class="pre">for</span> <em><span class="pre">var</span></em> <span class="pre">in</span> <span class="pre">(</span><em><span class="pre">item1</span></em><span class="pre">,</span> <em><span class="pre">item2</span></em><span class="pre">,</span> <span class="pre">...)]</span></code> em vez disso. Observe também que as compreensões de lista têm semântica diferente: elas estão mais próximas do açúcar sintático para uma expressão geradora dentro de um construtor <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a> e, em particular, as variáveis de controle de laço não são mais vazadas para o escopo circundante.</p></li>
<li><p class="translated">As <em>reticências</em> (<code class="docutils literal notranslate"><span class="pre">...</span></code>) podem ser usadas como uma expressão atômica em qualquer lugar. (Anteriormente, eram permitidas apenas em fatias.) Além disso, agora <em>devem</em> ser escritas como <code class="docutils literal notranslate"><span class="pre">...</span></code>. (Anteriormente, também poderiam ser escritas como <code class="docutils literal notranslate"><span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span></code>, por um mero acidente da gramática.)</p></li>
</ul>
</section>
<section id="removed-syntax">
<h3 class="translated">Sintaxe removida<a class="headerlink" href="#removed-syntax" title="Link para este cabeçalho">¶</a></h3>
<ul class="simple">
<li><p class="translated"><span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-3113/"><strong>PEP 3113</strong></a>: Desempacotamento de parâmetro de tupla removido. Você não pode mais escrever <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">(b,</span> <span class="pre">c)):</span> <span class="pre">...</span></code>. Em vez disso, use <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">b_c):</span> <span class="pre">b,</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">b_c</span></code>.</p></li>
<li><p class="translated">Removidos backticks (use <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>).</p></li>
<li><p class="translated">Removido <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> (use <code class="docutils literal notranslate"><span class="pre">!=</span></code>).</p></li>
<li><p class="translated">Removida palavra reservada: <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> não é mais uma palavra reservada; ela permanece como uma função. (Felizmente a sintaxe da função também era aceita nas versões 2.x.) Observe também que <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> não aceita mais um argumento de fluxo; em vez de <code class="docutils literal notranslate"><span class="pre">exec(f)</span></code> você pode usar <code class="docutils literal notranslate"><span class="pre">exec(f.read())</span></code>.</p></li>
<li><p class="translated">Literais de inteiro não mais têm suporte a um <code class="docutils literal notranslate"><span class="pre">l</span></code> ou <code class="docutils literal notranslate"><span class="pre">L</span></code> final.</p></li>
<li><p class="translated">Literais de string não mais têm suporte a um <code class="docutils literal notranslate"><span class="pre">u</span></code> ou <code class="docutils literal notranslate"><span class="pre">U</span></code> no início.</p></li>
<li><p class="translated">A sintaxe <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> <em>módulo</em> <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> <code class="docutils literal notranslate"><span class="pre">*</span></code> é permitida somente no nível do módulo, não mais dentro de funções.</p></li>
<li><p class="translated">A única sintaxe aceitável para importações relativas é <code class="samp docutils literal notranslate"><span class="pre">from</span> <span class="pre">.[</span><em><span class="pre">module</span></em><span class="pre">]</span> <span class="pre">import</span> <em><span class="pre">name</span></em></code>. Todos as formas de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> que não começam com <code class="docutils literal notranslate"><span class="pre">.</span></code> são interpretadas como importações absolutas. (<span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a>)</p></li>
<li><p class="translated">As classes clássicas se foram.</p></li>
</ul>
</section>
</section>
<section id="changes-already-present-in-python-2-6">
<h2 class="translated">Mudanças já presentes no Python 2.6<a class="headerlink" href="#changes-already-present-in-python-2-6" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Como muitos usuários provavelmente fazem o salto direto do Python 2.5 para o Python 3.0, esta seção lembra o leitor dos novos recursos que foram originalmente projetados para o Python 3.0, mas que foram portados de volta para o Python 2.6. As seções correspondentes em <a class="reference internal" href="2.6.html#whats-new-in-2-6"><span class="std std-ref">O que há de novo no Python 2.6</span></a> devem ser consultadas para descrições mais longas.</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-0343"><span class="std std-ref">PEP 343: The ‘with’ statement</span></a>. A instrução <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> agora é um recurso padrão e não precisa mais ser importada de <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>. Confira também <a class="reference internal" href="2.6.html#new-26-context-managers"><span class="std std-ref">Writing Context Managers</span></a> e <a class="reference internal" href="2.6.html#new-module-contextlib"><span class="std std-ref">The contextlib module</span></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-0366"><span class="std std-ref">PEP 366: Explicit Relative Imports From a Main Module</span></a>. Isso aumenta a utilidade da opção <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> quando o módulo referenciado reside em um pacote.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-0370"><span class="std std-ref">PEP 370: Per-user site-packages Directory</span></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-0371"><span class="std std-ref">PEP 371: The multiprocessing Package</span></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3101"><span class="std std-ref">PEP 3101: Advanced String Formatting</span></a>. Nota: a descrição da versão 2.6 menciona o método <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> para strings de 8 bits e Unicode. No 3.0, apenas o tipo <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> (strings de texto com suporte a Unicode) tem suporte a esse método; o tipo <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> não. O plano é eventualmente tornar esta a única API para formatação de strings e começar a descontinuar o operador <code class="docutils literal notranslate"><span class="pre">%</span></code> no Python 3.1.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3105"><span class="std std-ref">PEP 3105: print As a Function</span></a>. Este é agora um recurso padrão e não precisa mais ser importado de <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>. Mais detalhes foram fornecidos acima.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3110"><span class="std std-ref">PEP 3110: Exception-Handling Changes</span></a>. A sintaxe <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> <em>exc</em> <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> <em>var</em> agora é padrão e <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> <em>exc</em>, <em>var</em> não é mais suportado. (Claro, a parte <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> <em>var</em> ainda é opcional.)</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3112"><span class="std std-ref">PEP 3112: Byte Literals</span></a>. A notação de literal de string <code class="docutils literal notranslate"><span class="pre">b&quot;...&quot;</span></code> (e suas variantes como <code class="docutils literal notranslate"><span class="pre">b'...'</span></code>, <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;...&quot;&quot;&quot;</span></code> e <code class="docutils literal notranslate"><span class="pre">br&quot;...&quot;</span></code>) agora produz um literal do tipo <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3116"><span class="std std-ref">PEP 3116: New I/O Library</span></a>. O módulo <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> agora é a maneira padrão de fazer E/S de arquivo. A função embutida <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> agora é um apelido para <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a> e tem argumentos nomeados adicionais <em>encoding</em>, <em>errors</em>, <em>newline</em> e <em>closefd</em>. Observe também que um argumento <em>mode</em> inválido agora levanta <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, não <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>. O objeto arquivo binário subjacente a um objeto arquivo texto pode ser acessado como <code class="xref py py-attr docutils literal notranslate"><span class="pre">f.buffer</span></code> (mas tome cuidado, pois o objeto texto mantém um buffer de si mesmo para acelerar as operações de codificação e decodificação).</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3118"><span class="std std-ref">PEP 3118: Revised Buffer Protocol</span></a>. A antiga função embutida <code class="xref py py-func docutils literal notranslate"><span class="pre">buffer()</span></code> agora realmente se foi; a nova função embutida <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-func docutils literal notranslate"><span class="pre">memoryview()</span></code></a> fornece funcionalidade (principalmente) semelhante.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3119"><span class="std std-ref">PEP 3119: Abstract Base Classes</span></a>. O módulo <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> e as ABCs definidas no módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> desempenham um papel um pouco mais proeminente na linguagem agora, e tipos embutidos de coleção como <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> e <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> estão em conformidade com as ABCs <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.MutableMapping</span></code></a> e <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.MutableSequence</span></code></a>, respectivamente.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3127"><span class="std std-ref">PEP 3127: Integer Literal Support and Syntax</span></a>. Conforme mencionado acima, a nova notação de literal octal é a única suportada, e literais binários foram adicionados.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3129"><span class="std std-ref">PEP 3129: Class Decorators</span></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="2.6.html#pep-3141"><span class="std std-ref">PEP 3141: A Type Hierarchy for Numbers</span></a>. O módulo <a class="reference internal" href="../library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> é outro novo uso de ABCs, definindo a “torre numérica” do Python. Observe também o novo módulo <a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> que implementa <a class="reference internal" href="../library/numbers.html#numbers.Rational" title="numbers.Rational"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Rational</span></code></a>.</p></li>
</ul>
</section>
<section id="library-changes">
<h2 class="translated">Mudanças na biblioteca<a class="headerlink" href="#library-changes" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Devido a restrições de tempo, este documento não cobre exaustivamente as mudanças muito extensas na biblioteca padrão. <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-3108/"><strong>PEP 3108</strong></a> é a referência para as principais mudanças na biblioteca. Aqui está uma revisão resumida:</p>
<ul>
<li><p class="translated">Muitos módulos antigos foram removidos. Alguns, como <code class="xref py py-mod docutils literal notranslate"><span class="pre">gopherlib</span></code> (não mais usado) e <code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> (substituído por <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a>), já tinham sido descontinuados pela <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0004/"><strong>PEP 4</strong></a>. Outros foram removidos como resultado da remoção do suporte para várias plataformas, como Irix, BeOS e Mac OS 9 (veja <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0011/"><strong>PEP 11</strong></a>). Alguns módulos também foram selecionados para remoção no Python 3.0 devido à falta de uso ou porque existe uma substituição melhor. Veja <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-3108/"><strong>PEP 3108</strong></a> para uma lista exaustiva.</p></li>
<li><p class="translated">O pacote <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb3</span></code> foi removido porque sua presença na biblioteca padrão principal provou ao longo do tempo ser um fardo particular para os desenvolvedores principais devido à instabilidade dos testes e ao cronograma de lançamento do Berkeley DB. No entanto, o pacote está vivo e bem, mantido externamente em <a class="reference external" href="https://www.jcea.es/programacion/pybsddb.htm">https://www.jcea.es/programacion/pybsddb.htm</a>.</p></li>
<li><p class="translated">Alguns módulos foram renomeados porque seu nome antigo desobedecia a <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a>, ou por vários outros motivos. Aqui está a lista:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Old Name</p></th>
<th class="head"><p class="translated">Novo nome</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">_winreg</p></td>
<td><p class="translated">winreg</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">ConfigParser</p></td>
<td><p class="translated">configparser</p></td>
</tr>
<tr class="row-even"><td><p class="translated">copy_reg</p></td>
<td><p class="translated">copyreg</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">Queue</p></td>
<td><p class="translated">queue</p></td>
</tr>
<tr class="row-even"><td><p class="translated">SocketServer</p></td>
<td><p class="translated">socketserver</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">markupbase</p></td>
<td><p class="translated">_markupbase</p></td>
</tr>
<tr class="row-even"><td><p class="translated">repr</p></td>
<td><p class="translated">reprlib</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">test.test_support</p></td>
<td><p class="translated">test.support</p></td>
</tr>
</tbody>
</table>
</li>
<li><p class="translated">Um padrão comum no Python 2.x é ter uma versão de um módulo implementada em Python puro, com uma versão acelerada opcional implementada como uma extensão C; por exemplo, <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> e <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code>. Isso coloca o fardo de importar a versão acelerada e recorrer à versão Python pura em cada usuário desses módulos. No Python 3.0, as versões aceleradas são consideradas detalhes de implementação das versões Python puras. Os usuários devem sempre importar a versão padrão, que tenta importar a versão acelerada e recorrer à versão Python pura. O par <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> / <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> recebeu esse tratamento. O módulo <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> está na lista para 3.1. O módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">StringIO</span></code> foi transformado em uma classe no módulo <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>.</p></li>
<li><p class="translated">Alguns módulos relacionados foram agrupados em pacotes e, geralmente, os nomes dos submódulos foram simplificados. Os novos pacotes resultantes são:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: Interfaces to various Unix &quot;database&quot; formats."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">anydbm</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dbhash</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">dumbdbm</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">gdbm</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whichdb</span></code>).</p></li>
<li><p class="translated"><a class="reference internal" href="../library/html.html#module-html" title="html: Helpers for manipulating HTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">HTMLParser</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">htmlentitydefs</span></code>).</p></li>
<li><p class="translated"><a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">http</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">BaseHTTPServer</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">CGIHTTPServer</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleHTTPServer</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">Cookie</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cookielib</span></code>).</p></li>
<li><p class="translated"><a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a> (todos os módulos relacionados a <code class="docutils literal notranslate"><span class="pre">Tkinter</span></code>, exceto <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a>). O público-alvo de <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a> não se importa muito com <a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a>. Observe também que, a partir do Python 2.6, a funcionalidade de <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a> foi bastante aprimorada.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib2</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">urlparse</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparse</span></code>).</p></li>
<li><p class="translated"><a class="reference internal" href="../library/xmlrpc.html#module-xmlrpc" title="xmlrpc: Server and client modules implementing XML-RPC."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code>).</p></li>
</ul>
</li>
</ul>
<p class="translated">Algumas outras mudanças nos módulos da biblioteca padrão, não cobertas pela <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-3108/"><strong>PEP 3108</strong></a>:</p>
<ul class="simple">
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> eliminado. Use a classe embutida <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a>.</p></li>
<li><p class="translated">Limpeza do módulo <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>: removidos <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exitfunc()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_clear()</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exc_type</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exc_value</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exc_traceback</span></code>. (Observe que <a class="reference internal" href="../library/sys.html#sys.last_type" title="sys.last_type"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.last_type</span></code></a> etc. permanecem.)</p></li>
<li><p class="translated">Limpeza do tipo <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>: os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> foram removidos; use <a class="reference internal" href="../library/array.html#array.array.fromfile" title="array.array.fromfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fromfile()</span></code></a> e <a class="reference internal" href="../library/array.html#array.array.tofile" title="array.array.tofile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tofile()</span></code></a> em vez disso. Além disso, o typecode <code class="docutils literal notranslate"><span class="pre">'c'</span></code> para vetor foi removido – use <code class="docutils literal notranslate"><span class="pre">'b'</span></code> para bytes ou <code class="docutils literal notranslate"><span class="pre">'u'</span></code> para caracteres Unicode.</p></li>
<li><p class="untranslated">Cleanup of the <a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> module: removed
<code class="xref py py-func docutils literal notranslate"><span class="pre">sequenceIncludes()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">isCallable()</span></code>.</p></li>
<li><p class="translated">Limpeza do módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code>: <code class="xref py py-func docutils literal notranslate"><span class="pre">acquire_lock()</span></code> e <code class="xref py py-func docutils literal notranslate"><span class="pre">release_lock()</span></code> foram removidos; use <a class="reference internal" href="../library/threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> e <a class="reference internal" href="../library/threading.html#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> em vez disso.</p></li>
<li><p class="untranslated">Cleanup of the <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> module: removed the <code class="xref py py-func docutils literal notranslate"><span class="pre">jumpahead()</span></code> API.</p></li>
<li><p class="translated">O módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">new</span></code> foi removido.</p></li>
<li><p class="untranslated">The functions <code class="xref py py-func docutils literal notranslate"><span class="pre">os.tmpnam()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">os.tempnam()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">os.tmpfile()</span></code> have been removed in favor of the <a class="reference internal" href="../library/tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a>
module.</p></li>
<li><p class="translated">O módulo <a class="reference internal" href="../library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tokenize</span></code></a> foi alterado para funcionar com bytes. O ponto de entrada principal agora é <a class="reference internal" href="../library/tokenize.html#tokenize.tokenize" title="tokenize.tokenize"><code class="xref py py-func docutils literal notranslate"><span class="pre">tokenize.tokenize()</span></code></a>, em vez de generate_tokens.</p></li>
<li><p class="untranslated"><code class="xref py py-data docutils literal notranslate"><span class="pre">string.letters</span></code> and its friends (<code class="xref py py-data docutils literal notranslate"><span class="pre">string.lowercase</span></code> and
<code class="xref py py-data docutils literal notranslate"><span class="pre">string.uppercase</span></code>) are gone.  Use
<a class="reference internal" href="../library/string.html#string.ascii_letters" title="string.ascii_letters"><code class="xref py py-data docutils literal notranslate"><span class="pre">string.ascii_letters</span></code></a> etc. instead.  (The reason for the
removal is that <code class="xref py py-data docutils literal notranslate"><span class="pre">string.letters</span></code> and friends had
locale-specific behavior, which is a bad idea for such
attractively named global “constants”.)</p></li>
<li><p class="untranslated">Renamed module <code class="xref py py-mod docutils literal notranslate"><span class="pre">__builtin__</span></code> to <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> (removing the
underscores, adding an ‘s’).  The <code class="xref py py-data docutils literal notranslate"><span class="pre">__builtins__</span></code> variable
found in most global namespaces is unchanged.  To modify a builtin,
you should use <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, not <code class="xref py py-data docutils literal notranslate"><span class="pre">__builtins__</span></code>!</p></li>
</ul>
</section>
<section id="pep-3101-a-new-approach-to-string-formatting">
<h2 class="translated"><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-3101/"><strong>PEP 3101</strong></a>: Uma nova abordagem para formatação de strings<a class="headerlink" href="#pep-3101-a-new-approach-to-string-formatting" title="Link para este cabeçalho">¶</a></h2>
<ul class="simple">
<li><p class="translated">Um novo sistema para operações de formatação de strings embutidas substitui o operador de formatação de strings <code class="docutils literal notranslate"><span class="pre">%</span></code>. (No entanto, o operador <code class="docutils literal notranslate"><span class="pre">%</span></code> ainda é suportado; ele será descontinuado no Python 3.1 e removido da linguagem em algum momento posterior.) Leia a <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-3101/"><strong>PEP 3101</strong></a> para obter informações completas.</p></li>
</ul>
</section>
<section id="changes-to-exceptions">
<h2 class="translated">Mudanças para exceções<a class="headerlink" href="#changes-to-exceptions" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">As APIs para levantar e capturar exceções foram limpas e novos recursos poderosos foram adicionados:</p>
<ul>
<li><p class="translated"><span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0352/"><strong>PEP 352</strong></a>: Todas as exceções devem ser derivadas (direta ou indiretamente) de <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a>. Esta é a raiz da hierarquia de exceções. Isso não é novo como recomendação, mas o <em>requisito</em> para herdar de <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> é novo. (O Python 2.6 ainda permitia que classes clássicas fossem levantadas e não colocava nenhuma restrição sobre o que você pode capturar.) Como consequência, exceções de string estão finalmente verdadeira e completamente mortas.</p></li>
<li><p class="translated">Quase todas as exceções devem derivar de <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>; <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> deve ser usado apenas como uma classe base para exceções que devem ser manipuladas apenas no nível superior, como <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> ou <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>. O idioma recomendado para manipular todas as exceções, exceto para esta última categoria, é usar <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>.</p></li>
<li><p class="untranslated"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StandardError</span></code> was removed.</p></li>
<li><p class="untranslated">Exceptions no longer behave as sequences.  Use the <a class="reference internal" href="../library/exceptions.html#BaseException.args" title="BaseException.args"><code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code></a>
attribute instead.</p></li>
<li><p class="translated"><span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-3109/"><strong>PEP 3109</strong></a>: levantando exceções. Agora você deve usar <code class="samp docutils literal notranslate"><span class="pre">raise</span> <em><span class="pre">Exception</span></em><span class="pre">(</span><em><span class="pre">args</span></em><span class="pre">)</span></code> em vez de <code class="samp docutils literal notranslate"><span class="pre">raise</span> <em><span class="pre">Exception</span></em><span class="pre">,</span> <em><span class="pre">args</span></em></code>. Além disso, você não pode mais especificar explicitamente um traceback (situação da pilha de execução); em vez disso, se você <em>precisar</em> fazer isso, você pode atribuir diretamente ao atributo <a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> (veja abaixo).</p></li>
<li><p class="translated"><span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-3110/"><strong>PEP 3110</strong></a>: Capturando exceções. Agora você deve usar <code class="samp docutils literal notranslate"><span class="pre">except</span> <em><span class="pre">SomeException</span></em> <span class="pre">as</span> <em><span class="pre">variable</span></em></code> em vez de <code class="samp docutils literal notranslate"><span class="pre">except</span> <em><span class="pre">SomeException</span></em><span class="pre">,</span> <em><span class="pre">variable</span></em></code>. Além disso, a variável <em>variable</em> é explicitamente excluída quando o bloco <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> é deixado.</p></li>
<li><p class="translated"><span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a>: Encadeamento de exceções. Existem dois casos: encadeamento implícito e encadeamento explícito. O encadeamento implícito acontece quando uma exceção é levantada em um bloco manipulador <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> ou <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>. Isso geralmente acontece devido a um bug no bloco do manipulador; chamamos isso de exceção <em>secundária</em>. Nesse caso, a exceção original (que estava sendo manipulada) é salva como o atributo <a class="reference internal" href="../library/exceptions.html#BaseException.__context__" title="BaseException.__context__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code></a> da exceção secundária. O encadeamento explícito é invocado com esta sintaxe:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="n">SecondaryException</span><span class="p">()</span> <span class="kn">from</span><span class="w"> </span><span class="nn">primary_exception</span>
</pre></div>
</div>
<p class="translated">(onde <em>primary_exception</em> é qualquer expressão que produz um objeto de exceção, provavelmente uma exceção que foi capturada anteriormente). Neste caso, a exceção primária é armazenada no atributo <a class="reference internal" href="../library/exceptions.html#BaseException.__cause__" title="BaseException.__cause__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code></a> da exceção secundária. O traceback impresso quando uma exceção não tratada ocorre percorre a cadeia de atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> e <a class="reference internal" href="../library/exceptions.html#BaseException.__context__" title="BaseException.__context__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code></a> e imprime um traceback separado para cada componente da cadeia, com a exceção primária no topo. (Usuários Java podem reconhecer este comportamento.)</p>
</li>
<li><p class="translated"><span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a>: Objetos exceção agora armazenam seu traceback como o atributo <a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a>. Isso significa que um objeto de exceção agora contém todas as informações pertencentes a uma exceção, e há menos motivos para usar <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> (embora o último não seja removido).</p></li>
<li><p class="translated">Algumas mensagens de exceção estão melhores quando o Windows falha ao carregar um módulo de extensão. Por exemplo, <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">code</span> <span class="pre">193</span></code> agora é <code class="docutils literal notranslate"><span class="pre">%1</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">a</span> <span class="pre">valid</span> <span class="pre">Win32</span> <span class="pre">application</span></code>. As strings agora lidam com localidades que não sejam em inglês.</p></li>
</ul>
</section>
<section id="miscellaneous-other-changes">
<h2 class="translated">Outras mudanças diversas<a class="headerlink" href="#miscellaneous-other-changes" title="Link para este cabeçalho">¶</a></h2>
<section id="operators-and-special-methods">
<h3 class="translated">Operadores e métodos especiais<a class="headerlink" href="#operators-and-special-methods" title="Link para este cabeçalho">¶</a></h3>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">!=</span></code> agora retorna o oposto de <code class="docutils literal notranslate"><span class="pre">==</span></code>, a menos que <code class="docutils literal notranslate"><span class="pre">==</span></code> retorne <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p></li>
<li><p class="translated">O conceito de “métodos não vinculados” foi removido da linguagem. Ao referenciar um método como um atributo de classe, agora você obtém um objeto função simples.</p></li>
<li><p class="untranslated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getslice__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setslice__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delslice__()</span></code>
were killed.  The syntax <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> now translates to
<code class="docutils literal notranslate"><span class="pre">a.__getitem__(slice(i,</span> <span class="pre">j))</span></code> (or <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> or
<a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, when used as an assignment or deletion target,
respectively).</p></li>
<li><p class="translated"><span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-3114/"><strong>PEP 3114</strong></a>: o método padrão <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> foi renomeado para <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>.</p></li>
<li><p class="untranslated">The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__oct__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hex__()</span></code> special methods are removed
– <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> and <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> use <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> now to convert
the argument to an integer.</p></li>
<li><p class="untranslated">Removed support for <code class="xref py py-attr docutils literal notranslate"><span class="pre">__members__</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">__methods__</span></code>.</p></li>
<li><p class="translated">Os atributos de função chamados <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_X</span></code> foram renomeados para usar o formato <code class="xref py py-attr docutils literal notranslate"><span class="pre">__X__</span></code>, liberando esses nomes no espaço de nomes de atributos de função para atributos definidos pelo usuário. A saber, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_closure</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_code</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_defaults</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_dict</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_doc</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_globals</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_name</span></code> foram renomeados para <a class="reference internal" href="../reference/datamodel.html#function.__closure__" title="function.__closure__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#function.__code__" title="function.__code__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#function.__defaults__" title="function.__defaults__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#function.__dict__" title="function.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#function.__globals__" title="function.__globals__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, respectivamente.</p></li>
<li><p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__nonzero__()</span></code> agora é <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>.</p></li>
</ul>
</section>
<section id="builtins">
<h3 class="translated">Funções embutidas<a class="headerlink" href="#builtins" title="Link para este cabeçalho">¶</a></h3>
<ul class="simple">
<li><p class="translated"><span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-3135/"><strong>PEP 3135</strong></a>: Nova função <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>. Agora você pode invocar <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> sem argumentos e (presumindo que isso esteja em um método de instância regular definido dentro de uma instrução <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>) a classe e instância corretas serão automaticamente escolhidas. Com argumentos, o comportamento de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> não é alterado.</p></li>
<li><p class="untranslated"><span class="target" id="index-32"></span><a class="pep reference external" href="https://peps.python.org/pep-3111/"><strong>PEP 3111</strong></a>: <code class="xref py py-func docutils literal notranslate"><span class="pre">raw_input()</span></code> was renamed to <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a>.  That
is, the new <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> function reads a line from
<a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> and returns it with the trailing newline stripped.
It raises <a class="reference internal" href="../library/exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> if the input is terminated prematurely.
To get the old behavior of <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a>, use <code class="docutils literal notranslate"><span class="pre">eval(input())</span></code>.</p></li>
<li><p class="translated">Uma nova função embutido <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> foi adicionada para chamar o método <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> em um objeto.</p></li>
<li><p class="translated">A estratégia de arredondamento da função <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> e o tipo de retorno foram alterados. Casos exatos de meio caminho agora são arredondados para o resultado par mais próximo em vez de para longe de zero. (Por exemplo, <code class="docutils literal notranslate"><span class="pre">round(2.5)</span></code> agora retorna <code class="docutils literal notranslate"><span class="pre">2</span></code> em vez de <code class="docutils literal notranslate"><span class="pre">3</span></code>.) <code class="docutils literal notranslate"><span class="pre">round(x[,</span> <span class="pre">n])</span></code> agora delega para <code class="docutils literal notranslate"><span class="pre">x.__round__([n])</span></code> em vez de sempre retornar um float. Geralmente retorna um inteiro quando chamado com um único argumento e um valor do mesmo tipo que <code class="docutils literal notranslate"><span class="pre">x</span></code> quando chamado com dois argumentos.</p></li>
<li><p class="untranslated">Moved <code class="xref py py-func docutils literal notranslate"><span class="pre">intern()</span></code> to <a class="reference internal" href="../library/sys.html#sys.intern" title="sys.intern"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.intern()</span></code></a>.</p></li>
<li><p class="untranslated">Removed: <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code>.  Instead of <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args)</span></code> use
<code class="docutils literal notranslate"><span class="pre">f(*args)</span></code>.</p></li>
<li><p class="untranslated">Removed <a class="reference internal" href="../library/functions.html#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a>.  Instead of <code class="docutils literal notranslate"><span class="pre">callable(f)</span></code> you can use
<code class="docutils literal notranslate"><span class="pre">isinstance(f,</span> <span class="pre">collections.Callable)</span></code>.  The <code class="xref py py-func docutils literal notranslate"><span class="pre">operator.isCallable()</span></code>
function is also gone.</p></li>
<li><p class="untranslated">Removed <code class="xref py py-func docutils literal notranslate"><span class="pre">coerce()</span></code>.  This function no longer serves a purpose
now that classic classes are gone.</p></li>
<li><p class="untranslated">Removed <code class="xref py py-func docutils literal notranslate"><span class="pre">execfile()</span></code>.  Instead of <code class="docutils literal notranslate"><span class="pre">execfile(fn)</span></code> use
<code class="docutils literal notranslate"><span class="pre">exec(open(fn).read())</span></code>.</p></li>
<li><p class="untranslated">Removed the <code class="xref py py-class docutils literal notranslate"><span class="pre">file</span></code> type.  Use <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.  There are now several
different kinds of streams that open can return in the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> module.</p></li>
<li><p class="untranslated">Removed <code class="xref py py-func docutils literal notranslate"><span class="pre">reduce()</span></code>.  Use <a class="reference internal" href="../library/functools.html#functools.reduce" title="functools.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.reduce()</span></code></a> if you really
need it; however, 99 percent of the time an explicit <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>
loop is more readable.</p></li>
<li><p class="untranslated">Removed <code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code>.  Use <code class="xref py py-func docutils literal notranslate"><span class="pre">imp.reload()</span></code>.</p></li>
<li><p class="untranslated">Removed. <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.has_key()</span></code> – use the <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> operator
instead.</p></li>
</ul>
</section>
</section>
<section id="build-and-c-api-changes">
<h2 class="translated">Mudanças a construções e API C<a class="headerlink" href="#build-and-c-api-changes" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Devido a restrições de tempo, aqui está uma lista <em>muito</em> incompleta de alterações na API C.</p>
<ul class="simple">
<li><p class="translated">O suporte para várias plataformas foi descartado, incluindo, mas não se limitando a Mac OS 9, BeOS, RISCOS, Irix e Tru64.</p></li>
<li><p class="translated"><span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-3118/"><strong>PEP 3118</strong></a>: Nova API de Buffer.</p></li>
<li><p class="translated"><span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-3121/"><strong>PEP 3121</strong></a>: Inicialização e finalização do módulo de extensão.</p></li>
<li><p class="translated"><span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-3123/"><strong>PEP 3123</strong></a>: Tornando <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a> conforme o padrão C.</p></li>
<li><p class="translated">Não há mais suporte à API C para execução restrita.</p></li>
<li><p class="translated">As APIs C <code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Coerce()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_CoerceEx()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMember_Get()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMember_Set()</span></code> foram removidas.</p></li>
<li><p class="translated">Nova API C <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModuleNoBlock" title="PyImport_ImportModuleNoBlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModuleNoBlock()</span></code></a>, funciona como <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>, mas não bloqueia na trava de importação (retornando um erro).</p></li>
<li><p class="translated">Renomeado o slot e o método de nível C de conversão booleana: <code class="docutils literal notranslate"><span class="pre">nb_nonzero</span></code> agora é <code class="docutils literal notranslate"><span class="pre">nb_bool</span></code>.</p></li>
<li><p class="translated">Removidas <code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> e <code class="xref c c-macro docutils literal notranslate"><span class="pre">WITH_CYCLE_GC</span></code> da API C.</p></li>
</ul>
</section>
<section id="performance">
<h2 class="translated">Desempenho<a class="headerlink" href="#performance" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">O resultado líquido das generalizações do 3.0 é que o Python 3.0 executa o benchmark pystone cerca de 10% mais lento que o Python 2.5. Provavelmente a maior causa é a remoção do uso de maiúsculas e minúsculas especiais para números inteiros pequenos. Há espaço para melhorias, mas isso acontecerá após o lançamento do 3.0!</p>
</section>
<section id="porting-to-python-3-0">
<h2 class="translated">Portando para o Python 3.0<a class="headerlink" href="#porting-to-python-3-0" title="Link para este cabeçalho">¶</a></h2>
<p class="translated">Para portar o código-fonte existente do Python 2.5 ou 2.6 para o Python 3.0, a melhor estratégia é a seguinte:</p>
<ol class="arabic simple" start="0">
<li><p class="translated">(Pré-requisito:) Comece com uma excelente cobertura de teste.</p></li>
<li><p class="translated">Portar para o Python 2.6. Isso não deve dar mais trabalho do que o port médio do Python 2.x para o Python 2.(x+1). Certifique-se de que todos os seus testes passem.</p></li>
<li><p class="translated">(Ainda usando 2.6:) Ative a opção de linha de comando <code class="xref std std-option docutils literal notranslate"><span class="pre">-3</span></code>. Isso habilita avisos sobre recursos que serão removidos (ou alterados) no 3.0. Execute seu conjunto de testes novamente e corrija o código sobre o qual você recebe avisos até que não haja mais avisos e todos os seus testes ainda passem.</p></li>
<li><p class="translated">Execute o tradutor de fonte para fonte <code class="docutils literal notranslate"><span class="pre">2to3</span></code> em sua árvore de código-fonte. Execute o resultado da tradução no Python 3.0. Corrija manualmente quaisquer problemas restantes, corrigindo problemas até que todos os testes passem novamente.</p></li>
</ol>
<p class="translated">Não é recomendado tentar escrever código-fonte que seja executado inalterado no Python 2.6 e 3.0; você teria que usar um estilo de codificação muito distorcido, por exemplo, evitando instruções <code class="docutils literal notranslate"><span class="pre">print</span></code>, metaclasses e muito mais. Se você estiver mantendo uma biblioteca que precisa ter suporte ao Python 2.6 e Python 3.0, a melhor abordagem é modificar a etapa 3 acima editando a versão 2.6 do código-fonte e executando o tradutor <code class="docutils literal notranslate"><span class="pre">2to3</span></code> novamente, em vez de editar a versão 3.0 do código-fonte.</p>
<p class="translated">Para portar extensões C para Python 3.0, consulte <a class="reference internal" href="../howto/cporting.html#cporting-howto"><span class="std std-ref">Portando módulos de extensão para o Python 3</span></a>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabela de Conteúdo</a></h3>
    <ul>
<li><a class="reference internal" href="#">O que há de novo no Python 3.0</a><ul>
<li><a class="reference internal" href="#common-stumbling-blocks">Obstáculos comuns</a><ul>
<li><a class="reference internal" href="#print-is-a-function">print é uma função</a></li>
<li><a class="reference internal" href="#views-and-iterators-instead-of-lists">Visualizações e iteradores em vez de listas</a></li>
<li><a class="reference internal" href="#ordering-comparisons">Comparações de ordenação</a></li>
<li><a class="reference internal" href="#integers">Inteiros</a></li>
<li><a class="reference internal" href="#text-vs-data-instead-of-unicode-vs-8-bit">Texto vs. Dados em vez de Unicode vs. 8 bits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-syntax-changes">Visão geral das alterações da sintaxe</a><ul>
<li><a class="reference internal" href="#new-syntax">Nova sintaxe</a></li>
<li><a class="reference internal" href="#changed-syntax">Sintaxe alterada</a></li>
<li><a class="reference internal" href="#removed-syntax">Sintaxe removida</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes-already-present-in-python-2-6">Mudanças já presentes no Python 2.6</a></li>
<li><a class="reference internal" href="#library-changes">Mudanças na biblioteca</a></li>
<li><a class="reference internal" href="#pep-3101-a-new-approach-to-string-formatting"><strong>PEP 3101</strong>: Uma nova abordagem para formatação de strings</a></li>
<li><a class="reference internal" href="#changes-to-exceptions">Mudanças para exceções</a></li>
<li><a class="reference internal" href="#miscellaneous-other-changes">Outras mudanças diversas</a><ul>
<li><a class="reference internal" href="#operators-and-special-methods">Operadores e métodos especiais</a></li>
<li><a class="reference internal" href="#builtins">Funções embutidas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">Mudanças a construções e API C</a></li>
<li><a class="reference internal" href="#performance">Desempenho</a></li>
<li><a class="reference internal" href="#porting-to-python-3-0">Portando para o Python 3.0</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="3.1.html"
                          title="capítulo anterior">O que há de novo no Python 3.1</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="2.7.html"
                          title="próximo capítulo">O que há de novo no Python 2.7</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/3.0.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="O que há de novo no Python 2.7"
             >próximo</a> |</li>
        <li class="right" >
          <a href="3.1.html" title="O que há de novo no Python 3.1"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >O que há de novo no Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">O que há de novo no Python 3.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>