<!DOCTYPE html>

<html lang="pt-BR" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Glossário" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/glossary.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content=">>>, O prompt padrão do console interativo do Python. Normalmente visto em exemplos de código que podem ser executados interativamente no interpretador.,,..., Pode se referir a:- O prompt padrão do..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.13/pt-br/_images/social_previews/summary_glossary_4ad85248.png" />
<meta property="og:image:alt" content=">>>, O prompt padrão do console interativo do Python. Normalmente visto em exemplos de código que podem ser executados interativamente no interpretador.,,..., Pode se referir a:- O prompt padrão do..." />
<meta name="description" content=">>>, O prompt padrão do console interativo do Python. Normalmente visto em exemplos de código que podem ser executados interativamente no interpretador.,,..., Pode se referir a:- O prompt padrão do..." />
<meta name="twitter:card" content="summary_large_image" />

    <title>Glossário &#8212; Documentação Python 3.13.5</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?v=5ff89526" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=5349f25f" />
    
    <script src="_static/documentation_options.js?v=62a4a58b"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=71a39b36"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Pesquisar dentro de Documentação Python 3.13.5"
          href="_static/opensearch.xml"/>
    <link rel="author" title="Sobre esses documentos" href="about.html" />
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Buscar" href="search.html" />
    <link rel="copyright" title="Direitos autorais" href="copyright.html" />
    <link rel="next" title="Sobre esta documentação" href="about.html" />
    <link rel="prev" title="Descontinuações" href="deprecations/index.html" />
    
      
      <script defer data-domain="docs.python.org" src="https://analytics.python.org/js/script.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/glossary.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="_static/py.svg">
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script>
            <script type="text/javascript" src="_static/search-focus.js"></script>
            <script type="text/javascript" src="_static/themetoggle.js"></script> 
            <script type="text/javascript" src="_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="deprecations/index.html"
                          title="capítulo anterior">Descontinuações</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="about.html"
                          title="próximo capítulo">Sobre esta documentação</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="Sobre esta documentação"
             accesskey="N">próximo</a> |</li>
        <li class="right" >
          <a href="deprecations/index.html" title="Descontinuações"
             accesskey="P">anterior</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.13.5 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossário</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1 class="translated">Glossário<a class="headerlink" href="#glossary" title="Link para este cabeçalho">¶</a></h1>
<dl class="glossary">
<dt class="translated" id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Link para este termo">¶</a></dt><dd><p class="translated">O prompt padrão do console <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interativo</span></a> do Python. Normalmente visto em exemplos de código que podem ser executados interativamente no interpretador.</p>
</dd>
<dt class="translated" id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Link para este termo">¶</a></dt><dd><p class="translated">Pode se referir a:</p>
<ul class="simple">
<li><p class="translated">O prompt padrão do console <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interativo</span></a> do Python ao inserir o código para um bloco de código recuado, quando dentro de um par de delimitadores correspondentes esquerdo e direito (parênteses, colchetes, chaves ou aspas triplas) ou após especificar um decorador.</p></li>
<li><p class="translated">A constante embutida <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>.</p></li>
</ul>
</dd>
<dt class="translated" id="term-abstract-base-class">classe base abstrata<a class="headerlink" href="#term-abstract-base-class" title="Link para este termo">¶</a></dt><dd><p class="translated">Classes bases abstratas (ABCs, do inglês <em>abstract base class</em>) complementam a <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">tipagem pato</span></a>, fornecendo uma maneira de definir interfaces quando outras técnicas, como <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>, seriam desajeitadas ou sutilmente erradas (por exemplo, com <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">métodos mágicos</span></a>). ABCs introduzem subclasses virtuais, classes que não herdam de uma classe mas ainda são reconhecidas por <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> e <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>; veja a documentação do módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>. Python vem com muitas ABCs embutidas para estruturas de dados (no módulo <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>), números (no módulo <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a>), fluxos (no módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>), localizadores e carregadores de importação (no módulo <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a>). Você pode criar suas próprias ABCs com o módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>.</p>
</dd>
<dt class="translated" id="term-annotation">anotação<a class="headerlink" href="#term-annotation" title="Link para este termo">¶</a></dt><dd><p class="translated">Um rótulo associado a uma variável, um atributo de classe ou um parâmetro de função ou valor de retorno, usado por convenção como <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dica de tipo</span></a>.</p>
<p class="translated">Anotações de variáveis locais não podem ser acessadas em tempo de execução, mas anotações de variáveis globais, atributos de classe e funções são armazenadas no atributo especial <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> de módulos, classes e funções, respectivamente.</p>
<p class="translated">Veja <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">anotação de variável</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">anotação de função</span></a>, <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> e <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, que descrevem esta funcionalidade. Veja também <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Boas práticas para anotações</span></a> para as melhores práticas sobre como trabalhar com anotações.</p>
</dd>
<dt class="translated" id="term-argument">argumento<a class="headerlink" href="#term-argument" title="Link para este termo">¶</a></dt><dd><p class="translated">Um valor passado para uma <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a> (ou <a class="reference internal" href="#term-method"><span class="xref std std-term">método</span></a>) ao chamar a função. Existem dois tipos de argumento:</p>
<ul>
<li><p class="translated"><em class="dfn">argumento nomeado</em>: um argumento precedido por um identificador (por exemplo, <code class="docutils literal notranslate"><span class="pre">nome=</span></code>) na chamada de uma função ou passada como um valor em um dicionário precedido por <code class="docutils literal notranslate"><span class="pre">**</span></code>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">3</span></code> e <code class="docutils literal notranslate"><span class="pre">5</span></code> são ambos argumentos nomeados nas chamadas da função <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> a seguir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p class="translated"><em class="dfn">argumento posicional</em>: um argumento que não é um argumento nomeado. Argumentos posicionais podem aparecer no início da lista de argumentos e/ou podem ser passados como elementos de um <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterável</span></a> precedido por <code class="docutils literal notranslate"><span class="pre">*</span></code>. Por exemplo, <code class="docutils literal notranslate"><span class="pre">3</span></code> e <code class="docutils literal notranslate"><span class="pre">5</span></code> são ambos argumentos posicionais nas chamadas a seguir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p class="translated">Argumentos são atribuídos às variáveis locais nomeadas no corpo da função. Veja a seção <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Chamadas</span></a> para as regras de atribuição. Sintaticamente, qualquer expressão pode ser usada para representar um argumento; após a expressão ser valiada, o valor resultante é atribuído à variável local.</p>
<p class="translated">Veja também o termo <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parâmetro</span></a> no glossário, a pergunta no FAQ sobre <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">a diferença entre argumentos e parâmetros</span></a> e <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-context-manager">gerenciador de contexto assíncrono<a class="headerlink" href="#term-asynchronous-context-manager" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que controla o ambiente envolto numa instrução <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> por meio da definição dos métodos <a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> e <a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a>. Introduzido pela <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-generator">gerador assíncrono<a class="headerlink" href="#term-asynchronous-generator" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função que retorna um <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">iterador gerador assíncrono</span></a>. É parecida com uma função de corrotina definida com <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> exceto pelo fato de conter instruções <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para produzir uma série de valores que podem ser usados em um laço <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p class="translated">Normalmente se refere a uma função geradora assíncrona, mas pode se referir a um <em>iterador gerador assíncrono</em> em alguns contextos. Em casos em que o significado não esteja claro, usar o termo completo evita a ambiguidade.</p>
<p class="translated">Uma função geradora assíncrona pode conter expressões <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> e também as instruções <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> e <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-generator-iterator">iterador gerador assíncrono<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto criado por uma função <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">geradora assíncrona</span></a>.</p>
<p class="translated">Este é um <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a> que, quando chamado usando o método <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, retorna um objeto aguardável que executará o corpo da função geradora assíncrona até a próxima expressão <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>.</p>
<p class="translated">Cada <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspende temporariamente o processamento, lembrando o estado de execução (incluindo variáveis locais e instruções <code class="docutils literal notranslate"><span class="pre">try</span></code> pendentes). Quando o <em>iterador gerador assíncrono</em> é efetivamente retomado com outro aguardável retornado por <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, ele inicia de onde parou. Veja <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> e <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-iterable">iterável assíncrono<a class="headerlink" href="#term-asynchronous-iterable" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que pode ser usado em uma instrução <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Deve retornar um <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">iterador assíncrono</span></a> do seu método <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a>. Introduzido por <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-iterator">iterador assíncrono<a class="headerlink" href="#term-asynchronous-iterator" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que implementa os métodos <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> e <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>. <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> deve retornar um objeto <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">aguardável</span></a>. <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> resolve os aguardáveis retornados por um método <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> do iterador assíncrono até que ele levante uma exceção <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Introduzido pela <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-attribute">atributo<a class="headerlink" href="#term-attribute" title="Link para este termo">¶</a></dt><dd><p class="translated">Um valor associado a um objeto que é geralmente referenciado pelo nome separado por um ponto. Por exemplo, se um objeto <em>o</em> tem um atributo <em>a</em> esse seria referenciado como <em>o.a</em>.</p>
<p class="translated">É possível dar a um objeto um atributo cujo nome não seja um identificador conforme definido por <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identificadores e palavras-chave</span></a>, por exemplo usando <a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>, se o objeto permitir. Tal atributo não será acessível usando uma expressão pontilhada e, em vez disso, precisaria ser recuperado com <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.</p>
</dd>
<dt class="translated" id="term-awaitable">aguardável<a class="headerlink" href="#term-awaitable" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que pode ser usado em uma expressão <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. Pode ser uma <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">corrotina</span></a> ou um objeto com um método <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Veja também a <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Link para este termo">¶</a></dt><dd><p class="translated">Abreviação da expressão da língua inglesa “Benevolent Dictator for Life” (em português, “Ditador Benevolente Vitalício”), referindo-se a <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>, criador do Python.</p>
</dd>
<dt class="translated" id="term-binary-file">arquivo binário<a class="headerlink" href="#term-binary-file" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a> capaz de ler e gravar em <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objetos bytes ou similares</span></a>. Exemplos de arquivos binários são arquivos abertos no modo binário (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code></a>, e instâncias de <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> e <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-text-file"><span class="xref std std-term">arquivo texto</span></a> para um objeto arquivo capaz de ler e gravar em objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd>
<dt class="translated" id="term-borrowed-reference">referência emprestada<a class="headerlink" href="#term-borrowed-reference" title="Link para este termo">¶</a></dt><dd><p class="translated">Na API C do Python, uma referência emprestada é uma referência a um objeto que não é dona da referência. Ela se torna um ponteiro solto se o objeto for destruído. Por exemplo, uma coleta de lixo pode remover a última <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referência forte</span></a> para o objeto e assim destruí-lo.</p>
<p class="translated">Chamar <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> na <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">referência emprestada</span></a> é recomendado para convertê-lo, internamente, em uma <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referência forte</span></a>, exceto quando o objeto não pode ser destruído antes do último uso da referência emprestada. A função <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> pode ser usada para criar uma nova <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referência forte</span></a>.</p>
</dd>
<dt class="translated" id="term-bytes-like-object">objeto bytes ou similar<a class="headerlink" href="#term-bytes-like-object" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto com suporte ao <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">Protocolo de Buffer</span></a> e que pode exportar um buffer C <a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contíguo</span></a>. Isso inclui todos os objetos <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> e <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>, além de muitos objetos <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> comuns. Objetos bytes ou similares podem ser usados para várias operações que funcionam com dados binários; isso inclui compactação, salvamento em um arquivo binário e envio por um soquete.</p>
<p class="translated">Algumas operações precisam que os dados binários sejam mutáveis. A documentação geralmente se refere a eles como “objetos bytes ou similares para leitura e escrita”. Exemplos de objetos de buffer mutável incluem <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> e um <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de um <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Outras operações exigem que os dados binários sejam armazenados em objetos imutáveis (“objetos bytes ou similares para somente leitura”); exemplos disso incluem <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> e a <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de um objeto <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt class="translated" id="term-bytecode">bytecode<a class="headerlink" href="#term-bytecode" title="Link para este termo">¶</a></dt><dd><p class="translated">O código-fonte Python é compilado para bytecode, a representação interna de um programa em Python no interpretador CPython. O bytecode também é mantido em cache em arquivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> e <code class="docutils literal notranslate"><span class="pre">.pyo</span></code>, de forma que executar um mesmo arquivo é mais rápido na segunda vez (a recompilação dos fontes para bytecode não é necessária). Esta “linguagem intermediária” é adequada para execução em uma <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">máquina virtual</span></a>, que executa o código de máquina correspondente para cada bytecode. Tenha em mente que não se espera que bytecodes sejam executados entre máquinas virtuais Python diferentes, nem que se mantenham estáveis entre versões de Python.</p>
<p class="translated">Uma lista de instruções bytecode pode ser encontrada na documentação para <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">o módulo dis</span></a>.</p>
</dd>
<dt class="translated" id="term-callable">chamável<a class="headerlink" href="#term-callable" title="Link para este termo">¶</a></dt><dd><p class="translated">Um chamável é um objeto que pode ser chamado, possivelmente com um conjunto de argumentos (veja <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a>), com a seguinte sintaxe:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">chamavel</span><span class="p">(</span><span class="n">argumento1</span><span class="p">,</span> <span class="n">argumento2</span><span class="p">,</span> <span class="n">argumentoN</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Uma <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a>, e por extensão um <a class="reference internal" href="#term-method"><span class="xref std std-term">método</span></a>, é um chamável. Uma instância de uma classe que implementa o método <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> também é um chamável.</p>
</dd>
<dt class="translated" id="term-callback">função de retorno<a class="headerlink" href="#term-callback" title="Link para este termo">¶</a></dt><dd><p class="translated">Também conhecida como callback, é uma função sub-rotina que é passada como um argumento a ser executado em algum ponto no futuro.</p>
</dd>
<dt class="translated" id="term-class">classe<a class="headerlink" href="#term-class" title="Link para este termo">¶</a></dt><dd><p class="translated">Um modelo para criação de objetos definidos pelo usuário. Definições de classe normalmente contém definições de métodos que operam sobre instâncias da classe.</p>
</dd>
<dt class="translated" id="term-class-variable">variável de classe<a class="headerlink" href="#term-class-variable" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma variável definida em uma classe e destinada a ser modificada apenas no nível da classe (ou seja, não em uma instância da classe).</p>
</dd>
<dt class="translated" id="term-closure-variable">variável de clausura<a class="headerlink" href="#term-closure-variable" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma <a class="reference internal" href="#term-free-variable"><span class="xref std std-term">variável livre</span></a> referenciada de um <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">escopo aninhado</span></a> que é definida em um escopo externo em vez de ser resolvida em tempo de execução a partir dos espaços de nomes embutido ou globais. Pode ser explicitamente definida com a palavra reservada <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> para permitir acesso de gravação, ou implicitamente definida se a variável estiver sendo somente lida.</p>
<p class="translated">Por exemplo, na função <code class="docutils literal notranslate"><span class="pre">interna</span></code> no código a seguir, tanto <code class="docutils literal notranslate"><span class="pre">x</span></code> quanto <code class="docutils literal notranslate"><span class="pre">print</span></code> são <a class="reference internal" href="#term-free-variable"><span class="xref std std-term">variáveis livres</span></a>, mas somente <code class="docutils literal notranslate"><span class="pre">x</span></code> é uma <em>variável de clausura</em>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">externa</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interna</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interna</span>
</pre></div>
</div>
<p class="translated">Devido ao atributo <a class="reference internal" href="reference/datamodel.html#codeobject.co_freevars" title="codeobject.co_freevars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">codeobject.co_freevars</span></code></a> (que, apesar do nome, inclui apenas os nomes das variáveis de clausura em vez de listar todas as variáveis livres referenciadas), o termo mais geral <a class="reference internal" href="#term-free-variable"><span class="xref std std-term">variável livre</span></a> às vezes é usado mesmo quando o significado pretendido é se referir especificamente às variáveis de clausura.</p>
</dd>
<dt class="translated" id="term-complex-number">número complexo<a class="headerlink" href="#term-complex-number" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma extensão ao familiar sistema de números reais em que todos os números são expressos como uma soma de uma parte real e uma parte imaginária. Números imaginários são múltiplos reais da unidade imaginária (a raiz quadrada de <code class="docutils literal notranslate"><span class="pre">-1</span></code>), normalmente escrita como <code class="docutils literal notranslate"><span class="pre">i</span></code> em matemática ou <code class="docutils literal notranslate"><span class="pre">j</span></code> em engenharia. O Python tem suporte nativo para números complexos, que são escritos com esta última notação; a parte imaginária escrita com um sufixo <code class="docutils literal notranslate"><span class="pre">j</span></code>, p.ex., <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>. Para ter acesso aos equivalentes para números complexos do módulo <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>, utilize <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>. O uso de números complexos é uma funcionalidade matemática bastante avançada. Se você não sabe se irá precisar deles, é quase certo que você pode ignorá-los sem problemas.</p>
</dd>
<dt class="translated" id="term-context">contexto<a class="headerlink" href="#term-context" title="Link para este termo">¶</a></dt><dd><p class="translated">Este termo tem diferentes significados dependendo de onde e como ele é usado. Alguns significados comuns:</p>
<ul class="simple">
<li><p class="translated">O estado ou ambiente temporário estabelecido por um <a class="reference internal" href="#term-context-manager"><span class="xref std std-term">gerenciador de contexto</span></a> por meio de uma instrução <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p></li>
<li><p class="translated">A coleção de ligações de chave-valor associadas a um objeto <a class="reference internal" href="library/contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> específico e acessadas por meio de objetos <a class="reference internal" href="library/contextvars.html#contextvars.ContextVar" title="contextvars.ContextVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContextVar</span></code></a>. Veja também <a class="reference internal" href="#term-context-variable"><span class="xref std std-term">variável de contexto</span></a>.</p></li>
<li><p class="translated">Um objeto <a class="reference internal" href="library/contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a>. Veja também <a class="reference internal" href="#term-current-context"><span class="xref std std-term">contexto atual</span></a>.</p></li>
</ul>
</dd>
<dt class="translated" id="term-context-management-protocol">protocolo de gerenciamento de contexto<a class="headerlink" href="#term-context-management-protocol" title="Link para este termo">¶</a></dt><dd><p class="translated">Os métodos <a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> e <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> chamados pela instrução <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. Veja <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt class="translated" id="term-context-manager">gerenciador de contexto<a class="headerlink" href="#term-context-manager" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que implementa o <a class="reference internal" href="#term-context-management-protocol"><span class="xref std std-term">protocolo de gerenciamento de contexto</span></a> e controla o ambiente envolto em uma instrução <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. Veja <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt class="translated" id="term-context-variable">variável de contexto<a class="headerlink" href="#term-context-variable" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma variável cujo valor depende de qual contexto é o <a class="reference internal" href="#term-current-context"><span class="xref std std-term">contexto atual</span></a>. Os valores são acessados por meio de objetos <a class="reference internal" href="library/contextvars.html#contextvars.ContextVar" title="contextvars.ContextVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.ContextVar</span></code></a>. Variáveis de contexto são usadas principalmente para isolar o estado entre tarefas assíncronas simultâneas.</p>
</dd>
<dt class="translated" id="term-contiguous">contíguo<a class="headerlink" href="#term-contiguous" title="Link para este termo">¶</a></dt><dd><p class="translated" id="index-11">Um buffer é considerado contíguo exatamente se for <em>contíguo C</em> ou <em>contíguo Fortran</em>. Os buffers de dimensão zero são contíguos C e Fortran. Em vetores unidimensionais, os itens devem ser dispostos na memória próximos um do outro, em ordem crescente de índices, começando do zero. Em vetores multidimensionais contíguos C, o último índice varia mais rapidamente ao visitar itens em ordem de endereço de memória. No entanto, nos vetores contíguos do Fortran, o primeiro índice varia mais rapidamente.</p>
</dd>
<dt class="translated" id="term-coroutine">corrotina<a class="headerlink" href="#term-coroutine" title="Link para este termo">¶</a></dt><dd><p class="translated">Corrotinas são uma forma mais generalizada de sub-rotinas. Sub-rotinas tem a entrada iniciada em um ponto, e a saída em outro ponto. Corrotinas podem entrar, sair, e continuar em muitos pontos diferentes. Elas podem ser implementadas com a instrução <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Veja também <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-coroutine-function">função de corrotina<a class="headerlink" href="#term-coroutine-function" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função que retorna um objeto do tipo <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">corrotina</span></a>. Uma função de corrotina pode ser definida com a instrução <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, e pode conter as palavras chaves <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, e <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>. Isso foi introduzido pela <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Link para este termo">¶</a></dt><dd><p class="translated">A implementação canônica da linguagem de programação Python, como disponibilizada pelo <a class="reference external" href="https://www.python.org">python.org</a>. O termo “CPython” é usado quando necessário distinguir esta implementação de outras como Jython ou IronPython.</p>
</dd>
<dt class="translated" id="term-current-context">contexto atual<a class="headerlink" href="#term-current-context" title="Link para este termo">¶</a></dt><dd><p class="translated">O <a class="reference internal" href="#term-context"><span class="xref std std-term">contexto</span></a> (objeto <a class="reference internal" href="library/contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a>) que é usado atualmente pelos objetos <a class="reference internal" href="library/contextvars.html#contextvars.ContextVar" title="contextvars.ContextVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContextVar</span></code></a> para acessar (obter ou definir) os valores de <a class="reference internal" href="#term-context-variable"><span class="xref std std-term">variáveis de contexto</span></a>. Cada thread tem seu próprio contexto atual. Frameworks para executar tarefas assíncronas (veja <a class="reference internal" href="library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) associam cada tarefa a um contexto que se torna o contexto atual sempre que a tarefa inicia ou retoma a execução.</p>
</dd>
<dt class="translated" id="term-decorator">decorador<a class="headerlink" href="#term-decorator" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função que retorna outra função, geralmente aplicada como uma transformação de função usando a sintaxe <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code>. Exemplos comuns para decoradores são <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> e <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
<p class="translated">A sintaxe do decorador é meramente um açúcar sintático, as duas definições de funções a seguir são semanticamente equivalentes:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">O mesmo conceito existe para as classes, mas não é comumente utilizado. Veja a documentação de <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">definições de função</span></a> e <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">definições de classe</span></a> para obter mais informações sobre decoradores.</p>
</dd>
<dt class="translated" id="term-descriptor">descritor<a class="headerlink" href="#term-descriptor" title="Link para este termo">¶</a></dt><dd><p class="translated">Qualquer objeto que define os métodos <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> ou <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. Quando um atributo de classe é um descritor, seu comportamento de associação especial é acionado no acesso a um atributo. Normalmente, ao se utilizar <em>a.b</em> para se obter, definir ou excluir, um atributo dispara uma busca no objeto chamado <em>b</em> no dicionário de classe de <em>a</em>, mas se <em>b</em> for um descritor, o respectivo método descritor é chamado. Compreender descritores é a chave para um profundo entendimento de Python pois eles são a base de muitas funcionalidades incluindo funções, métodos, propriedades, métodos de classe, métodos estáticos e referências para superclasses.</p>
<p class="translated">Para obter mais informações sobre os métodos dos descritores, veja: <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implementando descritores</span></a> ou o <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">Guia de Descritores</span></a>.</p>
</dd>
<dt class="translated" id="term-dictionary">dicionário<a class="headerlink" href="#term-dictionary" title="Link para este termo">¶</a></dt><dd><p class="translated">Um vetor associativo em que chaves arbitrárias são mapeadas para valores. As chaves podem ser quaisquer objetos que possuam os métodos <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> e <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>. Isso é chamado de hash em Perl.</p>
</dd>
<dt class="translated" id="term-dictionary-comprehension">compreensão de dicionário<a class="headerlink" href="#term-dictionary-comprehension" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma maneira compacta de processar todos ou parte dos elementos de um iterável e retornar um dicionário com os resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> gera um dicionário contendo a chave <code class="docutils literal notranslate"><span class="pre">n</span></code> mapeada para o valor <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>. Veja <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Sintaxe de criação de listas, conjuntos e dicionários</span></a>.</p>
</dd>
<dt class="translated" id="term-dictionary-view">visão de dicionário<a class="headerlink" href="#term-dictionary-view" title="Link para este termo">¶</a></dt><dd><p class="translated">Os objetos retornados por <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> e <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> são chamados de visões de dicionário. Eles fornecem uma visão dinâmica das entradas do dicionário, o que significa que quando o dicionário é alterado, a visão reflete essas alterações. Para forçar a visão de dicionário a se tornar uma lista completa use <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>. Veja <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Objetos de visão de dicionário</span></a>.</p>
</dd>
<dt class="translated" id="term-docstring">docstring<a class="headerlink" href="#term-docstring" title="Link para este termo">¶</a></dt><dd><p class="translated">Abreviatura de “documentation string” (string de documentação). Uma string literal que aparece como primeira expressão numa classe, função ou módulo. Ainda que sejam ignoradas quando a suíte é executada, é reconhecida pelo compilador que a coloca no atributo <a class="reference internal" href="library/stdtypes.html#definition.__doc__" title="definition.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> da classe, função ou módulo que a encapsula. Como ficam disponíveis por meio de introspecção, docstrings são o lugar canônico para documentação do objeto.</p>
</dd>
<dt class="translated" id="term-duck-typing">tipagem pato<a class="headerlink" href="#term-duck-typing" title="Link para este termo">¶</a></dt><dd><p class="translated">Também conhecida como <em>duck-typing</em>, é um estilo de programação que não verifica o tipo do objeto para determinar se ele possui a interface correta; em vez disso, o método ou atributo é simplesmente chamado ou utilizado (“Se se parece com um pato e grasna como um pato, então deve ser um pato.”) Enfatizando interfaces ao invés de tipos específicos, o código bem desenvolvido aprimora sua flexibilidade por permitir substituição polimórfica. Tipagem pato evita necessidade de testes que usem <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> ou <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>. (Note, porém, que a tipagem pato pode ser complementada com o uso de <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classes base abstratas</span></a>.) Ao invés disso, são normalmente empregados testes <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> ou programação <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a>.</p>
</dd>
<dt class="translated" id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Link para este termo">¶</a></dt><dd><p class="translated">Iniciais da expressão em inglês “easier to ask for forgiveness than permission” que significa “é mais fácil pedir perdão que permissão”. Este estilo de codificação comum no Python presume a existência de chaves ou atributos válidos e captura exceções caso essa premissa se prove falsa. Este estilo limpo e rápido se caracteriza pela presença de várias instruções <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> e <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>. A técnica diverge do estilo <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a>, comum em outras linguagens como C, por exemplo.</p>
</dd>
<dt class="translated" id="term-expression">expressão<a class="headerlink" href="#term-expression" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma parte da sintaxe que pode ser avaliada para algum valor. Em outras palavras, uma expressão é a acumulação de elementos de expressão como literais, nomes, atributos de acesso, operadores ou chamadas de funções, todos os quais retornam um valor. Em contraste com muitas outras linguagens, nem todas as construções de linguagem são expressões. Também existem <a class="reference internal" href="#term-statement"><span class="xref std std-term">instruções</span></a>, as quais não podem ser usadas como expressões, como, por exemplo, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>. Atribuições também são instruções, não expressões.</p>
</dd>
<dt class="translated" id="term-extension-module">módulo de extensão<a class="headerlink" href="#term-extension-module" title="Link para este termo">¶</a></dt><dd><p class="translated">Um módulo escrito em C ou C++, usando a API C do Python para interagir tanto com código de usuário quanto do núcleo.</p>
</dd>
<dt class="translated" id="term-f-string">f-string<a class="headerlink" href="#term-f-string" title="Link para este termo">¶</a></dt><dd><p class="translated">Literais string prefixadas com <code class="docutils literal notranslate"><span class="pre">'f'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'F'</span></code> são conhecidas como “f-strings” que é uma abreviação de <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a>. Veja também <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>.</p>
</dd>
<dt class="translated" id="term-file-object">objeto arquivo<a class="headerlink" href="#term-file-object" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que expõe uma API orientada a arquivos (com métodos tais como <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> ou <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) para um recurso subjacente. Dependendo da maneira como foi criado, um objeto arquivo pode mediar o acesso a um arquivo real no disco ou outro tipo de dispositivo de armazenamento ou de comunicação (por exemplo a entrada/saída padrão, buffers em memória, soquetes, pipes, etc.). Objetos arquivo também são chamados de <em class="dfn">objetos arquivo ou similares</em> ou <em class="dfn">fluxos</em>.</p>
<p class="translated">Atualmente há três categorias de objetos arquivo: <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">arquivos binários</span></a> brutos, <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">arquivos binários</span></a> em buffer e <a class="reference internal" href="#term-text-file"><span class="xref std std-term">arquivos textos</span></a>. Suas interfaces estão definidas no módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>. A forma canônica para criar um objeto arquivo é usando a função <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd>
<dt class="translated" id="term-file-like-object">objeto arquivo ou similar<a class="headerlink" href="#term-file-like-object" title="Link para este termo">¶</a></dt><dd><p class="translated">Um sinônimo do termo <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a>.</p>
</dd>
<dt class="translated" id="term-filesystem-encoding-and-error-handler">tratador de erros e codificação do sistema de arquivos<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Link para este termo">¶</a></dt><dd><p class="translated">Tratador de erros e codificação usado pelo Python para decodificar bytes do sistema operacional e codificar Unicode para o sistema operacional.</p>
<p class="translated">A codificação do sistema de arquivos deve garantir a decodificação bem-sucedida de todos os bytes abaixo de 128. Se a codificação do sistema de arquivos falhar em fornecer essa garantia, as funções da API podem levantar <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
<p class="translated">As funções <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> e <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> podem ser usadas para obter o tratador de erros e codificação do sistema de arquivos.</p>
<p class="translated">O <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">tratador de erros e codificação do sistema de arquivos</span></a> são configurados na inicialização do Python pela função <a class="reference internal" href="c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a>: veja os membros <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> e <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> do <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">codificação da localidade</span></a>.</p>
</dd>
<dt class="translated" id="term-finder">localizador<a class="headerlink" href="#term-finder" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que tenta encontrar o <a class="reference internal" href="#term-loader"><span class="xref std std-term">carregador</span></a> para um módulo que está sendo importado.</p>
<p class="translated">Existem dois tipos de localizador: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">localizadores de metacaminho</span></a> para uso com <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, e <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">localizadores de entrada de caminho</span></a> para uso com <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p class="translated">Veja <a class="reference internal" href="reference/import.html#finders-and-loaders"><span class="std std-ref">Localizadores e carregadores</span></a> e <a class="reference internal" href="library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> para muito mais detalhes.</p>
</dd>
<dt class="translated" id="term-floor-division">divisão pelo piso<a class="headerlink" href="#term-floor-division" title="Link para este termo">¶</a></dt><dd><p class="translated">Divisão matemática que arredonda para baixo para o inteiro mais próximo. O operador de divisão pelo piso é <code class="docutils literal notranslate"><span class="pre">//</span></code>. Por exemplo, a expressão <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> retorna o valor <code class="docutils literal notranslate"><span class="pre">2</span></code> ao invés de <code class="docutils literal notranslate"><span class="pre">2.75</span></code>, que seria retornado pela divisão de ponto flutuante. Note que <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> é <code class="docutils literal notranslate"><span class="pre">-3</span></code> porque é <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> arredondado <em>para baixo</em>. Consulte a <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>.</p>
</dd>
<dt class="translated" id="term-free-threading">threads livres<a class="headerlink" href="#term-free-threading" title="Link para este termo">¶</a></dt><dd><p class="translated">Um modelo de threads onde múltiplas threads podem simultaneamente executar bytecode Python no mesmo interpretador.  Isso está em contraste com a <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">trava global do interpretador</span></a> que permite apenas uma thread por vez executar bytecode Python. Veja <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0703/"><strong>PEP 703</strong></a>.</p>
</dd>
<dt class="translated" id="term-free-variable">variável livre<a class="headerlink" href="#term-free-variable" title="Link para este termo">¶</a></dt><dd><p class="translated">Formalmente, conforme definido no <a class="reference internal" href="reference/executionmodel.html#bind-names"><span class="std std-ref">modelo de execução de linguagem</span></a>, uma variável livre é qualquer variável usada em um espaço de nomes que não seja uma variável local naquele espaço de nomes. Veja <a class="reference internal" href="#term-closure-variable"><span class="xref std std-term">variável de clausura</span></a> para um exemplo. Pragmaticamente, devido ao nome do atributo <a class="reference internal" href="reference/datamodel.html#codeobject.co_freevars" title="codeobject.co_freevars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">codeobject.co_freevars</span></code></a>, o termo também é usado algumas vezes como sinônimo de <a class="reference internal" href="#term-closure-variable"><span class="xref std std-term">variável de clausura</span></a>.</p>
</dd>
<dt class="translated" id="term-function">função<a class="headerlink" href="#term-function" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma série de instruções que retorna algum valor para um chamador. Também pode ser passado zero ou mais <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumentos</span></a> que podem ser usados na execução do corpo. Veja também <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parâmetro</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">método</span></a> e a seção <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>.</p>
</dd>
<dt class="translated" id="term-function-annotation">anotação de função<a class="headerlink" href="#term-function-annotation" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotação</span></a> de um parâmetro de função ou valor de retorno.</p>
<p class="translated">Anotações de função são comumente usados por <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a>: por exemplo, essa função espera receber dois argumentos <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> e também é esperado que devolva um valor <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">soma_dois_numeros</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p class="translated">A sintaxe de anotação de função é explicada na seção <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a>.</p>
<p class="translated">Veja <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">anotação de variável</span></a> e <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que descrevem esta funcionalidade. Veja também <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Boas práticas para anotações</span></a> para as melhores práticas sobre como trabalhar com anotações.</p>
</dd>
<dt class="translated" id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Link para este termo">¶</a></dt><dd><p class="translated">A <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">instrução future</span></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code>, direciona o compilador a compilar o módulo atual usando sintaxe ou semântica que será padrão em uma versão futura de Python. O módulo <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> documenta os possíveis valores de <em>feature</em>.  Importando esse módulo e avaliando suas variáveis, você pode ver quando um novo recurso foi inicialmente adicionado à linguagem e quando será (ou se já é) o padrão:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-garbage-collection">coleta de lixo<a class="headerlink" href="#term-garbage-collection" title="Link para este termo">¶</a></dt><dd><p class="translated">Também conhecido como <em>garbage collection</em>, é o processo de liberar a memória quando ela não é mais utilizada. Python executa a liberação da memória através da contagem de referências e um coletor de lixo cíclico que é capaz de detectar e interromper referências cíclicas. O coletor de lixo pode ser controlado usando o módulo <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</dd>
<dt class="translated" id="term-generator">gerador<a class="headerlink" href="#term-generator" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função que retorna um <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">iterador gerador</span></a>. É parecida com uma função normal, exceto pelo fato de conter expressões <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para produzir uma série de valores que podem ser usados em um laço “for” ou que podem ser obtidos um de cada vez com a função <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<p class="translated">Normalmente refere-se a uma função geradora, mas pode referir-se a um <em>iterador gerador</em> em alguns contextos. Em alguns casos onde o significado desejado não está claro, usar o termo completo evita ambiguidade.</p>
</dd>
<dt class="translated" id="term-generator-iterator">iterador gerador<a class="headerlink" href="#term-generator-iterator" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto criado por uma função <a class="reference internal" href="#term-generator"><span class="xref std std-term">geradora</span></a>.</p>
<p class="translated">Cada <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspende temporariamente o processamento, memorizando o estado da execução (incluindo variáveis locais e instruções try pendentes). Quando o <em>iterador gerador</em> retorna, ele se recupera do último ponto onde estava (em contrapartida as funções que iniciam uma nova execução a cada vez que são invocadas).</p>
</dd>
<dt class="translated" id="term-generator-expression">expressão geradora<a class="headerlink" href="#term-generator-expression" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma <a class="reference internal" href="#term-expression"><span class="xref std std-term">expressão</span></a> que retorna um <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterador</span></a>. Parece uma expressão normal, seguido de uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> definindo uma variável de laço, um intervalo, e uma cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> opcional. A expressão combinada gera valores para uma função encapsuladora:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># soma dos quadrados 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-generic-function">função genérica<a class="headerlink" href="#term-generic-function" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função composta por várias funções implementando a mesma operação para diferentes tipos. Qual implementação deverá ser usada durante a execução é determinada pelo algoritmo de despacho.</p>
<p class="translated">Veja também a entrada <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">despacho único</span></a> no glossário, o decorador <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a>, e a <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>.</p>
</dd>
<dt class="translated" id="term-generic-type">tipo genérico<a class="headerlink" href="#term-generic-type" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-type"><span class="xref std std-term">tipo</span></a> que pode ser parametrizado; tipicamente uma <a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">classe contêiner</span></a> tal como <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Usado para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a> e <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotações</span></a>.</p>
<p class="translated">Para mais detalhes, veja <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">tipo apelido genérico</span></a>, <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, <span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>, e o módulo <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>.</p>
</dd>
<dt class="translated" id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Link para este termo">¶</a></dt><dd><p class="translated">Veja <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">trava global do interpretador</span></a>.</p>
</dd>
<dt class="translated" id="term-global-interpreter-lock">trava global do interpretador<a class="headerlink" href="#term-global-interpreter-lock" title="Link para este termo">¶</a></dt><dd><p class="translated">O mecanismo utilizado pelo interpretador <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> para garantir que apenas uma thread execute o <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> Python por vez. Isto simplifica a implementação do CPython ao fazer com que o modelo de objetos (incluindo tipos embutidos críticos como o <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) ganhem segurança implícita contra acesso concorrente. Travar todo o interpretador facilita que o interpretador em si seja multitarefa, às custas de muito do paralelismo já provido por máquinas multiprocessador.</p>
<p class="translated">No entanto, alguns módulos de extensão, tanto da biblioteca padrão quanto de terceiros, são desenvolvidos de forma a liberar a GIL ao realizar tarefas computacionalmente muito intensas, como compactação ou cálculos de hash. Além disso, a GIL é sempre liberado nas operações de E/S.</p>
<p class="translated">A partir de Python 3.13, o GIL pode ser desabilitado usando a configuração de construção <a class="reference internal" href="using/configure.html#cmdoption-disable-gil"><code class="xref std std-option docutils literal notranslate"><span class="pre">--disable-gil</span></code></a>. Depois de construir Python com essa opção, o código deve ser executado com a opção <a class="reference internal" href="using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span> <span class="pre">gil=0</span></code></a> ou a variável de ambiente <span class="target" id="index-101"></span><a class="reference internal" href="using/cmdline.html#envvar-PYTHON_GIL"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON_GIL=0</span></code></a> deve estar definida. Esse recurso provê um desempenho melhor para aplicações com múltiplas threads e torna mais fácil o uso eficiente de CPUs com múltiplos núcleos. Para mais detalhes, veja <span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-0703/"><strong>PEP 703</strong></a>.</p>
</dd>
<dt class="translated" id="term-hash-based-pyc">pyc baseado em hash<a class="headerlink" href="#term-hash-based-pyc" title="Link para este termo">¶</a></dt><dd><p class="translated">Um arquivo de cache em bytecode que usa hash ao invés do tempo, no qual o arquivo de código-fonte foi modificado pela última vez, para determinar a sua validade. Veja <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Invalidação de bytecode em cache</span></a>.</p>
</dd>
<dt class="translated" id="term-hashable">hasheável<a class="headerlink" href="#term-hashable" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto é <em>hasheável</em> se tem um valor de hash que nunca muda durante seu ciclo de vida (precisa ter um método <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>) e pode ser comparado com outros objetos (precisa ter um método <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>). Objetos hasheáveis que são comparados como iguais devem ter o mesmo valor de hash.</p>
<p class="translated">A hasheabilidade faz com que um objeto possa ser usado como uma chave de dicionário e como um membro de conjunto, pois estas estruturas de dados utilizam os valores de hash internamente.</p>
<p class="translated">A maioria dos objetos embutidos imutáveis do Python são hasheáveis; containers mutáveis (tais como listas ou dicionários) não são; containers imutáveis (tais como tuplas e frozensets) são hasheáveis apenas se os seus elementos são hasheáveis. Objetos que são instâncias de classes definidas pelo usuário são hasheáveis por padrão. Todos eles comparam de forma desigual (exceto entre si mesmos), e o seu valor hash é derivado a partir do seu <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.</p>
</dd>
<dt class="translated" id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Link para este termo">¶</a></dt><dd><p class="translated">Um ambiente de desenvolvimento e aprendizado integrado para Python. <a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE — editor e console Python</span></a> é um editor básico e um ambiente interpretador que vem junto com a distribuição padrão do Python.</p>
</dd>
<dt class="translated" id="term-immortal">imortal<a class="headerlink" href="#term-immortal" title="Link para este termo">¶</a></dt><dd><p class="translated"><em>Objetos imortais</em> são um detalhe da implementação do CPython introduzida na <span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-0683/"><strong>PEP 683</strong></a>.</p>
<p class="translated">Se um objeto é imortal, sua <a class="reference internal" href="#term-reference-count"><span class="xref std std-term">contagem de referências</span></a> nunca é modificada e, portanto, nunca é desalocado enquanto o interpretador está em execução. Por exemplo, <a class="reference internal" href="library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> e <a class="reference internal" href="library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> são imortais no CPython.</p>
</dd>
<dt class="translated" id="term-immutable">imutável<a class="headerlink" href="#term-immutable" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que possui um valor fixo. Objetos imutáveis incluem números, strings e tuplas. Estes objetos não podem ser alterados. Um novo objeto deve ser criado se um valor diferente tiver de ser armazenado. Objetos imutáveis têm um papel importante em lugares onde um valor constante de hash seja necessário, como por exemplo uma chave em um dicionário.</p>
</dd>
<dt class="translated" id="term-import-path">caminho de importação<a class="headerlink" href="#term-import-path" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma lista de localizações (ou <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entradas de caminho</span></a>) que são buscadas pelo <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> por módulos para importar. Durante a importação, esta lista de localizações usualmente vem a partir de <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, mas para subpacotes ela também pode vir do atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> de pacotes-pai.</p>
</dd>
<dt class="translated" id="term-importing">importação<a class="headerlink" href="#term-importing" title="Link para este termo">¶</a></dt><dd><p class="translated">O processo pelo qual o código Python em um módulo é disponibilizado para o código Python em outro módulo.</p>
</dd>
<dt class="translated" id="term-importer">importador<a class="headerlink" href="#term-importer" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que localiza e carrega um módulo; Tanto um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a> e o objeto <a class="reference internal" href="#term-loader"><span class="xref std std-term">carregador</span></a>.</p>
</dd>
<dt class="translated" id="term-interactive">interativo<a class="headerlink" href="#term-interactive" title="Link para este termo">¶</a></dt><dd><p class="translated">Python tem um interpretador interativo, o que significa que você pode digitar instruções e expressões no prompt do interpretador, executá-los imediatamente e ver seus resultados. Apenas execute <code class="docutils literal notranslate"><span class="pre">python</span></code> sem argumentos (possivelmente selecionando-o a partir do menu de aplicações de seu sistema operacional). O interpretador interativo é uma maneira poderosa de testar novas ideias ou aprender mais sobre módulos e pacotes (lembre-se do comando <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>). Para saber mais sobre modo interativo, veja <a class="reference internal" href="tutorial/appendix.html#tut-interac"><span class="std std-ref">Modo interativo</span></a>.</p>
</dd>
<dt class="translated" id="term-interpreted">interpretado<a class="headerlink" href="#term-interpreted" title="Link para este termo">¶</a></dt><dd><p class="translated">Python é uma linguagem interpretada, em oposição àquelas que são compiladas, embora esta distinção possa ser nebulosa devido à presença do compilador de bytecode. Isto significa que os arquivos-fontes podem ser executados diretamente sem necessidade explícita de se criar um arquivo executável. Linguagens interpretadas normalmente têm um ciclo de desenvolvimento/depuração mais curto que as linguagens compiladas, apesar de seus programas geralmente serem executados mais lentamente. Veja também <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interativo</span></a>.</p>
</dd>
<dt class="translated" id="term-interpreter-shutdown">desligamento do interpretador<a class="headerlink" href="#term-interpreter-shutdown" title="Link para este termo">¶</a></dt><dd><p class="translated">Quando solicitado para desligar, o interpretador Python entra em uma fase especial, onde ele gradualmente libera todos os recursos alocados, tais como módulos e várias estruturas internas críticas. Ele também faz diversas chamadas para o <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">coletor de lixo</span></a>. Isto pode disparar a execução de código em destrutores definidos pelo usuário ou função de retorno de referência fraca. Código executado durante a fase de desligamento pode encontrar diversas exceções, pois os recursos que ele depende podem não funcionar mais (exemplos comuns são os módulos de bibliotecas, ou os mecanismos de avisos).</p>
<p class="translated">A principal razão para o interpretador desligar, é que o módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> ou o script sendo executado terminou sua execução.</p>
</dd>
<dt class="translated" id="term-iterable">iterável<a class="headerlink" href="#term-iterable" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto capaz de retornar seus membros um de cada vez. Exemplos de iteráveis incluem todos os tipos de sequência (tais como <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> e <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) e alguns tipos de não-sequência, como o <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> e <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objetos arquivo</span></a>, além dos objetos de quaisquer classes que você definir com um método <a class="reference internal" href="reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> ou <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> que implementam a semântica de <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a>.</p>
<p class="translated">Iteráveis podem ser usados em um laço <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> e em vários outros lugares em que uma sequência é necessária (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, …). Quando um objeto iterável é passado como argumento para a função embutida <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, ela retorna um iterador para o objeto. Este iterador é adequado para se varrer todo o conjunto de valores. Ao usar iteráveis, normalmente não é necessário chamar <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> ou lidar com os objetos iteradores em si. A instrução <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> faz isso automaticamente para você, criando uma variável temporária para armazenar o iterador durante a execução do laço. Veja também <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterador</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a>, e <a class="reference internal" href="#term-generator"><span class="xref std std-term">gerador</span></a>.</p>
</dd>
<dt class="translated" id="term-iterator">iterador<a class="headerlink" href="#term-iterator" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que representa um fluxo de dados. Repetidas chamadas ao método <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> de um iterador (ou passando o objeto para a função embutida <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>) vão retornar itens sucessivos do fluxo. Quando não houver mais dados disponíveis uma exceção <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> será levantada. Neste ponto, o objeto iterador se esgotou e quaisquer chamadas subsequentes a seu método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> vão apenas levantar a exceção <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> novamente. Iteradores precisam ter um método <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> que retorne o objeto iterador em si, de forma que todo iterador também é iterável e pode ser usado na maioria dos lugares em que um iterável é requerido. Uma notável exceção é código que tenta realizar passagens em múltiplas iterações. Um objeto contêiner (como uma <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) produz um novo iterador a cada vez que você passá-lo para a função <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> ou utilizá-lo em um laço <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Tentar isso com o mesmo iterador apenas iria retornar o mesmo objeto iterador esgotado já utilizado na iteração anterior, como se fosse um contêiner vazio.</p>
<p class="translated">Mais informações podem ser encontradas em <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Tipos iteradores</span></a>.</p>
<div class="impl-detail compound">
<p class="translated">O CPython não aplica consistentemente o requisito de que um iterador defina <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>. E também observe que o CPython com threads livres não garante a segurança do thread das operações do iterador.</p>
</div>
</dd>
<dt class="translated" id="term-key-function">função chave<a class="headerlink" href="#term-key-function" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função chave ou função colação é um chamável que retorna um valor usado para ordenação ou classificação. Por exemplo, <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> é usada para produzir uma chave de ordenação que leva o locale em consideração para fins de ordenação.</p>
<p class="translated">Uma porção de ferramentas no Python aceitam funções chave para controlar como os elementos são ordenados ou agrupados. Algumas delas incluem <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a> e <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>.</p>
<p class="translated">Há várias maneiras de se criar funções chave. Por exemplo, o método <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> pode servir como uma função chave para ordenações insensíveis à caixa. Alternativamente, uma função chave ad-hoc pode ser construída a partir de uma expressão <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>, como <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>. Além disso, <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a> e <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.methodcaller()</span></code></a> são três construtores de função chave. Consulte o guia de <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">Ordenação</span></a> para ver exemplos de como criar e utilizar funções chave.</p>
</dd>
<dt class="translated" id="term-keyword-argument">argumento nomeado<a class="headerlink" href="#term-keyword-argument" title="Link para este termo">¶</a></dt><dd><p class="translated">Veja <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a>.</p>
</dd>
<dt class="translated" id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função de linha anônima consistindo de uma única <a class="reference internal" href="#term-expression"><span class="xref std std-term">expressão</span></a>, que é avaliada quando a função é chamada. A sintaxe para criar uma função lambda é <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt class="translated" id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Link para este termo">¶</a></dt><dd><p class="translated">Iniciais da expressão em inglês “look before you leap”, que significa algo como “olhe antes de pisar”. Este estilo de codificação testa as pré-condições explicitamente antes de fazer chamadas ou buscas. Este estilo contrasta com a abordagem <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> e é caracterizada pela presença de muitas instruções <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>.</p>
<p class="translated">Em um ambiente multithread, a abordagem LBYL pode arriscar a introdução de uma condição de corrida entre “o olhar” e “o pisar”. Por exemplo, o código <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> pode falhar se outra thread remover <em>key</em> do <em>mapping</em> após o teste, mas antes da olhada. Esse problema pode ser resolvido com travas ou usando a abordagem EAFP.</p>
</dd>
<dt class="translated" id="term-lexical-analyzer">analisador léxico<a class="headerlink" href="#term-lexical-analyzer" title="Link para este termo">¶</a></dt><dd><p class="translated">Nome formal para o <em>tokenizador</em>; veja <a class="reference internal" href="#term-token"><span class="xref std std-term">token</span></a>.</p>
</dd>
<dt class="translated" id="term-list">lista<a class="headerlink" href="#term-list" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a> embutida no Python. Apesar do seu nome, é mais próximo de um vetor em outras linguagens do que uma lista encadeada, como o acesso aos elementos é da ordem <em>O</em>(1).</p>
</dd>
<dt class="translated" id="term-list-comprehension">compreensão de lista<a class="headerlink" href="#term-list-comprehension" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma maneira compacta de processar todos ou parte dos elementos de uma sequência e retornar os resultados em uma lista. <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> gera uma lista de strings contendo números hexadecimais (0x..) no intervalo de 0 a 255. A cláusula <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> é opcional. Se omitida, todos os elementos no <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> serão processados.</p>
</dd>
<dt class="translated" id="term-loader">carregador<a class="headerlink" href="#term-loader" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que carrega um módulo. Ele deve definir os métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code> para implementar a interface <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">Loader</span></code></a>. Um carregador é normalmente retornado por um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a>. Veja também:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="reference/import.html#finders-and-loaders"><span class="std std-ref">Localizadores e carregadores</span></a></p></li>
<li><p class="translated"><a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a></p></li>
<li><p class="translated"><span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a></p></li>
</ul>
</dd>
<dt class="translated" id="term-locale-encoding">codificação da localidade<a class="headerlink" href="#term-locale-encoding" title="Link para este termo">¶</a></dt><dd><p class="translated">No Unix, é a codificação da localidade do LC_CTYPE, que pode ser definida com <a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p class="translated">No Windows, é a página de código ANSI (ex: <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p class="translated">No Android e no VxWorks, o Python usa <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> como a codificação da localidade.</p>
<p class="translated"><a class="reference internal" href="library/locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> pode ser usado para obter a codificação da localidade.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">tratador de erros e codificação do sistema de arquivos</span></a>.</p>
</dd>
<dt class="translated" id="term-magic-method">método mágico<a class="headerlink" href="#term-magic-method" title="Link para este termo">¶</a></dt><dd><p class="translated" id="index-28">Um sinônimo informal para um <a class="reference internal" href="#term-special-method"><span class="xref std std-term">método especial</span></a>.</p>
</dd>
<dt class="translated" id="term-mapping">mapeamento<a class="headerlink" href="#term-mapping" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto contêiner que tem suporte a pesquisas de chave arbitrária e implementa os métodos especificados nas <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> ou <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">classes base abstratas</span></a>. Exemplos incluem <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> e <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt class="translated" id="term-meta-path-finder">localizador de metacaminho<a class="headerlink" href="#term-meta-path-finder" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a> retornado por uma busca de <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Localizadores de metacaminho são relacionados a, mas diferentes de, <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">localizadores de entrada de caminho</span></a>.</p>
<p class="translated">Veja <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> para os métodos que localizadores de metacaminho implementam.</p>
</dd>
<dt class="translated" id="term-metaclass">metaclasse<a class="headerlink" href="#term-metaclass" title="Link para este termo">¶</a></dt><dd><p class="translated">A classe de uma classe. Definições de classe criam um nome de classe, um dicionário de classe e uma lista de classes base. A metaclasse é responsável por receber estes três argumentos e criar a classe. A maioria das linguagens de programação orientadas a objetos provê uma implementação default. O que torna o Python especial é o fato de ser possível criar metaclasses personalizadas. A maioria dos usuários nunca vai precisar deste recurso, mas quando houver necessidade, metaclasses possibilitam soluções poderosas e elegantes. Metaclasses têm sido utilizadas para gerar registros de acesso a atributos, para incluir proteção contra acesso concorrente, rastrear a criação de objetos, implementar singletons, dentre muitas outras tarefas.</p>
<p class="translated">Mais informações podem ser encontradas em <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Metaclasses</span></a>.</p>
</dd>
<dt class="translated" id="term-method">método<a class="headerlink" href="#term-method" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma função que é definida dentro do corpo de uma classe. Se chamada como um atributo de uma instância daquela classe, o método receberá a instância do objeto como seu primeiro <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a> (que comumente é chamado de <code class="docutils literal notranslate"><span class="pre">self</span></code>). Veja <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a> e <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">escopo aninhado</span></a>.</p>
</dd>
<dt class="translated" id="term-method-resolution-order">ordem de resolução de métodos<a class="headerlink" href="#term-method-resolution-order" title="Link para este termo">¶</a></dt><dd><p class="translated">Ordem de resolução de métodos é a ordem em que os membros de uma classe base são buscados durante a pesquisa. Veja <a class="reference internal" href="howto/mro.html#python-2-3-mro"><span class="std std-ref">A Ordem de Resolução de Métodos do Python 2.3</span></a> para detalhes do algoritmo usado pelo interpretador do Python desde a versão 2.3.</p>
</dd>
<dt class="translated" id="term-module">módulo<a class="headerlink" href="#term-module" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto que serve como uma unidade organizacional de código Python. Os módulos têm um espaço de nomes contendo objetos Python arbitrários. Os módulos são carregados pelo Python através do processo de <a class="reference internal" href="#term-importing"><span class="xref std std-term">importação</span></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-package"><span class="xref std std-term">pacote</span></a>.</p>
</dd>
<dt class="translated" id="term-module-spec">spec de módulo<a class="headerlink" href="#term-module-spec" title="Link para este termo">¶</a></dt><dd><p class="translated">Um espaço de nomes que contém as informações relacionadas à importação usadas para carregar um módulo. Uma instância de <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="reference/import.html#module-specs"><span class="std std-ref">Especificações de módulo</span></a>.</p>
</dd>
<dt class="translated" id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Link para este termo">¶</a></dt><dd><p class="translated">Veja <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">ordem de resolução de métodos</span></a>.</p>
</dd>
<dt class="translated" id="term-mutable">mutável<a class="headerlink" href="#term-mutable" title="Link para este termo">¶</a></dt><dd><p class="translated">Objeto mutável é aquele que pode modificar seus valor mas manter seu <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>. Veja também <a class="reference internal" href="#term-immutable"><span class="xref std std-term">imutável</span></a>.</p>
</dd>
<dt class="translated" id="term-named-tuple">tupla nomeada<a class="headerlink" href="#term-named-tuple" title="Link para este termo">¶</a></dt><dd><p class="translated">O termo “tupla nomeada” é aplicado a qualquer tipo ou classe que herda de tupla e cujos elementos indexáveis também são acessíveis usando atributos nomeados. O tipo ou classe pode ter outras funcionalidades também.</p>
<p class="translated">Diversos tipos embutidos são tuplas nomeadas, incluindo os valores retornados por <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> e <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>. Outro exemplo é <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># acesso indexado</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># acesso a campo nomeado</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># tipo de tupla</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">Algumas tuplas nomeadas são tipos embutidos (tal como os exemplos acima). Alternativamente, uma tupla nomeada pode ser criada a partir de uma definição de classe regular, que herde de <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> e que defina campos nomeados. Tal classe pode ser escrita a mão, ou ela pode ser criada herdando <a class="reference internal" href="library/typing.html#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code></a> ou com uma função fábrica <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>. As duas últimas técnicas também adicionam alguns métodos extras, que podem não ser encontrados quando foi escrita manualmente, ou em tuplas nomeadas embutidas.</p>
</dd>
<dt class="translated" id="term-namespace">espaço de nomes<a class="headerlink" href="#term-namespace" title="Link para este termo">¶</a></dt><dd><p class="translated">O lugar em que uma variável é armazenada. Espaços de nomes são implementados como dicionários. Existem os espaços de nomes local, global e nativo, bem como espaços de nomes aninhados em objetos (em métodos). Espaços de nomes suportam modularidade ao prevenir conflitos de nomes. Por exemplo, as funções <code class="xref py py-func docutils literal notranslate"><span class="pre">__builtin__.open()</span></code> e <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> são diferenciadas por seus espaços de nomes. Espaços de nomes também auxiliam na legibilidade e na manutenibilidade ao torar mais claro quais módulos implementam uma função. Escrever <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> ou <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.izip()</span></code>, por exemplo, deixa claro que estas funções são implementadas pelos módulos <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> e <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> respectivamente.</p>
</dd>
<dt class="translated" id="term-namespace-package">pacote de espaço de nomes<a class="headerlink" href="#term-namespace-package" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-package"><span class="xref std std-term">pacote</span></a> que serve apenas como contêiner para subpacotes. Pacotes de espaços de nomes podem não ter representação física, e especificamente não são como um <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">pacote regular</span></a> porque eles não tem um arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p class="translated">Pacotes de espaço de nomes permitem que vários pacotes instaláveis individualmente tenham um pacote pai comum. Caso contrário, é recomendado usar um <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">pacote regular</span></a>.</p>
<p class="translated">Para mais informações, veja <span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> e <a class="reference internal" href="reference/import.html#reference-namespace-package"><span class="std std-ref">Pacotes de espaço de nomes</span></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-module"><span class="xref std std-term">módulo</span></a>.</p>
</dd>
<dt class="translated" id="term-nested-scope">escopo aninhado<a class="headerlink" href="#term-nested-scope" title="Link para este termo">¶</a></dt><dd><p class="translated">A habilidade de referir-se a uma variável em uma definição de fechamento. Por exemplo, uma função definida dentro de outra pode referenciar variáveis da função externa. Perceba que escopos aninhados por padrão funcionam apenas por referência e não por atribuição. Variáveis locais podem ler e escrever no escopo mais interno. De forma similar, variáveis globais podem ler e escrever para o espaço de nomes global. O <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> permite escrita para escopos externos.</p>
</dd>
<dt class="translated" id="term-new-style-class">classe estilo novo<a class="headerlink" href="#term-new-style-class" title="Link para este termo">¶</a></dt><dd><p class="translated">Antigo nome para o tipo de classes agora usado para todos os objetos de classes. Em versões anteriores do Python, apenas classes estilo podiam usar recursos novos e versáteis do Python, tais como <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, descritores, propriedades, <a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, métodos de classe, e métodos estáticos.</p>
</dd>
<dt class="translated" id="term-object">objeto<a class="headerlink" href="#term-object" title="Link para este termo">¶</a></dt><dd><p class="translated">Qualquer dado que tenha estado (atributos ou valores) e comportamento definidos (métodos). Também a última classe base de qualquer <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">classe estilo novo</span></a>.</p>
</dd>
<dt class="translated" id="term-optimized-scope">escopo otimizado<a class="headerlink" href="#term-optimized-scope" title="Link para este termo">¶</a></dt><dd><p class="translated">Um escopo no qual os nomes das variáveis locais de destino são conhecidos de forma confiável pelo compilador quando o código é compilado, permitindo a otimização do acesso de leitura e gravação a esses nomes. Os espaços de nomes locais para funções, geradores, corrotinas, compreensões e expressões geradoras são otimizados desta forma. Nota: a maioria das otimizações de interpretador são aplicadas a todos os escopos, apenas aquelas que dependem de um conjunto conhecido de nomes de variáveis locais e não locais são restritas a escopos otimizados.</p>
</dd>
<dt class="translated" id="term-package">pacote<a class="headerlink" href="#term-package" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-module"><span class="xref std std-term">módulo</span></a> Python é capaz de conter submódulos ou recursivamente, subpacotes. Tecnicamente, um pacote é um módulo Python com um atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">pacote regular</span></a> e <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">pacote de espaço de nomes</span></a>.</p>
</dd>
<dt class="translated" id="term-parameter">parâmetro<a class="headerlink" href="#term-parameter" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma entidade nomeada na definição de uma <a class="reference internal" href="#term-function"><span class="xref std std-term">função</span></a> (ou método) que específica um <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a> (ou em alguns casos, argumentos) que a função pode receber. Existem cinco tipos de parâmetros:</p>
<ul>
<li><p class="translated"><em class="dfn">posicional-ou-nomeado</em>: especifica um argumento que pode ser tanto <a class="reference internal" href="#term-argument"><span class="xref std std-term">posicional</span></a> quanto <a class="reference internal" href="#term-argument"><span class="xref std std-term">nomeado</span></a>. Esse é o tipo padrão de parâmetro, por exemplo <em>foo</em> e <em>bar</em> a seguir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p class="translated"><em class="dfn">somente-posicional</em>: especifica um argumento que pode ser fornecido apenas por posição. Parâmetros somente-posicionais podem ser definidos incluindo o caractere <code class="docutils literal notranslate"><span class="pre">/</span></code> na lista de parâmetros da definição da função após eles, por exemplo <em>somentepos1</em> e <em>somentepos2</em> a seguir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">somentepos1</span><span class="p">,</span> <span class="n">somentepos2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">posicional_ou_nomeado</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p class="translated"><em class="dfn">somente-nomeado</em>: especifica um argumento que pode ser passado para a função somente por nome. Parâmetros somente-nomeados podem ser definidos com um simples parâmetro var-posicional ou um <code class="docutils literal notranslate"><span class="pre">*</span></code> antes deles na lista de parâmetros na definição da função, por exemplo <em>somente_nom1</em> and <em>somente_nom2</em> a seguir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">somente_nom1</span><span class="p">,</span> <span class="n">somente_nom2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="translated"><em class="dfn">var-posicional</em>: especifica que uma sequência arbitrária de argumentos posicionais pode ser fornecida (em adição a qualquer argumento posicional já aceito por outros parâmetros). Tal parâmetro pode ser definido colocando um <code class="docutils literal notranslate"><span class="pre">*</span></code> antes do nome do parâmetro, por exemplo <em>args</em> a seguir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="translated"><em class="dfn">var-nomeado</em>: especifica que, arbitrariamente, muitos argumentos nomeados podem ser fornecidos (em adição a qualquer argumento nomeado já aceito por outros parâmetros). Tal parâmetro pode definido colocando-se <code class="docutils literal notranslate"><span class="pre">**</span></code> antes do nome, por exemplo <em>kwargs</em> no exemplo acima.</p></li>
</ul>
<p class="translated">Parâmetros podem especificar tanto argumentos opcionais quanto obrigatórios, assim como valores padrão para alguns argumentos opcionais.</p>
<p class="translated">Veja também o termo <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a> no glossário, a pergunta do FAQ sobre <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">a diferença entre argumentos e parâmetros</span></a>, a classe <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>, a seção <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definições de função</span></a> e a <span class="target" id="index-105"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt class="translated" id="term-path-entry">entrada de caminho<a class="headerlink" href="#term-path-entry" title="Link para este termo">¶</a></dt><dd><p class="translated">Um local único no <a class="reference internal" href="#term-import-path"><span class="xref std std-term">caminho de importação</span></a> que o <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">localizador baseado no caminho</span></a> consulta para encontrar módulos a serem importados.</p>
</dd>
<dt class="translated" id="term-path-entry-finder">localizador de entrada de caminho<a class="headerlink" href="#term-path-entry-finder" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-finder"><span class="xref std std-term">localizador</span></a> retornado por um chamável em <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (ou seja, um <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">gancho de entrada de caminho</span></a>) que sabe como localizar os módulos <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a>.</p>
<p class="translated">Veja <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> para os métodos que localizadores de entrada de caminho implementam.</p>
</dd>
<dt class="translated" id="term-path-entry-hook">gancho de entrada de caminho<a class="headerlink" href="#term-path-entry-hook" title="Link para este termo">¶</a></dt><dd><p class="translated">Um chamável na lista <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> que retorna um <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">localizador de entrada de caminho</span></a> caso saiba como localizar módulos em uma <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrada de caminho</span></a> específica.</p>
</dd>
<dt class="translated" id="term-path-based-finder">localizador baseado no caminho<a class="headerlink" href="#term-path-based-finder" title="Link para este termo">¶</a></dt><dd><p class="translated">Um dos <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">localizadores de metacaminho</span></a> padrão que procura por um <a class="reference internal" href="#term-import-path"><span class="xref std std-term">caminho de importação</span></a> de módulos.</p>
</dd>
<dt class="translated" id="term-path-like-object">objeto caminho ou similar<a class="headerlink" href="#term-path-like-object" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto representando um caminho de sistema de arquivos. Um objeto caminho ou similar é ou um objeto <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> representando um caminho, ou um objeto implementando o protocolo <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a>. Um objeto que suporta o protocolo <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> pode ser convertido para um arquivo de caminho do sistema <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, através da chamada da função <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a>; <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> e <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> podem ser usadas para garantir um <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> como resultado, respectivamente. Introduzido na <span class="target" id="index-106"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a>.</p>
</dd>
<dt class="translated" id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Link para este termo">¶</a></dt><dd><p class="translated">Proposta de melhoria do Python. Uma PEP é um documento de design que fornece informação para a comunidade Python, ou descreve uma nova funcionalidade para o Python ou seus predecessores ou ambientes. PEPs devem prover uma especificação técnica concisa e um racional para funcionalidades propostas.</p>
<p class="translated">PEPs têm a intenção de ser os mecanismos primários para propor novas funcionalidades significativas, para coletar opiniões da comunidade sobre um problema, e para documentar as decisões de design que foram adicionadas ao Python. O autor da PEP é responsável por construir um consenso dentro da comunidade e documentar opiniões dissidentes.</p>
<p class="translated">Veja <span class="target" id="index-107"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>.</p>
</dd>
<dt class="translated" id="term-portion">porção<a class="headerlink" href="#term-portion" title="Link para este termo">¶</a></dt><dd><p class="translated">Um conjunto de arquivos em um único diretório (possivelmente armazenado em um arquivo zip) que contribuem para um pacote de espaço de nomes, conforme definido em <span class="target" id="index-108"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
</dd>
<dt class="translated" id="term-positional-argument">argumento posicional<a class="headerlink" href="#term-positional-argument" title="Link para este termo">¶</a></dt><dd><p class="translated">Veja <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumento</span></a>.</p>
</dd>
<dt class="translated" id="term-provisional-API">API provisória<a class="headerlink" href="#term-provisional-API" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma API provisória é uma API que foi deliberadamente excluída das bibliotecas padrões com compatibilidade retroativa garantida. Enquanto mudanças maiores para tais interfaces não são esperadas, contanto que elas sejam marcadas como provisórias, mudanças retroativas incompatíveis (até e incluindo a remoção da interface) podem ocorrer se consideradas necessárias pelos desenvolvedores principais. Tais mudanças não serão feitas gratuitamente – elas irão ocorrer apenas se sérias falhas fundamentais forem descobertas, que foram esquecidas anteriormente a inclusão da API.</p>
<p class="translated">Mesmo para APIs provisórias, mudanças retroativas incompatíveis são vistas como uma “solução em último caso” - cada tentativa ainda será feita para encontrar uma resolução retroativa compatível para quaisquer problemas encontrados.</p>
<p class="translated">Esse processo permite que a biblioteca padrão continue a evoluir com o passar do tempo, sem se prender em erros de design problemáticos por períodos de tempo prolongados. Veja <span class="target" id="index-109"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> para mais detalhes.</p>
</dd>
<dt class="translated" id="term-provisional-package">pacote provisório<a class="headerlink" href="#term-provisional-package" title="Link para este termo">¶</a></dt><dd><p class="translated">Veja <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">API provisória</span></a>.</p>
</dd>
<dt class="translated" id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Link para este termo">¶</a></dt><dd><p class="translated">Apelido para a linha de lançamento da versão do Python 3.x (cunhada há muito tempo, quando o lançamento da versão 3 era algo em um futuro muito distante.) Esse termo possui a seguinte abreviação: “Py3k”.</p>
</dd>
<dt class="translated" id="term-Pythonic">Pythônico<a class="headerlink" href="#term-Pythonic" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma ideia ou um pedaço de código que segue de perto as formas de escritas mais comuns da linguagem Python, ao invés de implementar códigos usando conceitos comuns a outras linguagens. Por exemplo, um formato comum em Python é fazer um laço sobre todos os elementos de uma iterável usando a instrução <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Muitas outras linguagens não têm esse tipo de construção, então as pessoas que não estão familiarizadas com o Python usam um contador numérico:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comida</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">comida</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">Ao contrário do método mais limpo, Pythônico:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">parte</span> <span class="ow">in</span> <span class="n">comida</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">parte</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-qualified-name">nome qualificado<a class="headerlink" href="#term-qualified-name" title="Link para este termo">¶</a></dt><dd><p class="translated">Um nome pontilhado (quando 2 termos são ligados por um ponto) que mostra o “path” do escopo global de um módulo para uma classe, função ou método definido num determinado módulo, conforme definido pela <span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a>. Para funções e classes de nível superior, o nome qualificado é o mesmo que o nome do objeto:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span><span class="w"> </span><span class="nf">metodo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">metodo</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.metodo&#39;</span>
</pre></div>
</div>
<p class="translated">Quando usado para se referir a módulos, o <em>nome totalmente qualificado</em> significa todo o caminho pontilhado para o módulo, incluindo quaisquer pacotes pai, por exemplo: <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-reference-count">contagem de referências<a class="headerlink" href="#term-reference-count" title="Link para este termo">¶</a></dt><dd><p class="translated">O número de referências a um objeto. Quando a contagem de referências de um objeto cai para zero, ele é desalocado. Alguns objetos são <a class="reference internal" href="#term-immortal"><span class="xref std std-term">imortais</span></a> e têm contagens de referências que nunca são modificadas e, portanto, os objetos nunca são desalocados. A contagem de referências geralmente não é visível para o código Python, mas é um elemento-chave da implementação do <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a>. Os programadores podem chamar a função <a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> para retornar a contagem de referências para um objeto específico.</p>
<p class="untranslated">In <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a>, reference counts are not considered to be stable
or well-defined values; the number of references to an object, and how
that number is affected by Python code, may be different between
versions.</p>
</dd>
<dt class="translated" id="term-regular-package">pacote regular<a class="headerlink" href="#term-regular-package" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-package"><span class="xref std std-term">pacote</span></a> tradicional, como um diretório contendo um arquivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">pacote de espaço de nomes</span></a>.</p>
</dd>
<dt class="translated" id="term-REPL">REPL<a class="headerlink" href="#term-REPL" title="Link para este termo">¶</a></dt><dd><p class="translated">Um acrônimo para “read–eval–print loop”, outro nome para o console <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interativo</span></a> do interpretador.</p>
</dd>
<dt class="translated" id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma declaração dentro de uma classe que economiza memória pré-declarando espaço para atributos de instâncias, e eliminando dicionários de instâncias. Apesar de popular, a técnica é um tanto quanto complicada de acertar, e é melhor se for reservada para casos raros, onde existe uma grande quantidade de instâncias em uma aplicação onde a memória é crítica.</p>
</dd>
<dt class="translated" id="term-sequence">sequência<a class="headerlink" href="#term-sequence" title="Link para este termo">¶</a></dt><dd><p class="translated">Um <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterável</span></a> com suporte para acesso eficiente a seus elementos através de índices inteiros via método especial <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> e que define o método <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> que devolve o tamanho da sequência. Alguns tipos de sequência embutidos são: <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, e <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note que <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> também tem suporte para <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> e <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, mas é considerado um mapeamento e não uma sequência porque a busca usa uma chave <a class="reference internal" href="#term-hashable"><span class="xref std std-term">hasheável</span></a> arbitrária em vez de inteiros.</p>
<p class="translated">A classe base abstrata <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> define uma interface mais rica que vai além de apenas <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> e <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>, adicionando <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <a class="reference internal" href="reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, e <a class="reference internal" href="reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>. Tipos que implementam essa interface podem ser explicitamente registrados usando <a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a>. Para mais documentação sobre métodos de sequências em geral, veja <a class="reference internal" href="library/stdtypes.html#typesseq-common"><span class="std std-ref">Operações comuns de sequências</span></a>.</p>
</dd>
<dt class="translated" id="term-set-comprehension">compreensão de conjunto<a class="headerlink" href="#term-set-comprehension" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma maneira compacta de processar todos ou parte dos elementos em iterável e retornar um conjunto com os resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> gera um conjunto de strings <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>.  Veja <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Sintaxe de criação de listas, conjuntos e dicionários</span></a>.</p>
</dd>
<dt class="translated" id="term-single-dispatch">despacho único<a class="headerlink" href="#term-single-dispatch" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma forma de despacho de <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">função genérica</span></a> onde a implementação é escolhida com base no tipo de um único argumento.</p>
</dd>
<dt class="translated" id="term-slice">fatia<a class="headerlink" href="#term-slice" title="Link para este termo">¶</a></dt><dd><p class="translated">Um objeto geralmente contendo uma parte de uma <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequência</span></a>. Uma fatia é criada usando a notação de subscrito <code class="docutils literal notranslate"><span class="pre">[]</span></code> pode conter também até dois pontos entre números, como em <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code>. A notação de suporte (subscrito) utiliza objetos <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> internamente.</p>
</dd>
<dt class="translated" id="term-soft-deprecated">suavemente descontinuado<a class="headerlink" href="#term-soft-deprecated" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma API suavemente descontinuada não deve ser usada em código novo, mas é seguro para código já existente usá-la. A API continua documentada e testada, mas não será melhorada.</p>
<p class="translated">A descontinuação suave, diferentemente da descontinuação normal, não planeja remover a API e não emitirá avisos.</p>
<p class="translated">Veja <a class="reference external" href="https://peps.python.org/pep-0387/#soft-deprecation">PEP 387: Descontinuação suave</a>.</p>
</dd>
<dt class="translated" id="term-special-method">método especial<a class="headerlink" href="#term-special-method" title="Link para este termo">¶</a></dt><dd><p class="translated" id="index-36">Um método que é chamado implicitamente pelo Python para executar uma certa operação em um tipo, como uma adição por exemplo. Tais métodos tem nomes iniciando e terminando com dois underscores. Métodos especiais estão documentados em <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Nomes de métodos especiais</span></a>.</p>
</dd>
<dt class="translated" id="term-standard-library">biblioteca padrão<a class="headerlink" href="#term-standard-library" title="Link para este termo">¶</a></dt><dd><p class="translated">A coleção de <a class="reference internal" href="#term-package"><span class="xref std std-term">pacotes</span></a>, <a class="reference internal" href="#term-module"><span class="xref std std-term">módulos</span></a> e <a class="reference internal" href="#term-extension-module"><span class="xref std std-term">módulos de extensão</span></a> distribuída como parte do pacote do interpretador Python oficial. A relação exata de elementos da coleção pode variar de acordo com a plataforma, bibliotecas de sistema disponíveis ou outros critérios. A documentação pode ser encontrada em <a class="reference internal" href="library/index.html#library-index"><span class="std std-ref">A Biblioteca Padrão do Python</span></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="library/sys.html#sys.stdlib_module_names" title="sys.stdlib_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdlib_module_names</span></code></a> para obter uma lista de todos os possíveis nomes de módulos da biblioteca padrão.</p>
</dd>
<dt class="translated" id="term-statement">instrução<a class="headerlink" href="#term-statement" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma instrução é parte de uma suíte (um “bloco” de código). Uma instrução é ou uma <a class="reference internal" href="#term-expression"><span class="xref std std-term">expressão</span></a> ou uma de várias construções com uma palavra reservada, tal como <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> ou <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
</dd>
<dt class="translated" id="term-static-type-checker">verificador de tipo estático<a class="headerlink" href="#term-static-type-checker" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma ferramenta externa que lê código Python e o analisa, procurando por problemas como tipos incorretos. Consulte também <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a> e o módulo <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>.</p>
</dd>
<dt class="translated" id="term-stdlib">stdlib<a class="headerlink" href="#term-stdlib" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma abreviação do termo original em inglês para <a class="reference internal" href="#term-standard-library"><span class="xref std std-term">biblioteca padrão</span></a> (standard library).</p>
</dd>
<dt class="translated" id="term-strong-reference">referência forte<a class="headerlink" href="#term-strong-reference" title="Link para este termo">¶</a></dt><dd><p class="translated">Na API C do Python, uma referência forte é uma referência a um objeto que pertence ao código que contém a referência. A referência forte é obtida chamando <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> quando a referência é criada e liberada com <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> quando a referência é excluída.</p>
<p class="translated">A função <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> pode ser usada para criar uma referência forte para um objeto. Normalmente, a função <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> deve ser chamada na referência forte antes de sair do escopo da referência forte, para evitar o vazamento de uma referência.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">referência emprestada</span></a>.</p>
</dd>
<dt class="translated" id="term-text-encoding">codificador de texto<a class="headerlink" href="#term-text-encoding" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma string em Python é uma sequência de pontos de código Unicode (no intervalo <code class="docutils literal notranslate"><span class="pre">U+0000</span></code>–<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). Para armazenar ou transferir uma string, ela precisa ser serializada como uma sequência de bytes.</p>
<p class="translated">A serialização de uma string em uma sequência de bytes é conhecida como “codificação” e a recriação da string a partir de uma sequência de bytes é conhecida como “decodificação”.</p>
<p class="translated">Há uma variedade de diferentes serializações de texto <a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a>, que são coletivamente chamadas de “codificações de texto”.</p>
</dd>
<dt class="translated" id="term-text-file">arquivo texto<a class="headerlink" href="#term-text-file" title="Link para este termo">¶</a></dt><dd><p class="translated">Um  <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objeto arquivo</span></a> apto a ler e escrever objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Geralmente, um arquivo texto, na verdade, acessa um fluxo de dados de bytes e captura o <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">codificador de texto</span></a> automaticamente. Exemplos de arquivos texto são: arquivos abertos em modo texto (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> or <code class="docutils literal notranslate"><span class="pre">'w'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, e instâncias de <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>.</p>
<p class="translated">Veja também <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">arquivo binário</span></a> para um objeto arquivo apto a ler e escrever <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objetos bytes ou similares</span></a>.</p>
</dd>
<dt class="translated" id="term-token">token<a class="headerlink" href="#term-token" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma pequena unidade de código-fonte, gerada pelo <a class="reference internal" href="reference/lexical_analysis.html#lexical"><span class="std std-ref">analisador léxico</span></a> (também chamado de <em>tokenizador</em>). Nomes, números, strings, operadores, quebras de linha e similares são representados por tokens.</p>
<p class="translated">O módulo <a class="reference internal" href="library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tokenize</span></code></a> expõe o analisador léxico do Python. O módulo <a class="reference internal" href="library/token.html#module-token" title="token: Constants representing terminal nodes of the parse tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">token</span></code></a> contém informações sobre os vários tipos de tokens.</p>
</dd>
<dt class="translated" id="term-triple-quoted-string">aspas triplas<a class="headerlink" href="#term-triple-quoted-string" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma string que está definida com três ocorrências de aspas duplas (”) ou apóstrofos (‘). Enquanto elas não fornecem nenhuma funcionalidade não disponível com strings de aspas simples, elas são úteis para inúmeras razões. Elas permitem que você inclua aspas simples e duplas não escapadas dentro de uma string, e elas podem utilizar múltiplas linhas sem o uso de caractere de continuação, fazendo-as especialmente úteis quando escrevemos documentação em docstrings.</p>
</dd>
<dt class="translated" id="term-type">tipo<a class="headerlink" href="#term-type" title="Link para este termo">¶</a></dt><dd><p class="translated">O tipo de um objeto Python determina qual classe de objeto ele é; cada objeto tem um tipo. Um tipo de objeto é acessível pelo atributo <a class="reference internal" href="reference/datamodel.html#object.__class__" title="object.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> ou pode ser recuperado com <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.</p>
</dd>
<dt class="translated" id="term-type-alias">apelido de tipo<a class="headerlink" href="#term-type-alias" title="Link para este termo">¶</a></dt><dd><p class="translated">Um sinônimo para um tipo, criado através da atribuição do tipo para um identificador.</p>
<p class="translated">Apelidos de tipo são úteis para simplificar <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a>. Por exemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">remove_tons_de_cinza</span><span class="p">(</span>
        <span class="n">cores</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">pode tornar-se mais legível desta forma:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Cor</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">remove_tons_de_cinza</span><span class="p">(</span><span class="n">cores</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Cor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Cor</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">Veja <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> e <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que descreve esta funcionalidade.</p>
</dd>
<dt class="translated" id="term-type-hint">dica de tipo<a class="headerlink" href="#term-type-hint" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotação</span></a> que especifica o tipo esperado para uma variável, um atributo de classe, ou um parâmetro ou valor de retorno de função.</p>
<p class="translated">Dicas de tipo são opcionais e não são exigidas pelo Python, mas são úteis para <a class="reference internal" href="#term-static-type-checker"><span class="xref std std-term">verificadores de tipo estático</span></a>. Elas também ajudam IDEs a completar e refatorar código.</p>
<p class="translated">Dicas de tipo de variáveis globais, atributos de classes, e funções, mas não de variáveis locais, podem ser acessadas usando <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>.</p>
<p class="translated">Veja <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> e <span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que descreve esta funcionalidade.</p>
</dd>
<dt class="translated" id="term-universal-newlines">novas linhas universais<a class="headerlink" href="#term-universal-newlines" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma maneira de interpretar fluxos de textos, na qual todos estes são reconhecidos como caracteres de fim de linha: a convenção para fim de linha no Unix <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, a convenção no Windows <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>, e a antiga convenção no Macintosh <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>. Veja <span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> e <span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a>, bem como <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> para uso adicional.</p>
</dd>
<dt class="translated" id="term-variable-annotation">anotação de variável<a class="headerlink" href="#term-variable-annotation" title="Link para este termo">¶</a></dt><dd><p class="translated">Uma <a class="reference internal" href="#term-annotation"><span class="xref std std-term">anotação</span></a> de uma variável ou um atributo de classe.</p>
<p class="translated">Ao fazer uma anotação de uma variável ou um atributo de classe, a atribuição é opcional:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="n">campo</span><span class="p">:</span> <span class="s1">&#39;anotação&#39;</span>
</pre></div>
</div>
<p class="translated">Anotações de variáveis são normalmente usadas para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">dicas de tipo</span></a>: por exemplo, espera-se que esta variável receba valores do tipo <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">contagem</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p class="translated">A sintaxe de anotação de variável é explicada na seção <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Instruções de atribuição anotada</span></a>.</p>
<p class="translated">Veja <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">anotação de função</span></a>, <span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> e <span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, que descrevem esta funcionalidade. Veja também <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Boas práticas para anotações</span></a> para as melhores práticas sobre como trabalhar com anotações.</p>
</dd>
<dt class="translated" id="term-virtual-environment">ambiente virtual<a class="headerlink" href="#term-virtual-environment" title="Link para este termo">¶</a></dt><dd><p class="translated">Um ambiente de execução isolado que permite usuários Python e aplicações instalarem e atualizarem pacotes Python sem interferir no comportamento de outras aplicações Python em execução no mesmo sistema.</p>
<p class="translated">Veja também <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>.</p>
</dd>
<dt class="translated" id="term-virtual-machine">máquina virtual<a class="headerlink" href="#term-virtual-machine" title="Link para este termo">¶</a></dt><dd><p class="translated">Um computador definido inteiramente em software. A máquina virtual de Python executa o <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> emitido pelo compilador de bytecode.</p>
</dd>
<dt class="translated" id="term-Zen-of-Python">Zen do Python<a class="headerlink" href="#term-Zen-of-Python" title="Link para este termo">¶</a></dt><dd><p class="translated">Lista de princípios de projeto e filosofias do Python que são úteis para a compreensão e uso da linguagem. A lista é exibida quando se digita “<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>” no console interativo.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Tópico anterior</h4>
    <p class="topless"><a href="deprecations/index.html"
                          title="capítulo anterior">Descontinuações</a></p>
  </div>
  <div>
    <h4>Próximo tópico</h4>
    <p class="topless"><a href="about.html"
                          title="próximo capítulo">Sobre esta documentação</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Relatar um bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst?plain=1"
            rel="nofollow">Mostrar o código-fonte
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Recolher painel lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="Sobre esta documentação"
             >próximo</a> |</li>
        <li class="right" >
          <a href="deprecations/index.html" title="Descontinuações"
             >anterior</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.13.5 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossário</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Busca rápida" aria-label="Busca rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="copyright.html">
    
    Direitos autorais
    
      </a>
     2001-2025, Python Software Foundation.
    <br>
    This page is licensed under the Python Software Foundation License Version 2.
    <br>
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br>
    
      See <a href="/license.html">History and License</a> for more information.<br>
    
    
    <br>

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br>
    <br>
      Última atualização em ago. 03, 2025 (07:16 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br>

    Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 8.2.3.
    </div>

  </body>
</html>