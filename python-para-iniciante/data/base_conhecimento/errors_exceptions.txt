Until now error messages havenât been more than mentioned, but if you have tried
out the examples you have probably seen some.  There are (at least) two
distinguishable kinds of errors:syntax errorsandexceptions.

Syntax errors, also known as parsing errors, are perhaps the most common kind of
complaint you get while you are still learning Python:

>>>whileTrueprint('Hello world')File"<stdin>", line1whileTrueprint('Hello world')^^^^^SyntaxError:invalid syntax

The parser repeats the offending line and displays little arrows pointing
at the place where the error was detected.  Note that this is not always the
place that needs to be fixed.  In the example, the error is detected at the
functionprint(), since a colon (':') is missing just before it.

print()

':'

The file name (<stdin>in our example) and line number are printed so you
know where to look in case the input came from a file.

<stdin>

Even if a statement or expression is syntactically correct, it may cause an
error when an attempt is made to execute it. Errors detected during execution
are calledexceptionsand are not unconditionally fatal: you will soon learn
how to handle them in Python programs.  Most exceptions are not handled by
programs, however, and result in error messages as shown here:

>>>10*(1/0)Traceback (most recent call last):File"<stdin>", line1, in<module>10*(1/0)~^~ZeroDivisionError:division by zero>>>4+spam*3Traceback (most recent call last):File"<stdin>", line1, in<module>4+spam*3^^^^NameError:name 'spam' is not defined>>>'2'+2Traceback (most recent call last):File"<stdin>", line1, in<module>'2'+2~~~~^~~TypeError:can only concatenate str (not "int") to str

The last line of the error message indicates what happened. Exceptions come in
different types, and the type is printed as part of the message: the types in
the example areZeroDivisionError,NameErrorandTypeError.
The string printed as the exception type is the name of the built-in exception
that occurred.  This is true for all built-in exceptions, but need not be true
for user-defined exceptions (although it is a useful convention). Standard
exception names are built-in identifiers (not reserved keywords).

ZeroDivisionError

NameError

TypeError

The rest of the line provides detail based on the type of exception and what
caused it.

The preceding part of the error message shows the context where the exception
occurred, in the form of a stack traceback. In general it contains a stack
traceback listing source lines; however, it will not display lines read from
standard input.

Built-in Exceptionslists the built-in exceptions and their meanings.

It is possible to write programs that handle selected exceptions. Look at the
following example, which asks the user for input until a valid integer has been
entered, but allows the user to interrupt the program (usingControl-Cor
whatever the operating system supports); note that a user-generated interruption
is signalled by raising theKeyboardInterruptexception.

KeyboardInterrupt

>>>whileTrue:...try:...x=int(input("Please enter a number: "))...break...exceptValueError:...print("Oops!  That was no valid number.  Try again...")...

Thetrystatement works as follows.

try

First, thetry clause(the statement(s) between thetryandexceptkeywords) is executed.If no exception occurs, theexcept clauseis skipped and execution of thetrystatement is finished.If an exception occurs during execution of thetryclause, the rest of the
clause is skipped.  Then, if its type matches the exception named after theexceptkeyword, theexcept clauseis executed, and then execution
continues after the try/except block.If an exception occurs which does not match the exception named in theexcept
clause, it is passed on to outertrystatements; if no handler is
found, it is anunhandled exceptionand execution stops with an error message.

First, thetry clause(the statement(s) between thetryandexceptkeywords) is executed.

First, thetry clause(the statement(s) between thetryandexceptkeywords) is executed.

try

except

If no exception occurs, theexcept clauseis skipped and execution of thetrystatement is finished.

If no exception occurs, theexcept clauseis skipped and execution of thetrystatement is finished.

try

If an exception occurs during execution of thetryclause, the rest of the
clause is skipped.  Then, if its type matches the exception named after theexceptkeyword, theexcept clauseis executed, and then execution
continues after the try/except block.

If an exception occurs during execution of thetryclause, the rest of the
clause is skipped.  Then, if its type matches the exception named after theexceptkeyword, theexcept clauseis executed, and then execution
continues after the try/except block.

try

except

If an exception occurs which does not match the exception named in theexcept
clause, it is passed on to outertrystatements; if no handler is
found, it is anunhandled exceptionand execution stops with an error message.

If an exception occurs which does not match the exception named in theexcept
clause, it is passed on to outertrystatements; if no handler is
found, it is anunhandled exceptionand execution stops with an error message.

try

Atrystatement may have more than oneexcept clause, to specify
handlers for different exceptions.  At most one handler will be executed.
Handlers only handle exceptions that occur in the correspondingtry clause,
not in other handlers of the sametrystatement.  Anexcept clausemay name multiple exceptions as a parenthesized tuple, for example:

try

try

...except(RuntimeError,TypeError,NameError):...pass

A class in anexceptclause matches exceptions which are instances of the
class itself or one of its derived classes (but not the other way around â anexcept clauselisting a derived class does not match instances of its base classes).
For example, the following code will print B, C, D in that order:

except

classB(Exception):passclassC(B):passclassD(C):passforclsin[B,C,D]:try:raisecls()exceptD:print("D")exceptC:print("C")exceptB:print("B")

Note that if theexcept clauseswere reversed (withexceptBfirst), it
would have printed B, B, B â the first matchingexcept clauseis triggered.

exceptB

When an exception occurs, it may have associated values, also known as the
exceptionâsarguments. The presence and types of the arguments depend on the
exception type.

Theexcept clausemay specify a variable after the exception name.  The
variable is bound to the exception instance which typically has anargsattribute that stores the arguments. For convenience, builtin exception
types define__str__()to print all the arguments without explicitly
accessing.args.

args

__str__()

.args

>>>try:...raiseException('spam','eggs')...exceptExceptionasinst:...print(type(inst))# the exception type...print(inst.args)# arguments stored in .args...print(inst)# __str__ allows args to be printed directly,...# but may be overridden in exception subclasses...x,y=inst.args# unpack args...print('x =',x)...print('y =',y)...<class 'Exception'>('spam', 'eggs')('spam', 'eggs')x = spamy = eggs

The exceptionâs__str__()output is printed as the last part (âdetailâ)
of the message for unhandled exceptions.

__str__()

BaseExceptionis the common base class of all exceptions. One of its
subclasses,Exception, is the base class of all the non-fatal exceptions.
Exceptions which are not subclasses ofExceptionare not typically
handled, because they are used to indicate that the program should terminate.
They includeSystemExitwhich is raised bysys.exit()andKeyboardInterruptwhich is raised when a user wishes to interrupt
the program.

BaseException

Exception

Exception

SystemExit

sys.exit()

KeyboardInterrupt

Exceptioncan be used as a wildcard that catches (almost) everything.
However, it is good practice to be as specific as possible with the types
of exceptions that we intend to handle, and to allow any unexpected
exceptions to propagate on.

Exception

The most common pattern for handlingExceptionis to print or log
the exception and then re-raise it (allowing a caller to handle the
exception as well):

Exception

importsystry:f=open('myfile.txt')s=f.readline()i=int(s.strip())exceptOSErroraserr:print("OS error:",err)exceptValueError:print("Could not convert data to an integer.")exceptExceptionaserr:print(f"Unexpected{err=},{type(err)=}")raise

Thetryâ¦exceptstatement has an optionalelse
clause, which, when present, must follow allexcept clauses.  It is useful
for code that must be executed if thetry clausedoes not raise an exception.
For example:

try

except

forarginsys.argv[1:]:try:f=open(arg,'r')exceptOSError:print('cannot open',arg)else:print(arg,'has',len(f.readlines()),'lines')f.close()

The use of theelseclause is better than adding additional code to
thetryclause because it avoids accidentally catching an exception
that wasnât raised by the code being protected by thetryâ¦exceptstatement.

else

try

try

except

Exception handlers do not handle only exceptions that occur immediately in thetry clause, but also those that occur inside functions that are called (even
indirectly) in thetry clause. For example:

>>>defthis_fails():...x=1/0...>>>try:...this_fails()...exceptZeroDivisionErroraserr:...print('Handling run-time error:',err)...Handling run-time error: division by zero

Theraisestatement allows the programmer to force a specified
exception to occur. For example:

raise

>>>raiseNameError('HiThere')Traceback (most recent call last):File"<stdin>", line1, in<module>raiseNameError('HiThere')NameError:HiThere

The sole argument toraiseindicates the exception to be raised.
This must be either an exception instance or an exception class (a class that
derives fromBaseException, such asExceptionor one of its
subclasses).  If an exception class is passed, it will be implicitly
instantiated by calling its constructor with no arguments:

raise

BaseException

Exception

raiseValueError# shorthand for 'raise ValueError()'

If you need to determine whether an exception was raised but donât intend to
handle it, a simpler form of theraisestatement allows you to
re-raise the exception:

raise

>>>try:...raiseNameError('HiThere')...exceptNameError:...print('An exception flew by!')...raise...An exception flew by!Traceback (most recent call last):File"<stdin>", line2, in<module>raiseNameError('HiThere')NameError:HiThere

If an unhandled exception occurs inside anexceptsection, it will
have the exception being handled attached to it and included in the error
message:

except

>>>try:...open("database.sqlite")...exceptOSError:...raiseRuntimeError("unable to handle error")...Traceback (most recent call last):File"<stdin>", line2, in<module>open("database.sqlite")~~~~^^^^^^^^^^^^^^^^^^^FileNotFoundError:[Errno 2] No such file or directory: 'database.sqlite'During handling of the above exception, another exception occurred:Traceback (most recent call last):File"<stdin>", line4, in<module>raiseRuntimeError("unable to handle error")RuntimeError:unable to handle error

To indicate that an exception is a direct consequence of another, theraisestatement allows an optionalfromclause:

raise

from

# exc must be exception instance or None.raiseRuntimeErrorfromexc

This can be useful when you are transforming exceptions. For example:

>>>deffunc():...raiseConnectionError...>>>try:...func()...exceptConnectionErrorasexc:...raiseRuntimeError('Failed to open database')fromexc...Traceback (most recent call last):File"<stdin>", line2, in<module>func()~~~~^^File"<stdin>", line2, infuncConnectionErrorThe above exception was the direct cause of the following exception:Traceback (most recent call last):File"<stdin>", line4, in<module>raiseRuntimeError('Failed to open database')fromexcRuntimeError:Failed to open database

It also allows disabling automatic exception chaining using thefromNoneidiom:

fromNone

>>>try:...open('database.sqlite')...exceptOSError:...raiseRuntimeErrorfromNone...Traceback (most recent call last):File"<stdin>", line4, in<module>raiseRuntimeErrorfromNoneRuntimeError

For more information about chaining mechanics, seeBuilt-in Exceptions.

Programs may name their own exceptions by creating a new exception class (seeClassesfor more about Python classes).  Exceptions should typically
be derived from theExceptionclass, either directly or indirectly.

Exception

Exception classes can be defined which do anything any other class can do, but
are usually kept simple, often only offering a number of attributes that allow
information about the error to be extracted by handlers for the exception.

Most exceptions are defined with names that end in âErrorâ, similar to the
naming of the standard exceptions.

Many standard modules define their own exceptions to report errors that may
occur in functions they define.

Thetrystatement has another optional clause which is intended to
define clean-up actions that must be executed under all circumstances.  For
example:

try

>>>try:...raiseKeyboardInterrupt...finally:...print('Goodbye, world!')...Goodbye, world!Traceback (most recent call last):File"<stdin>", line2, in<module>raiseKeyboardInterruptKeyboardInterrupt

If afinallyclause is present, thefinallyclause will execute as the last task before thetrystatement completes. Thefinallyclause runs whether or
not thetrystatement produces an exception. The following
points discuss more complex cases when an exception occurs:

finally

finally

try

finally

try

If an exception occurs during execution of thetryclause, the exception may be handled by anexceptclause. If the exception is not handled by anexceptclause, the exception is re-raised after thefinallyclause has been executed.An exception could occur during execution of anexceptorelseclause. Again, the exception is re-raised after
thefinallyclause has been executed.If thefinallyclause executes abreak,continueorreturnstatement, exceptions are not
re-raised.If thetrystatement reaches abreak,continueorreturnstatement, thefinallyclause will execute just prior to thebreak,continueorreturnstatementâs execution.If afinallyclause includes areturnstatement, the returned value will be the one from thefinallyclauseâsreturnstatement, not the
value from thetryclauseâsreturnstatement.

If an exception occurs during execution of thetryclause, the exception may be handled by anexceptclause. If the exception is not handled by anexceptclause, the exception is re-raised after thefinallyclause has been executed.

If an exception occurs during execution of thetryclause, the exception may be handled by anexceptclause. If the exception is not handled by anexceptclause, the exception is re-raised after thefinallyclause has been executed.

try

except

except

finally

An exception could occur during execution of anexceptorelseclause. Again, the exception is re-raised after
thefinallyclause has been executed.

An exception could occur during execution of anexceptorelseclause. Again, the exception is re-raised after
thefinallyclause has been executed.

except

else

finally

If thefinallyclause executes abreak,continueorreturnstatement, exceptions are not
re-raised.

If thefinallyclause executes abreak,continueorreturnstatement, exceptions are not
re-raised.

finally

break

continue

return

If thetrystatement reaches abreak,continueorreturnstatement, thefinallyclause will execute just prior to thebreak,continueorreturnstatementâs execution.

If thetrystatement reaches abreak,continueorreturnstatement, thefinallyclause will execute just prior to thebreak,continueorreturnstatementâs execution.

try

break

continue

return

finally

break

continue

return

If afinallyclause includes areturnstatement, the returned value will be the one from thefinallyclauseâsreturnstatement, not the
value from thetryclauseâsreturnstatement.

If afinallyclause includes areturnstatement, the returned value will be the one from thefinallyclauseâsreturnstatement, not the
value from thetryclauseâsreturnstatement.

finally

return

finally

return

try

return

For example:

>>>defbool_return():...try:...returnTrue...finally:...returnFalse...>>>bool_return()False

A more complicated example:

>>>defdivide(x,y):...try:...result=x/y...exceptZeroDivisionError:...print("division by zero!")...else:...print("result is",result)...finally:...print("executing finally clause")...>>>divide(2,1)result is 2.0executing finally clause>>>divide(2,0)division by zero!executing finally clause>>>divide("2","1")executing finally clauseTraceback (most recent call last):File"<stdin>", line1, in<module>divide("2","1")~~~~~~^^^^^^^^^^File"<stdin>", line3, individeresult=x/y~~^~~TypeError:unsupported operand type(s) for /: 'str' and 'str'

As you can see, thefinallyclause is executed in any event.  TheTypeErrorraised by dividing two strings is not handled by theexceptclause and therefore re-raised after thefinallyclause has been executed.

finally

TypeError

except

finally

In real world applications, thefinallyclause is useful for
releasing external resources (such as files or network connections), regardless
of whether the use of the resource was successful.

finally

Some objects define standard clean-up actions to be undertaken when the object
is no longer needed, regardless of whether or not the operation using the object
succeeded or failed. Look at the following example, which tries to open a file
and print its contents to the screen.

forlineinopen("myfile.txt"):print(line,end="")

The problem with this code is that it leaves the file open for an indeterminate
amount of time after this part of the code has finished executing.
This is not an issue in simple scripts, but can be a problem for larger
applications. Thewithstatement allows objects like files to be
used in a way that ensures they are always cleaned up promptly and correctly.

with

withopen("myfile.txt")asf:forlineinf:print(line,end="")

After the statement is executed, the filefis always closed, even if a
problem was encountered while processing the lines. Objects which, like files,
provide predefined clean-up actions will indicate this in their documentation.

There are situations where it is necessary to report several exceptions that
have occurred. This is often the case in concurrency frameworks, when several
tasks may have failed in parallel, but there are also other use cases where
it is desirable to continue execution and collect multiple errors rather than
raise the first exception.

The builtinExceptionGroupwraps a list of exception instances so
that they can be raised together. It is an exception itself, so it can be
caught like any other exception.

ExceptionGroup

>>>deff():...excs=[OSError('error 1'),SystemError('error 2')]...raiseExceptionGroup('there were problems',excs)...>>>f()+ Exception Group Traceback (most recent call last):|   File "<stdin>", line 1, in <module>|     f()|     ~^^|   File "<stdin>", line 3, in f|     raise ExceptionGroup('there were problems', excs)| ExceptionGroup: there were problems (2 sub-exceptions)+-+---------------- 1 ----------------| OSError: error 1+---------------- 2 ----------------| SystemError: error 2+------------------------------------>>>try:...f()...exceptExceptionase:...print(f'caught{type(e)}: e')...caught <class 'ExceptionGroup'>: e>>>

By usingexcept*instead ofexcept, we can selectively
handle only the exceptions in the group that match a certain
type. In the following example, which shows a nested exception
group, eachexcept*clause extracts from the group exceptions
of a certain type while letting all other exceptions propagate to
other clauses and eventually to be reraised.

except*

except

except*

>>>deff():...raiseExceptionGroup(..."group1",...[...OSError(1),...SystemError(2),...ExceptionGroup(..."group2",...[...OSError(3),...RecursionError(4)...]...)...]...)...>>>try:...f()...except*OSErrorase:...print("There were OSErrors")...except*SystemErrorase:...print("There were SystemErrors")...There were OSErrorsThere were SystemErrors+ Exception Group Traceback (most recent call last):|   File "<stdin>", line 2, in <module>|     f()|     ~^^|   File "<stdin>", line 2, in f|     raise ExceptionGroup(|     ...<12 lines>...|     )| ExceptionGroup: group1 (1 sub-exception)+-+---------------- 1 ----------------| ExceptionGroup: group2 (1 sub-exception)+-+---------------- 1 ----------------| RecursionError: 4+------------------------------------>>>

Note that the exceptions nested in an exception group must be instances,
not types. This is because in practice the exceptions would typically
be ones that have already been raised and caught by the program, along
the following pattern:

>>>excs=[]...fortestintests:...try:...test.run()...exceptExceptionase:...excs.append(e)...>>>ifexcs:...raiseExceptionGroup("Test Failures",excs)...

When an exception is created in order to be raised, it is usually initialized
with information that describes the error that has occurred. There are cases
where it is useful to add information after the exception was caught. For this
purpose, exceptions have a methodadd_note(note)that accepts a string and
adds it to the exceptionâs notes list. The standard traceback rendering
includes all notes, in the order they were added, after the exception.

add_note(note)

>>>try:...raiseTypeError('bad type')...exceptExceptionase:...e.add_note('Add some information')...e.add_note('Add some more information')...raise...Traceback (most recent call last):File"<stdin>", line2, in<module>raiseTypeError('bad type')TypeError:bad typeAdd some informationAdd some more information>>>

For example, when collecting exceptions into an exception group, we may want
to add context information for the individual errors. In the following each
exception in the group has a note indicating when this error has occurred.

>>>deff():...raiseOSError('operation failed')...>>>excs=[]>>>foriinrange(3):...try:...f()...exceptExceptionase:...e.add_note(f'Happened in Iteration{i+1}')...excs.append(e)...>>>raiseExceptionGroup('We have some problems',excs)+ Exception Group Traceback (most recent call last):|   File "<stdin>", line 1, in <module>|     raise ExceptionGroup('We have some problems', excs)| ExceptionGroup: We have some problems (3 sub-exceptions)+-+---------------- 1 ----------------| Traceback (most recent call last):|   File "<stdin>", line 3, in <module>|     f()|     ~^^|   File "<stdin>", line 2, in f|     raise OSError('operation failed')| OSError: operation failed| Happened in Iteration 1+---------------- 2 ----------------| Traceback (most recent call last):|   File "<stdin>", line 3, in <module>|     f()|     ~^^|   File "<stdin>", line 2, in f|     raise OSError('operation failed')| OSError: operation failed| Happened in Iteration 2+---------------- 3 ----------------| Traceback (most recent call last):|   File "<stdin>", line 3, in <module>|     f()|     ~^^|   File "<stdin>", line 2, in f|     raise OSError('operation failed')| OSError: operation failed| Happened in Iteration 3+------------------------------------>>>